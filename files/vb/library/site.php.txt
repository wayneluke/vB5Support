<?php
/*========================================================================*\
|| ###################################################################### ||
|| # vBulletin 6.1.0 Alpha 4 Week 2 - Licence Number VBCW2VFT7A
|| # ------------------------------------------------------------------ # ||
|| # Copyright 2000-2024 MH Sub I, LLC dba vBulletin. All Rights Reserved.  # ||
|| # This file may not be redistributed in whole or significant part.   # ||
|| # ----------------- VBULLETIN IS NOT FREE SOFTWARE ----------------- # ||
|| # http://www.vbulletin.com | http://www.vbulletin.com/license.html   # ||
|| ###################################################################### ||
\*========================================================================*/

/**
 * vB_Library_Site
 *
 * @package vBLibrary
 */

class vB_Library_Site extends vB_Library
{
	// Assertor object
	protected $assertor;

	// fields for navbars -- everything else will be removed
	protected $fields = [
		'title' => vB_Cleaner::TYPE_STR,
		'phrase' => vB_Cleaner::TYPE_STR,
		'url' => vB_Cleaner::TYPE_STR,
		'routeid' => vB_Cleaner::TYPE_UINT,
		'route_guid' => vB_Cleaner::TYPE_STR,
		'attr' => vB_Cleaner::TYPE_STR,
		'usergroups' => vB_Cleaner::TYPE_ARRAY_UINT,
		'newWindow' => vB_Cleaner::TYPE_BOOL,
		'subnav' => vB_Cleaner::TYPE_ARRAY,
	];

	//all boolean fields need to be listed here because
	//"false" is an empty value.
	private $emptyAllowed = [
		'subnav',
		'usergroups',
		'phrase',
		'attr',
		'newWindow',

		// These are special in that at least ONE has to be filled.
		// See hasEmptyData()
		//'url',
		//'routeid',
		//'route_guid',
	];


	protected $sitescache = [];

	/**
	 * Array of cached channelInfo, used by getChannelType
	 * @var	array
	 */
	protected $channelInfo = [];

	/**
	 * Phrases that need to be cached for the navbar/footer items
	 *
	 * @var array
	 */
	protected $requiredPhrases = [];

	/**
	 * Cached phrases used for navbar/footer items
	 *
	 * @var array
	 */
	protected $phraseCache = [];

	/**
	 * Initializes an Api Site object
	 */
	public function __construct()
	{
		parent::__construct();

		$this->assertor = vB::getDbAssertor();
	}

	/**
	 * Stores the header navbar data.
	 *
	 * @param	int     $siteId   The storing data siteid (currently ignored).
	 * @param	mixed   $data     Array of elements containing data to be stored for header navbar. Elements might contain:
	 * 			title		--	string		Site title. *required
	 * 			url			--	string		Site url. *required
	 * 			usergroups	--	array		Array of ints.
	 * 			newWindow	--	boolean		Flag used to display site in new window. *required
	 * 			subnav		--	mixed		Array of subnav sites (containing same site data structure).
	 * 				id			--	int		Id of subnav site.
	 * 				title		--	string	Title of subnav site.
	 * 				url			--	string	Url of subnav site.
	 * 				usergroups	--	array	Array of ints.
	 * 				newWindow	--	boolean	Flag used to display subnav site in new window.
	 * 				subnav		--	mixed	Array of subnav sites (containing same site data structure).
	 * @param   bool   $titlesArePhraseTitles    If true, skip the phrase processing to push "title" into a phrase value, and replace "title" with
	 *                             the phrase key that it's stored under.
	 *                             Long version: When data is coming from sitebuilder, each navitem has 'title' and (optionally) 'phrase' keys,
	 *                             where 'title' is the display-title and 'phrase' (if set) is the phrase-key that the display-title value should
	 *                             be stored under. However, in the serialized data stored in the database, 'title' is the phrase-title. This makes
	 *                             fetching and storing data a bit difficult especially if you're handling the raw data that's not going through
	 *                             the various presentation steps... This flag exists to skip all that if you're not modifying the display-titles/
	 *                             phrase-values at all. This flag is currently used in the installer & upgrader.
	 *                             Note, if you do use this flag, you are responsible for ensuring that the phrases for navitem titles are actually
	 *                             added/updated. In other words, only use this flag if you're not modifying the title data at all.
	 *
	 * @return	boolean		To indicate if save was succesfully done.
	 */
	public function saveHeaderNavbar($siteId, $data, $titlesArePhraseTitles = false)
	{
		/** We expect an array of elements for cleaning */
		$cleanedData = [];
		foreach ($data AS $key => $element)
		{
			$cleanedData[$key] = $this->cleanData($element);
		}

		/** Required fields check */
		$this->hasEmptyData($cleanedData);
		$phrases = [];
		$this->processNavbar($cleanedData, $phrases, $titlesArePhraseTitles);

		//rebuild the language after saving phrases
		require_once(DIR . '/includes/adminfunctions.php');
		require_once(DIR . '/includes/adminfunctions_language.php');
		build_language(-1);

		/** At this point we can store the data */
		$cleanedData = serialize($cleanedData);
		$this->assertor->update('vBForum:site', ['headernavbar' => $cleanedData], vB_dB_Query::CONDITION_ALL);

		// reset cache
		$this->sitescache = [];
		return true;
	}

	// public to allow access from upgrader. Might want to have the upgrader just go through saveHeaderNavbar() / saveFooterNabar() instead,
	// but trying to limit unintended changes atm.
	public function processNavbar(&$navbar, &$phrases, $titlesArePhraseTitles = false)
	{
		foreach ($navbar AS &$element)
		{
			if (!$titlesArePhraseTitles)
			{
				// THIS NEEDS SOME REFACTORING. The crux of the problem seems to be, for
				// SOME REASON we switch the meaning of "title" between DB and frontend,
				// and the library layer is stuck with trying to figure out which the is what
				// and makes the library methods painful to use if you don't know all of the
				// mysteries and secrets. And then different places update the navbar via
				// direct queries vs using the save methods (probably because using the save
				// methods freaking sucks because of issues like this), and that puts
				// the whole damn thing in a refactor gridlock. We need to get this, and the
				// various permission checks OUT of the standard getter/setter type functions
				$this->saveNavbarPhrase($element, $phrases);
			}
			$this->updateUrlFromRoute($element);
			if (!empty($element['subnav']))
			{
				$this->processNavbar($element['subnav'], $phrases, $titlesArePhraseTitles);
			}
		}
	}

	/*
	public function flattenNavbarData($navbar) : array
	{
		$flattened = [];
		foreach ($navbar AS $__item)
		{
			$__copy = $__item;
			unset($__copy['subnav']);
			$flattened[] = $__copy;
			if (!empty($__item['subnav']))
			{
				$flattened = array_merge($flattened, $this->flattenNavbarData($__item['subnav']));
			}
		}

		return $flattened;
	}
	*/

	// public, this may be called as part of vB_Api_Page::setAsHomepage()
	public function updateUrlFromRoute(array &$element) : bool
	{
		// short circuit exit. If neither of this is set, below is a no-op anyways.
		if (empty($element['route_guid']) AND empty($element['routeid']))
		{
			// If this is just using hard-coded URLs, routeid may be 0 or not ever set in that case
			// Let's consistently clean the unused keys up.
			unset($element['route_guid'], $element['routeid']);
			return false;
		}

		// Precedence: route_guid, routeid, url.
		$assertor = vB::getDbAssertor();
		$route = [];
		if (!empty($element['route_guid']))
		{
			$route = $assertor->getRow('routenew', ['guid' => $element['route_guid']]);
			if ($route)
			{
				// Switch route_guid for routeid. The guid is only meant for install/import of default data,
				// and we don't want to revert future changes to this route or navitem.
				// Since we're serializing, let's keep the type consistent. routeid defaults to a string
				// coming out of the assertor, but upon resave it'll be cleaned as an int.
				$element['routeid'] = intval($route['routeid']);
				unset($element['route_guid']);
			}
		}
		else if (!empty($element['routeid']))
		{
			$route = $assertor->getRow('routenew', ['routeid' => $element['routeid']]);
		}

		// If have a route to use from above, overwrite/set the url.
		// We generate the URL on "write" (either navbar edit or updateRoute()) because
		// we don't want to be doing this looking up every page load.
		if ($route)
		{
			// This may not be set during vb4 -> vb5 upgrades, as we didn't add the
			// ishomeroute field until 544a4. Guard the field so upgrade tests pass.
			if (!empty($route['ishomeroute']))
			{
				$element['url'] = '/';
				return true;
			}
			else
			{
				try
				{
					$canonicalUrl = vB5_Route::buildUrl($route['routeid'] . '|nohomeurl');
					$element['url'] = $canonicalUrl;
					return true;
				}
				catch (vB_Exception_NodePermission $e)
				{
					// In rare cases, there might be a navitem that points to a URL/page that *this* current user does not
					// have permissions to view. That can cause an exception to be thrown in the route generation (e.g. channel routes)
					// There's currently not a great way around this, let's just skip this for now.
					return false;
				}
			}
		}

		return false;
	}

	/**
	 * Stores the footer navbar data.
	 *
	 * @param	int         The storing data siteid (currently ignored).
	 * @param	mixed       Array of data to be stored for footer navbar.
	 * 			title		--	string		Site title.
	 * 			url			--	string		Site url.
	 * 			usergroups	--	array		Array of ints.
	 * 			newWindow	--	boolean		Flag used to display site in new window.
	 * 			subnav		--	mixed		Array of subnav sites (containing same site data structure).
	 * 				id			--	int		Id of subnav site.
	 * 				title		--	string	Title of subnav site.
	 * 				url			--	string	Url of subnav site.
	 * 				usergroups	--	array	Array of ints.
	 * 				newWindow	--	boolean	Flag used to display subnav site in new window.
	 * 				subnav		--	mixed	Array of subnav sites (containing same site data structure).
	 * @param   bool         @see vB_Library_Site::saveHeaderNavbar()
	 *
	 * @return	boolean		To indicate if save was succesfully done.
	 */
	public function saveFooterNavbar($siteId, $data, $titlesArePhraseTitles = false)
	{
		/** We expect an array of elements for cleaning */
		$cleanedData = [];
		foreach ($data AS $key => $element)
		{
			$cleanedData[$key] = $this->cleanData($element);
		}

		/** Required fields check */
		$this->hasEmptyData($cleanedData);
		$phrases = [];
		$this->processNavbar($cleanedData, $phrases, $titlesArePhraseTitles);

		//rebuild the language after saving phrases
		require_once(DIR . '/includes/adminfunctions.php');
		require_once(DIR . '/includes/adminfunctions_language.php');
		build_language(-1);

		/** At this point we can store the data */
		$cleanedData = serialize($cleanedData);
		$this->assertor->update('vBForum:site', ['footernavbar' => $cleanedData], vB_dB_Query::CONDITION_ALL);

		// reset cache
		$this->sitescache = [];

		return true;
	}

	/**
	 * Gets the header navbar data
	 *
	 * @param	int		Site id requesting header data.
	 * @param	string		URL
	 * @param	int		Edit mode so allow all links if user can admin sitebuilder
	 * @param	int		Channel ID (optional, used to determine current header navbar tab)
	 *
	 * @return	mixed	Array of header navbar data (Described in save method).
	 */
	public function loadHeaderNavbar($siteId, $url = false, $edit = false, $channelId = 0)
	{
		return $this->getNavbar('header', $siteId, $url, $edit, $channelId);
	}

	/**
	 * Gets the footer navbar data
	 *
	 * @param	int		Site id requesting footer data.
	 * @param	string		URL
	 * @param	int		Edit mode so allow all links if user can admin sitebuilder
	 *
	 * @return	mixed	Array of footer navbar data (Described in save method).
	 */
	public function loadFooterNavbar($siteId, $url = false, $edit = false)
	{
		return $this->getNavbar('footer', $siteId, $url, $edit);
	}

	/**
	 * Gets the navbar data for the header or the footer
	 *
	 * @param	int		Site id requesting header/footer data. (currently ignored).
	 * @param	string		URL
	 * @param	int		Edit mode so allow all links if user can admin sitebuilder
	 * @param	int		Channel ID (optional, used to determine current header navbar tab)
	 *
	 * @return	mixed	Array of header/footer navbar data (Described in save method).
	 */
	private function getNavbar($type, $siteId, $url = false, $edit = false, $channelId = 0)
	{
		if (empty($this->sitescache))
		{
			// technically this *should* use $siteId, though we don't ever actually use any other siteid than 1...
			$queryParams = [vB_dB_Query::TYPE_KEY => vB_dB_Query::QUERY_SELECT];
			$this->sitescache = $this->assertor->getRow('vBForum:site', $queryParams);

			$header = vb_unserialize($this->sitescache['headernavbar']);
			$footer = vb_unserialize($this->sitescache['footernavbar']);

			try
			{
				$this->removeRestrictedTabs($header, $edit);
				$this->addDerivedData($header);

				$this->removeRestrictedTabs($footer, $edit);
				$this->addDerivedData($footer);

				//Mark which tabs are the current page.  We don't do much with it in the footer but the class is there
				//and ther is some css associated with it (which should most likely get cleaned up.
				if ($url OR $channelId)
				{
					$this->markCurrentTab($header, $url, $edit, $channelId);
					$this->markCurrentTab($footer, $url, $edit, $channelId);
				}
			}
			catch (Exception $e)
			{
				// This only really happens in unit tests, but if we hit an exception during the preparation above,
				// it means never finished saving the _prepared data to memory. If multiple calls to loadHeaderNavbar()
				// are made, it can cause weird behavior.
				// On a related note, the fact that we don't cache by $channelId means that only the *first valid*
				// (no exception) loadHeaderNavbar() call will be guaranteed to be correct. . .
				$this->sitescache = [];
				throw $e;
			}

			// when editing, phrases need to be loaded from language 0 specifically
			// other language translations can be edited in the Admin CP
			// when not editing, phrases are pulled via the template tag vb:phrase
			if ($edit)
			{
				$this->cachePhrases($edit);
				$this->addPhrasesToData($header);
				$this->addPhrasesToData($footer);
			}

			$this->sitescache['headernavbar_prepared'] = $header;
			$this->sitescache['footernavbar_prepared'] = $footer;
		}

		return $this->sitescache[$type . 'navbar_prepared'];
	}

	/*
	public function getUnrestrictedNavbars() : array
	{
		// the removeRestrictedTabs() calls (& anything else that checks permissions and throws exceptions)
		// should be part of the API instead, but what I'm currently working on is already kind of blowing
		// up in scope and so I'm trying to heavily restrict my changes/regression risk.
		// For now just duplicating most of the code of getNavBar().
		$siteId = 1;
		$site = $this->assertor->getRow('vBForum:site', ['siteid' => $siteId]);
		if (empty($site))
		{
			return [
				'headernavbar' => [],
				'footernavbar' => [],
			];
		}
		$header = vb_unserialize($site['headernavbar']);
		$footer = vb_unserialize($site['footernavbar']);

		$this->addDerivedData($header);
		$this->addDerivedData($footer);

		$this->cachePhrases(true);

		$this->addPhrasesToData($header);
		$this->addPhrasesToData($footer);
		return [
			'headernavbar' => $header,
			'footernavbar' => $footer,
		];
	}
	*/


	private function markCurrentTab(array &$data, $url, $edit, $channelId)
	{
		$baseurl = vB::getDatastore()->getOption('frontendurl');
		$baseurl_short = vB_String::parseUrl($baseurl, PHP_URL_PATH);

		//if we don't have a url or we are at the root we're basically going
		//to match a bunch of things of dubious merit.
		//
		//We'll default to the root url (if it's in the nav) if we don't find anything else
		if ($url)
		{
			if ($this->setBestMatchFromUrl($data, $baseurl, $baseurl_short, $url))
			{
				return;
			}
		}

		$channelId = (int) $channelId;
		if ($channelId > 0)
		{
			//this is a little bogus, but some people have change the url on the
			//base pages without changing the navbar.  This will continue to work
			//in some cases because of 301 redirects and this logic mapping to the
			//default tab urls.  Leaving it in to prevent existing sites from
			//randomly breaking on upgrade.
			$channelTabMap = [
				'blog' => 'blogs',
				'group' => 'social-groups',
				'article' => 'articles',
			];

			$type = $this->getChannelType($channelId);
			if (isset($channelTabMap[$type]))
			{
				if ($this->setBestMatchFromUrl($data, $baseurl, $baseurl_short, $baseurl_short . '/' . $channelTabMap[$type]))
				{
					return;
				}
			}

			$channelApi = vB_Api::instance('content_channel');
			$topChannels = $channelApi->fetchTopLevelChannelIds();
			if (isset($topChannels[$type]))
			{
				//we have an (unused) channel page for the forum channel that is distinct from the
				//"home" page which is what most people associate with the forums.  This
				//is unfortunate, but it's going to be difficult to unwind at this point.
				//so let's work around it.
				$channelid = ($type == "forum" ? 1 : $topChannels[$type]);

				$channel = $channelApi->getBareContent($channelid);
				// Some forums may have a top level channel blocked for non-admins. Avoid errors in that case.
				if (empty($channel['errors']))
				{
					$channel = reset($channel);
					$url = vB5_Route::buildUrl($channel['routeid']);

					//the channel url starts with '/' from the route even though it shouldn't
					//however the implications of correcting this are a little scary so it hasn't
					//happened yet.  The ltrim future proofs this so it won't break if we
					//fix it.
					$url = $baseurl_short . '/' . ltrim($url, '/');
					if ($this->setBestMatchFromUrl($data, $baseurl, $baseurl_short, $url))
					{
						return;
					}
				}
			}
		}

		//try to find the root page
		if ($this->setBestMatchFromUrl($data, $baseurl, $baseurl_short, $baseurl_short . '/'))
		{
			return;
		}

		//mark the first tab so *something* is highlighted.
		$data[0]['current'] = true;
	}

	private function setBestMatchFromUrl(array &$data, $baseurl, $baseurl_short, $url)
	{
		$bestMatchTab = null;
		$bestMatchLength = 0;

		foreach ($data AS $k => &$item)
		{
			if (!empty($item['subnav']) AND is_array($item['subnav']))
			{
				foreach ($item['subnav'] AS $subKey => &$subItem)
				{
					$matchLen = $this->getPossibleTabMatchLength($baseurl, $baseurl_short, $subItem, $url);
					if ($matchLen > $bestMatchLength)
					{
						//deliberately track the parent tab and not the subtab
						$bestMatchTab = &$item;
						$bestMatchLength = $matchLen;
					}
				}
			}

			$matchLen = $this->getPossibleTabMatchLength($baseurl, $baseurl_short, $item, $url);
			if ($matchLen > $bestMatchLength)
			{
				$bestMatchTab = &$item;
				$bestMatchLength = $matchLen;
			}
		}

		if ($bestMatchLength > 0)
		{
			$bestMatchTab['current'] = true;
			return true;
		}

		return false;
	}

	private function getPossibleTabMatchLength($baseurl, $baseurl_short, $item, $currentUrl)
	{
		//try to normalize the item url against what we get passed as the "currentUrl"
		if ($item['isAbsoluteUrl'])
		{
			//if the absolute url for doesn't match the site path, then we should never
			//flag it.  However if the path happens to be a prefix of baseurl, then it
			//*can* trigger a match in the logic below.  When that happens and we don't
			//have a better match then we'll use it -- potentially at the expense of
			//other, better rules that we would fall to without a match.
			if (strpos($item['normalizedUrl'], $baseurl) !== 0)
			{
				return 0;
			}

			$itemUrl = vB_String::parseUrl($item['normalizedUrl'], PHP_URL_PATH);
		}
		else
		{
			$itemUrl = $baseurl_short . '/' . $item['normalizedUrl'];
		}

		$currentLower = strtolower($currentUrl);
		$itemLower = strtolower($itemUrl);
		$currentLen = strlen($currentUrl);
		$itemLen = strlen($itemUrl);

		//exact match, this is probably the winner
		if ($currentLower == $itemLower)
		{
			return $itemLen;
		}

		//if the url we are testing is longer than the tab/subtab url then we might have
		//a match.  However we don't want to test if the item url is blank because that
		//can cause spurious matches (the base_url will match *anything*) and prevent
		//fall through to some of the the other match urls (channel based, etc)
		if ($item['normalizedUrl'] AND $currentLen > $itemLen)
		{
			//$itemLower is a prefix of $currentUrl then we have a possible match.  Return the
			//prefix length so we can compute the best one
			$prefixLower = strtolower(substr($currentUrl, 0, -($currentLen - $itemLen)));
			if ($prefixLower == $itemLower)
			{
				return $itemLen;
			}
		}

		return 0;
	}

	private function addDerivedData(array &$data)
	{
		foreach ($data AS $k => &$item)
		{
			$this->addDerivedDataToItem($item);
			if (!empty($item['subnav']) AND is_array($item['subnav']))
			{
				foreach ($item['subnav'] AS $subKey => &$subItem)
				{
					$this->addDerivedDataToItem($subItem);
				}
			}
		}
	}

	private function addDerivedDataToItem(array &$item)
	{
		//not entirely sure what purpose this serves
		// update: important -- this is meant to preregister all
		// of the navbar_links phrases for header & footer
		// for the following sequence of calls --
		// addDerivedData(), cachePhrases(), addPhrasesToData()
		// so that we fetch all of the navitem titles in bulk in
		// cachePhrases() before they're used in addPhrasesToData().
		// IMO this is bad because it adds a dependency/awareness amongst
		// those three functions that's difficult to grasp unless
		// you happen to be familiar with all of the functions,
		// and we should probably refactor to make each function
		// atomic. The performance gain of doing it that way
		// is probably marginal at best. If anything we should
		// just pull the whole 'navbarlinks' phrase group for the
		// languageid we want, and eat the memory cost of potentially
		// unused phrases (e.g. if some navitems are removed due to
		// removeRestrictedTabs(), or if we don't clean them up when
		// navitems are removed)
		$this->requiredPhrases[] = $item['title'];

		$item['phrase'] = $item['title'];
		$item['isAbsoluteUrl'] = (bool) preg_match('#^(https?://|mailto:)#i', $item['url']);
		$item['normalizedUrl'] = ltrim($item['url'], '/');
		$item['newWindow'] = ($item['newWindow'] ? 1 : 0);
	}

	private function removeRestrictedTabs(array &$data, $edit = false)
	{
		$canusesitebuilder = vB::getUserContext()->hasAdminPermission('canusesitebuilder');

		$userinfo = vB_Api::instanceInternal('user')->fetchCurrentUserInfo();
		$usergroups = [];
		if ($userinfo['membergroupids'])
		{
			$usergroups = explode(',', $userinfo['membergroupids']);
		}
		$usergroups[] = $userinfo['usergroupid'];
		sort($usergroups);

		$showAll = ($edit AND $canusesitebuilder);

		$removed_element = false;
		foreach ($data AS $k => &$item)
		{
			if ($this->shouldRemoveItem($showAll, $usergroups, $item))
			{
				unset($data[$k]);
				$removed_element = true;
			}
			else
			{
				if (!empty($item['subnav']) AND is_array($item['subnav']))
				{
					$removed_element_sub = false;
					foreach ($item['subnav'] AS $subKey => &$subItem)
					{
						if ($this->shouldRemoveItem($showAll, $usergroups, $subItem))
						{
							unset($item['subnav'][$subKey]);
							$removed_element_sub = true;
						}
					}

					if ($removed_element_sub)
					{
						$item['subnav'] = array_values($item['subnav']);
					}
				}
			}
		}

		// Reset the keys of the array, because in js it will be considered as an object
		// Only want to do if needed (and only once per array) since it can be expensive.
		if ($removed_element)
		{
			$data = array_values($data);
		}
	}

	private function shouldRemoveItem($showAll, $usergroups, array $item)
	{
		//not sure if this is still needed.  It was added with a cryptic comment about
		//making unit tests pass and skips some processing we should always be doing
		//More over each item should be an array with a url field -- if that's not
		//true we have a problem.  So we'll just quietly remove it here and assume
		//it's good later.  This is a change of behavior from previously.
		if (!is_array($item) OR !isset($item['url']))
		{
			return true;
		}

		//if we aren't showing everything and we have usergroups set in the item
		//we might want to hide the tab (no usergroups means allow all)
		else if (!$showAll AND !empty($item['usergroups']))
		{
			$itemgroups = $item['usergroups'];
			sort($itemgroups);

			if (!$this->compareGroupLists($usergroups, $itemgroups))
			{
				return true;
			}
		}

		return false;
	}

	/**
	 *	Returns true if any of needle exist in haystack
	 *
	 *	*ASSUMES THAT BOTH NEEDLE AND HAYSTACK ARE SORTED ASCENDING*
	 *
	 *	@param array $needle
	 *	@param array $haystack
	 *	@return bool
	 */
	private function compareGroupLists($needle, $haystack)
	{
		$needleindex = 0;
		$needlelen = count($needle);

		$haystackindex = 0;
		$haystacklen = count($haystack);

		//while we haven't hit the end of the array
		while (($needleindex < $needlelen) AND ($haystackindex < $haystacklen))
		{
			if ($needle[$needleindex] == $haystack[$haystackindex])
			{
				return true;
			}
			else if ($needle[$needleindex] < $haystack[$haystackindex])
			{
				$needleindex++;
			}
			else
			{
				$haystackindex++;
			}
		}

		//we hit the end of one of the lists without finding a match
		return false;
	}


	/**
	 * Returns the channel type for the given channel ID
	 * @param  int          The channel associated with the page.  If a non channel node is provided
	 * 											we will use that nodes channel instead.
	 * @return string|false The channel type, or an false if there was a problem,
	 *                      for example the user doesn't have access to the channel.
	 */
	protected function getChannelType($channelId)
	{
		if (!isset($this->channelInfo[$channelId]))
		{
			try
			{
				//this is supposed to be a channel id but it isn't always.  However all we actually care about is the
				//channel type, which is set for any node based on its ancestor channel.  If we ever need more
				//information about the channel than that we can explicitly look up the node's channel if it isn't
				//one already.
				/** @var vB_Library_Node */
				$nodeLib = vB_Library::instance('node');
				$foundChannelid = $nodeLib->getChannelId($channelId);
				/** @var array{int:string} */
				$channelTypes = vB::getDatastore()->getValue('vBChannelTypes');
				// Not known to happen, but just in case -- fallback to false to match "error" return behavior below if failed to find the channel.
				$this->channelInfo[$channelId]['channeltype'] = $channelTypes[$foundChannelid] ?? false;
			}
			catch (vB_Exception_Api $e)
			{
				if ($e->has_error('no_permission'))
				{
					return false;
				}
				else
				{
					throw $e;
				}
			}
		}

		if (isset($this->channelInfo[$channelId]) AND isset($this->channelInfo[$channelId]['channeltype']))
		{
			return $this->channelInfo[$channelId]['channeltype'];
		}

		return false;
	}

	protected function cachePhrases($edit = false)
	{
		if (!empty($this->requiredPhrases))
		{
			// when editing, use the default language phrase
			// translations can be made in the Admin CP.
			// instanceinternal?
			$this->phraseCache = vB_Api::instance('phrase')->fetch($this->requiredPhrases, ($edit ? 0 : null));
			$this->requiredPhrases = [];
		}
	}

	protected function addPhrasesToData(&$data)
	{
		foreach ($data as $k => &$item)
		{
			$item['phrase'] = $item['title'];
			$item['title'] = (isset($this->phraseCache[$item['phrase']]) AND !empty($this->phraseCache[$item['phrase']]))
				? $this->phraseCache[$item['phrase']] : $item['phrase'];

			if (!empty($item['subnav']) AND is_array($item['subnav']))
			{
				$this->addPhrasesToData($item['subnav']);
			}
		}
	}

	/**
	 * Check if data array is empty
	 *
	 * @param	mixed		Array of site data (described in save methods) to check.
	 *
	 * @throws 	Exception	missing_required_field if there's an empty field in site data.
	 */
	protected function hasEmptyData($data)
	{
		if (empty($data) OR !is_array($data))
		{
			throw new vB_Exception_Api('missing_required_field');
		}

		foreach ($data AS $field => $value)
		{
			//it's O.K. to have some empty fields.
			//we have both numeric and named fields that flow through here -- the numeric ones
			//are for tabs/subtabs as a whole and hit the recursive call below.  However because
			//of nastiness with PHPs auto type conversions, 0 == 'subnav' is true (even indirectly
			//with functions like in_array) so we validate that $field is not an empty value
			//to avoid a case.  It shouldn't matter anyway since empty($value) should never be
			//true for field 0 but a previous version of this code had a flaw were that wasn't checked
			//properly.  It's best to be completely correct here.
			if (!empty($field) AND (empty($value)) AND in_array($field, $this->emptyAllowed))
			{
				continue;
			}

			if (is_array($value))
			{
				$this->hasEmptyData($value);
			}
			else
			{
				// We just need ONE of these fields
				if (in_array($field, ['url', 'routeid', 'route_guid']))
				{
					if (!empty($data['url']) OR
						!empty($data['routeid']) OR
						!empty($data['route_guid'])
					)
					{
						continue;
					}
				}

				if (empty($value))
				{
					throw new vB_Exception_Api('missing_required_field');
				}
			}
		}
	}

	protected function cleanData($data)
	{
		/** should be an array data */
		if (!is_array($data))
		{
			throw new vB_Exception_Api('invalid_data');
		}


		$cleanerObj = vB::getCleaner();
		foreach ($data AS $fieldKey => $fieldVal)
		{
			if (isset($this->fields[$fieldKey]))
			{
				//if the field isn't present, don't add it.
				if (isset($data[$fieldKey]))
				{
					// clean array of subnav items properly
					if ($fieldKey === 'subnav')
					{
						foreach ($data[$fieldKey] AS $idx => $val)
						{
							$data[$fieldKey][$idx] = $this->cleanData($data[$fieldKey][$idx]);
						}
					}
					else
					{
						$data[$fieldKey] = $cleanerObj->clean($data[$fieldKey], $this->fields[$fieldKey]);
					}
				}
			}
			else
			{
				unset($data[$fieldKey]);
			}
		}

		return $data;
	}

	private function saveNavbarPhrase(&$element, &$phrases)
	{
		if (
			!isset($element['phrase']) OR
			empty($element['phrase']) OR
			strpos($element['phrase'], 'navbar_') !== 0 OR
			/* we cannot have two different values for the same phrase */
			(isset($phrases[$element['phrase']]) AND $phrases[$element['phrase']] != $element['title'])
		)
		{
			$words = explode(' ', $element['title']);
			$words = array_map('trim', $words);
			$phrase = strtolower(implode('_', $words));

			//translating some special characters to their latin form
			$phrase = vB_String::latinise($phrase);

			// remove any invalid chars
			$phrase = preg_replace('#[^' . vB_Library_Phrase::VALID_CLASS . ']+#', '', $phrase);

			$phrase = 'navbar_' . $phrase;

			$suffix = 0;
			$tmpPhrase = $phrase;
			while (isset($phrases[$tmpPhrase]) AND $phrases[$tmpPhrase] != $element['title'])
			{
				$tmpPhrase = $phrase . (++$suffix);
			}

			$element['phrase'] = $tmpPhrase;
		}

		// Store the phrase-value so that we can check
		$phrases[$element['phrase']] = $element['title'];

		$existingPhrases = vB::getDbAssertor()->getRows('phrase', [
			'varname' => $element['phrase'],
		]);

		// don't destroy translations
		$text = [];
		foreach ($existingPhrases AS $existingPhrase)
		{
			$text[$existingPhrase['languageid']] = $existingPhrase['text'];
		}
		// the edited phrase
		$text[0] = $element['title'];

		vB_Library::instance('phrase')->save(
			'navbarlinks',
			$element['phrase'],
			[
				'text' => $text,
				'oldvarname' => $element['phrase'],
				'oldfieldname' => 'navbarlinks',
				't' => 0,
				'ismaster' => 0,
				'product' => 'vbulletin'
			],
			true
		);

		// store phrase name instead of title
		$element['title'] = $element['phrase'];
		unset($element['phrase']);

		/*
		// do the same for subnavigation
		if (isset($element['subnav']) AND !empty($element['subnav']))
		{
			foreach ($element['subnav'] AS &$subnav)
			{
				$this->saveNavbarPhrase($subnav, $phrases);
			}
		}
		*/
	}

	/**
	 * Returns an array of general statistics for the site
	 *
	 * @return	array	Statistics.
	 */
	public function getSiteStatistics()
	{
		$statistics = [];

		// topics & posts
		$topChannels = vB_Api::instanceInternal('Content_Channel')->fetchTopLevelChannelIds();
		$forumStats = vB_Api::instanceInternal('Node')->getChannelStatistics($topChannels['forum']);
		$statistics['topics'] = $forumStats['topics'];
		$statistics['posts'] = $forumStats['posts'];

		// members
		$userstats = vB::getDatastore()->getValue('userstats');
		$statistics['members'] = $userstats['numbermembers'];
		$statistics['activeMembers'] = $userstats['activemembers'];

		// latest member
		$statistics['newuser'] = [
			'username' => $userstats['newusername'],
			'userid' => $userstats['newuserid'],
		];

		return [
			'statistics' => $statistics,
		];
	}

	/**
	 * Called by vB5_Route::updateRoute() to automatically update any header navbar items that are linked
	 * to routes/pages.
	 */
	public function onRouteUpdate(int $oldrouteid, int $newrouteid, array $oldHomeRouteids = [], array $deletedRouteids = []) : void
	{
		$routesForURLUpdates = [];
		$routesForURLUpdates[$oldrouteid] = 1;
		$routesForURLUpdates[$newrouteid] = 1;
		// Trivial case, no url change.
		if ($oldrouteid != $newrouteid)
		{
		}

		foreach ($oldHomeRouteids AS $__routeid)
		{
			// trivial case, this was already home
			if ($__routeid == $newrouteid)
			{
				continue;
			}
			$routesForURLUpdates[$__routeid] = 1;
		}

		// todo: when can deletedRouteids happen
		$deletedRouteids = array_combine($deletedRouteids, $deletedRouteids);

		$siteId = 1;
		$url = false;
		$edit = 1;
		$channelId = 0;
		$headerNav = $this->getNavbar('header', $siteId, $url, $edit, $channelId);
		$changed = $this->updateNavitemsRoutesRecursively($headerNav, $oldrouteid, $newrouteid, $routesForURLUpdates, $deletedRouteids);
		if ($changed)
		{
			$this->saveHeaderNavbar($siteId, $headerNav);
		}


		$footerNav = $this->getNavbar('footer', $siteId, $url, $edit);
		$changed = $this->updateNavitemsRoutesRecursively($footerNav, $oldrouteid, $newrouteid, $routesForURLUpdates, $deletedRouteids);
		if ($changed)
		{
			$this->saveFooterNavbar($siteId, $footerNav);
		}
	}

	private function updateNavitemsRoutesRecursively(&$navgroup, $oldrouteid, $newrouteid, $changedRouteidsKeyed, $deletedRouteidsKeyed) : bool
	{
		$changed = false;
		foreach ($navgroup AS &$__item)
		{
			$__routeid = $__item['routeid'] ?? 0;
			// If the URL changed & thus a new route was created, update any navitems using the old routeid.
			if ($oldrouteid != $newrouteid AND $__routeid == $oldrouteid)
			{
				$__item['routeid'] = $newrouteid;
				$changed = true;
			}
			if (isset($changedRouteidsKeyed[$__routeid]))
			{
				// This is mainly to catch old homeroute navitems and signal for an update.
				// Its URL will be corrected from '/' to the canonical URL by the saveHeaderNav() downstream logic.
				$changed = true;
			}

			if (!empty($__item['subnav']))
			{
				$__thischanged = $this->updateNavitemsRoutesRecursively($__item['subnav'], $oldrouteid, $newrouteid, $changedRouteidsKeyed, $deletedRouteidsKeyed);
				$changed = $changed || $__thischanged;
			}

		}

		/*
		$changed = false;
		$routeid = $element['routeid'] ?? 0;

		// If the URL changed & thus a new route was created, update any navitems using the old routeid.
		if ($oldrouteid != $newrouteid AND $routeid == $oldrouteid)
		{
			$element['routeid'] = $newrouteid;
			$changed = true;
		}


		if (isset($changedRouteidsKeyed[$routeid]))
		{
			// This is mainly to catch old homeroute navitems and signal for an update.
			$changed = true;
		}

		// do the same for subnavigation
		if (isset($element['subnav']) AND !empty($element['subnav']))
		{
			foreach ($element['subnav'] AS &$subnav)
			{
				$changed = $this->updateNavitemsRoutesRecursively($subnav, $oldrouteid, $newrouteid, $changedRouteidsKeyed, $deletedRouteidsKeyed) || $changed;
			}
		}
		*/

		return $changed;
	}

	/**
	 * Get default navbar data for 'blog', 'articles', and 'groups' header tabs
	 *
	 * @param bool $queryUsergroups  Optional, default false. If true, will query the `usergroup` table to get the usergroups that
	 *                               can create blogs and groups for the "create a new blog" and "create a new group" subnav
	 *                               items.
	 *
	 * @return array    ['blog' => [..], 'articles' => [..], 'groups' => [..]]
	 */
	public function getDefaultHeaderNavbarItems(bool $queryUsergroups = false) : array
	{
		$defaults = [
			// This is more of a generic home tab, but the label *does* say "Forums" so I guess we should associate it with the
			// forum channel.
			'forum' => [
				'title' => 'navbar_home',
				'url' => '/',
				'route_guid' => vB_Library_Route::GUID_HOME,
				'newWindow' => 0,
				'subnav' => [
					[
						'title' => 'navbar_newtopics',
						'url' => 'search?searchJSON=%7B%22view%22%3A%22topic%22%2C%22unread_only%22%3A1%2C%22sort%22%3A%7B%22lastcontent%22%3A%22desc%22%7D%2C%22exclude_type%22%3A%5B%22vBForum_PrivateMessage%22%5D%7D',
						'newWindow' => 0,
						'usergroups' => [2,5,6,7,9,10,11,12,13,14],
					],
					[
						'title' => 'navbar_todays_posts',
						'url' => 'search?searchJSON=%7B%22last%22%3A%7B%22from%22%3A%22lastDay%22%7D%2C%22view%22%3A%22topic%22%2C%22starter_only%22%3A+1%2C%22sort%22%3A%7B%22lastcontent%22%3A%22desc%22%7D%2C%22exclude_type%22%3A%5B%22vBForum_PrivateMessage%22%5D%7D',
						'newWindow' => 0,
						'usergroups' => [1],
					],
					[
						'title' => 'navbar_whos_online',
						'url' => 'online',
						'route_guid' => 'vbulletin-4ecbdacd6a8725.49820977',
						'newWindow' => 0,
						'usergroups' => [2,5,6,7,9,10,11,12,13,14],
					],
					[
						'title' => 'navbar_member_list',
						'url' => 'memberlist',
						'route_guid' => 'vbulletin-4ecbdacd6a8725.49820978',
						'newWindow' => 0,
						'usergroups' => 0,
					],
					[
						'title' => 'navbar_calendar',
						'url' => 'calendar',
						'route_guid' => 'vbulletin-route-calendar-58af7c31d90530.47875165',
						'newWindow' => 0,
					],
				]
			],
			'blog' => [
				'title' => 'navbar_blogs',
				'url' => 'blogs',
				'route_guid' => vB_Library_Route::GUID_BLOGS,
				'newWindow' => 0,
				'subnav' => [
					[
						'title' => 'navbar_create_a_new_blog',
						'url' => 'blogadmin/create/settings',
						'newWindow' => 0,
						'usergroups' => [2,5,6,7,9,10,11,12,13,14],
					],
					[
						'title' => 'navbar_newentries',
						'url' => 'search?searchJSON=%7B%22date%22%3A%22lastVisit%22%2C%22view%22%3A%22topic%22%2C%22unread_only%22%3A1%2C%22sort%22%3A%7B%22lastcontent%22%3A%22desc%22%7D%2C%22exclude_type%22%3A%5B%22vBForum_PrivateMessage%22%5D%2C%22channel%22%3A%5B%225%22%5D%7D',
						'newWindow' => 0,
					],
				]
			],
			'articles' => [
				'title' => 'navbar_articles',
				'url' => 'articles',
				'route_guid' => vB_Library_Route::GUID_ARTICLES,
				'newWindow' => 0,
			],
			'groups' => [
				'title' => 'navbar_social_groups',
				'url' => 'social-groups',
				'route_guid' => vB_Library_Route::GUID_SOCIALGROUPS,
				'newWindow' => 0,
				'subnav' => [
					[
						'title' => 'navbar_create_a_new_group',
						'url' => 'sgadmin/create/settings',
						'newWindow' => 0,
						'usergroups' => [2,5,6,7,9,10,11,12,13,14]
					],
				]
			],
		];

		// for post-install setup, in case usergroup perms have changed, query the `usergroup` permissions for blog & group creation
		if ($queryUsergroups)
		{
			$assertor = vB::getDbAssertor();
			$datastore = vB::getDatastore();

			$forumpermissions = $datastore->getValue('bf_ugp_forumpermissions');
			$canCreateBlogGroups = $assertor->getColumn('usergroup',
				'usergroupid',
				[
					vB_dB_Query::CONDITIONS_KEY => [
						['field' => 'forumpermissions', 'value' => $forumpermissions['cancreateblog'], 'operator' => vB_dB_Query::OPERATOR_AND]
					]
				]
			);
			$defaults['blog']['subnav'][0]['usergroups'] = $canCreateBlogGroups;

			$socialgrouppermissions = $datastore->getValue('bf_ugp_socialgrouppermissions');
			$canCreateGroupGroups = $assertor->getColumn('usergroup',
				'usergroupid',
				[
					vB_dB_Query::CONDITIONS_KEY => [
						['field' => 'forumpermissions', 'value' => $socialgrouppermissions['cancreategroups'], 'operator' => vB_dB_Query::OPERATOR_AND]
					]
				]
			);
			$defaults['groups']['subnav'][0]['usergroups'] = $canCreateGroupGroups;
		}

		return $defaults;
	}

	/**
	 * Go through the provided $navbar array, and returns a map of the $navbar array-keys for elements that correspond to certain
	 * default channels. This is meant to check if the default items defined in getDefaultHeaderNavbarItems() are present in the
	 * provided $navbar array, but may not be exactly accurate as it only checks for the routeid when present, or a matching title
	 * & URL when routeid is not present.
	 * If a channel is present multiple times, it is undefined which key will be returned.
	 *
	 * @param array $navbar  array from loadHeaderNavbar()
	 *
	 * @return array<string,int> channelname => $navbar key
	 */
	public function associateChannelsWithNavbarItems(array $navbar) : array
	{
		// So conceptually, this is simple.
		// Just go through the header $navbar and see if the default
		// forum, blog, articles, groups items are present.
		// In practice, we don't have a way to mark a system generated/default tab vs a customized one,
		// so unless we check every single piece of data, we don't know for sure if it's a default or not.
		// For now, let's first check if the associated routeid matches if we have one, if not, let's
		// check the url against the prefix.
		[
			'idToChannel' => $idToChannel,
			'preficesToChannel' => $preficesToChannel,
			'homeRouteid' => $homeRouteid,
		] = $this->getDefaultNavbarRouteids();

		$presentDefaultNavItems = [];
		foreach ($navbar AS $__key => $__item)
		{
			$__title = $__item['title'];
			$__trimmedUrl = ltrim($__item['url'], '/');
			$__routeid = $__item['routeid'] ?? 0;
			$__channelname = '';

			// Home check. Needs to be separate as it may share a routeid with a named channel (e.g. forum on default)
			if (
				// default forum tab
				$homeRouteid AND $__routeid AND $__routeid == $homeRouteid OR
				// If we don't have a routeid or it doesn't match, but url is empty, this is probably the home tab.
				// The system inserted sparse home tab doesn't have a routeid so it matches this.
				$__trimmedUrl == ''
			)
			{
				// Note this 'home' key MAY also match a channel key below if a top level channel is also the home (e.g. forum for
				// default installs), but that is not guaranteed, depending on the current state of the navbar.
				// For that reason, we always try to perform a merge of the navbar item when activating a channel associated with
				// home in vB_Api_Content_Channel::toggleDefaultHeaderNavbars()
				$presentDefaultNavItems['home'] = $__key;
			}

			// Specific channel has a tab
			if (isset($idToChannel[$__routeid]))
			{
				$__channelname = $idToChannel[$__routeid];
				$presentDefaultNavItems[$__channelname] = $__key;
			}
			else if (isset($preficesToChannel[$__trimmedUrl]))
			{
				$__channelname = $preficesToChannel[$__trimmedUrl];
				$presentDefaultNavItems[$__channelname] = $__key;
			}
			// Check default URLs
			else {
				if ($__title == 'navbar_home' AND $__trimmedUrl == 'forum')
				{
					$__channelname = 'forum';
				}
				else if ($__title == 'navbar_blogs' AND $__trimmedUrl == 'blogs')
				{
					$__channelname = 'blog';
				}
				else if ($__title == 'navbar_articles' AND $__trimmedUrl == 'articles')
				{
					$__channelname = 'articles';
				}
				else if ($__title == 'navbar_social_groups' AND $__trimmedUrl == 'social-groups')
				{
					$__channelname = 'groups';
				}
				else if ($__title == 'navbar_homepage' AND $__trimmedUrl == '')
				{
					$__channelname = 'home';
				}

				// If we don't already have a better (routeid) match and found a likely match, let's use it.
				if ($__channelname AND empty($presentDefaultNavItems[$__channelname]))
				{
					$presentDefaultNavItems[$__channelname] = $__key;
				}
			}
		}

		return $presentDefaultNavItems;
	}

	/**
	 * Fetch routeids for the default navbar items
	 *
	 * @return array{
	 *             channelToIds: array<string,int>,
	 *             idToChannel: array<int,string>
	 *             preficesToChannel: array<string,string>,
	 *             homeRouteid: int
	 *         }
	 */
	private function getDefaultNavbarRouteids() : array
	{
		$guidToChannelname = [
			vB_Library_Route::GUID_HOME => 'forum',
			vB_Library_Route::GUID_HOME => 'forum',
			vB_Library_Route::GUID_HOME => 'forum',

			vB_Library_Route::GUID_BLOGS => 'blog',
			vB_Library_Route::GUID_ARTICLES => 'articles',
			vB_Library_Route::GUID_SOCIALGROUPS => 'groups',

		];

		// $guidsToLookup = array_column($defaults, 'route_guid');
		// // After the install, we *should* have routeid rather than route_guid (for default items, modified or hard-coded
		// // URLs do not have routeid's), but just in case...
		// if (!empty($navbaritem['route_guid']) AND empty($navbaritem['routeid']))
		// {
		// 	$guidsToLookup[] = $navbaritem['route_guid'];
		// }
		$assertor = vB::getDbAssertor();
		$guidToId = $assertor->getRows('routenew', ['guid' => array_keys($guidToChannelname)], false, 'guid');
		$homeroute = $assertor->getRow('routenew', ['ishomeroute' => 1]);
		$channelToIds = [];
		$idToChannel = [];
		foreach ($guidToId AS $__guid => $__row)
		{
			$__routeid = $__row['routeid'];

			$__channelname = $guidToChannelname[$__guid];

			// There might be multiple routeids per channel (namely the forum channel)
			$channelToIds[$__channelname][] = $__routeid;
			$idToChannel[$__routeid] = $__channelname;
			$preficesToChannel[$__row['prefix']] = $__channelname;
		}

		if (empty($preficesToChannel['']))
		{
			// This is to help map when a navbar has '/' or '' as the URL, and the home page is a channel.
			// E.g. by default, forums tab is the home page with URL = '/', and depending on how old the install is
			// or if the admin touched the navbar, the routeid field may or may not be set properly.
			if (isset($guidToChannelname[$homeroute['guid']]))
			{
				$preficesToChannel[''] = $guidToChannelname[$homeroute['guid']];
			}
		}

		return [
			'channelToIds' => $channelToIds,
			'idToChannel' => $idToChannel,
			'preficesToChannel' => $preficesToChannel,
			'homeRouteid' => $homeroute['routeid'] ?? 0,
		];
	}
}

/*=========================================================================*\
|| #######################################################################
|| # Downloaded: 12:50, Tue Dec 24th 2024
|| # CVS: $RCSfile$ - $Revision: 117156 $
|| #######################################################################
\*=========================================================================*/
