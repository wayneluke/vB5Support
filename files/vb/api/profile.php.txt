<?php
/*========================================================================*\
|| ###################################################################### ||
|| # vBulletin 6.1.0 Alpha 4 Week 2 - Licence Number VBCW2VFT7A
|| # ------------------------------------------------------------------ # ||
|| # Copyright 2000-2024 MH Sub I, LLC dba vBulletin. All Rights Reserved.  # ||
|| # This file may not be redistributed in whole or significant part.   # ||
|| # ----------------- VBULLETIN IS NOT FREE SOFTWARE ----------------- # ||
|| # http://www.vbulletin.com | http://www.vbulletin.com/license.html   # ||
|| ###################################################################### ||
\*========================================================================*/

/**
 * vB_Api_Profile
 *
 * @package vBApi
 */
class vB_Api_Profile extends vB_Api
{
	/**
	 * return font information for profile customization
	 *
	 * @return		array with two elements- fontsizes and fontnames.
	 */
	public function getAllowedFonts()
	{
		$options = vB::getDatastore()->getValue('options');
		return array(
			'fontsizes' => $this->buildSelectOptions($options['usercss_allowed_font_sizes']),
			'fontnames' => $this->buildSelectOptions($options['usercss_allowed_fonts'])
		);
	}

	/**
	 * Builds the array for various admin-controlled select options (font sizes, etc).
	 * Determines the CSS value and internal phrase key if there is one.
	 *
	 * @param	string	Raw string. Line break and pipe delimited.
	 *
	 * @return	array	Array prepared for select building
	 */
	protected function buildSelectOptions($inputString)
	{
		$lines = preg_split("/(\n|\r\n|\r)/", $inputString, -1, PREG_SPLIT_NO_EMPTY);

		$output = array();
		foreach ($lines AS $line)
		{
			$parts = explode('|', $line);
			$key = trim($parts[0]);
			$value = isset($parts[1]) ? trim($parts[1]) : $key;
			$output["$key"] = $value;
		}

		return $output;
	}

	/**
	 * Get the default avatars- creates the profile UI tab
	 */
	public function getDefaultAvatars()
	{
		$assertor = vB::getDbAssertor();
		$avatars = $assertor->getRows('vBForum:avatar', array(vB_dB_Query::TYPE_KEY => vB_dB_Query::QUERY_SELECT,
		'imagecategoryid' => 3), 'displayorder');

		if (empty($avatars) OR !empty($avatars['errors']))
		{
			return array();
		}
		$userPosts = vB::getCurrentSession()->fetch_userinfo();
		$userPosts = $userPosts['posts'];

		foreach ($avatars as $key => $avatar)
		{
			if ($avatar['minimumposts'] > $userPosts)
			{
				unset ($avatars[$key]);
			}
		}
		return $avatars;
	}


	/**
	 * Upload an avatar from a URL and set it to be this user's custom avatar
	 *
	 * @param	string	The URL to retrieve the image from
	 * @param	array	An array containing the 'crop' element which contains the info to crop the image
	 *
	 * @return	mixed	an array- which can have $errors or avatarpath- the path from baseurl_core
	 */
	public function uploadUrl($url, $data = array())
	{
		if (!defined('ATTACH_AS_FILES_NEW'))
		{
			//Leave for consistency with admincp
			define('ATTACH_AS_FILES_NEW', 2);
		}

		$imageHandler = vB_Image::instance();

		$usercontext = vB::getUserContext();

		//Only logged-in-users can upload files
		if (
			!$usercontext->fetchUserId() OR
			!$usercontext->hasPermission('genericpermissions', 'canuseavatar') OR
			!$usercontext->hasPermission('genericpermissions', 'canmodifyprofile')
		)
		{
			throw new vB_Exception_Api('no_permission_use_avatar');
		}

		//Did we get a valid url?
		if (empty($url))
		{
			// throw the same exception to mitigate SSRF (VBV-13082)
			throw new vB_Exception_Api('upload_invalid_image');
		}

		if (!preg_match('#^https?://#i', $url))
		{
			// throw the same exception to mitigate SSRF (VBV-13082)
			throw new vB_Exception_Api('upload_invalid_image');
		}

		// Retrieve the image
		// We might want to set a max size here
		$vurl = vB::getUrlLoader();
		$vurl->setOption(vB_Utility_Url::FOLLOWLOCATION, 1);
		$vurl->setOption(vB_Utility_Url::HEADER, 1);
		$fileResult = $vurl->get($url);

		if (empty($fileResult['body']))
		{
			// throw the same exception to mitigate SSRF (VBV-13082)
			throw new vB_Exception_Api('upload_invalid_image');
		}

		$pathinfo = pathinfo($url);
		$data['crop']['org_file_info'] = $pathinfo;
		if (!empty($fileResult['body']) AND !empty($pathinfo))
		{
			$extension_map = $imageHandler->getExtensionMap();
			if (empty($pathinfo['extension']) OR !array_key_exists(strtolower($pathinfo['extension']), $extension_map))
			{
				// try to get an extension from the content type header
				if (!empty($fileResult['headers']['content-type']))
				{
					// should be something like image/jpeg
					$typeData = explode('/', $fileResult['headers']['content-type']);
					if ((count($typeData) == 2) AND array_key_exists(trim($typeData[1]), $extension_map))
					{
						$extension = strtolower($extension_map[trim($typeData[1])]);
					}
				}
			}
			else
			{
				$extension = $pathinfo['extension'];
			}

			//did we get an extension?
			if (empty($extension))
			{
				// throw the same exception to mitigate SSRF (VBV-13082)
				throw new vB_Exception_Api('upload_invalid_image');
			}

			//Make a local copy
			$filename = vB_Utilities::getTmpFileName('', 'vbprofile', ".$extension");
			file_put_contents($filename, $fileResult['body']);

			$this->checkProfileGifPerms($filename);
			// filescan done in vB_Library_User::uploadAvatar()

			return vB_Library::instance('user')->uploadAvatar($filename, empty($data['crop']) ? array() : $data['crop']);
		}
		// TODO: is there supposed to be an else...error here for when pathinfo's empty?
	}

	private function checkProfileGifPerms($filename)
	{
		$imageHandler = vB_Image::instance();
		$usercontext = vB::getUserContext();

		// We probably already checked these, but doesn't hurt to check again. Mostly here for hardening/future-proofing.
		// Only logged-in-users can upload files
		if (
			!$usercontext->fetchUserId()
				OR
			!$usercontext->hasPermission('genericpermissions', 'canuseavatar')
				OR
			!$usercontext->hasPermission('genericpermissions', 'canmodifyprofile')
		)
		{
			throw new vB_Exception_Api('no_permission_use_avatar');
		}


		$canAnimateAvatar = $usercontext->hasPermission('genericpermissions', 'cananimateavatar');
		if (!$canAnimateAvatar)
		{
			$isAnimatedGif = $imageHandler->fileIsAnimatedGif($filename);
			if ($isAnimatedGif)
			{
				throw new vB_Exception_Api('no_permission_animate_avatar');
			}
		}
	}


	/**
	 * Upload an avatar and set it as the user's profile image.
	 *
	 *	@param	array|object A file object, or a $_FILE array
	 *
	 *	@return	mixed	an array- which can have $errors or avatarpath- the path from baseurl_core
	 */
	public function upload($file, $data = [])
	{
		if (!defined('ATTACH_AS_FILES_NEW'))
		{
			//Leave for consistency with admincp
			define('ATTACH_AS_FILES_NEW', 2);
		}

		$usercontext = vB::getUserContext();
		if (
			!$usercontext->fetchUserId()
				OR
			!$usercontext->hasPermission('genericpermissions', 'canuseavatar')
				OR
			!$usercontext->hasPermission('genericpermissions', 'canmodifyprofile')
		)
		{
			throw new vB_Exception_Api('no_permission_use_avatar');
		}

		//We can get either an uploaded file or an object. If we have an object let's make it into an array.

		if (is_object($file) AND isset($file->name))
		{
			$pathinfo = pathinfo($file->name);
			$data['org_file_info'] = $pathinfo;
			if (isset($file->contents) AND !empty($file->contents))
			{
				$filename = vB_Utilities::getTmpFileName('', 'vbprofile', '.' . $pathinfo['extension']);
				file_put_contents($filename, $file->contents);
			}
		}
		else
		{
			if (!file_exists($file['tmp_name']))
			{
				// Encountered PHP upload error
				if (!($maxupload = @ini_get('upload_max_filesize')))
				{
					$maxupload = 10485760;
				}
				$maxattachsize = vb_number_format($maxupload, 1, true);

				switch($file['error'])
				{
					case '1': // UPLOAD_ERR_INI_SIZE
					case '2': // UPLOAD_ERR_FORM_SIZE
						throw new vB_Exception_Api('upload_file_exceeds_php_limit', $maxattachsize);
						break;
					case '3': // UPLOAD_ERR_PARTIAL
						throw new vB_Exception_Api('upload_file_partially_uploaded');
						break;
					case '4':
						throw new vB_Exception_Api('upload_file_failed');
						break;
					case '6':
						throw new vB_Exception_Api('missing_temporary_folder');
						break;
					case '7':
						throw new vB_Exception_Api('upload_writefile_failed');
						break;
					case '8':
						throw new vB_Exception_Api('upload_stopped_by_extension');
						break;
					default:
						throw new Exception('Upload failed. PHP upload error: ' . intval($file['error']));
				}
			}

			$data['org_file_info'] = pathinfo($file['name']);
			$filename = $file['tmp_name'];
		}

		$this->checkProfileGifPerms($filename);

		// filescan done in vB_Library_User::uploadAvatar()

		return vB_Library::instance('user')->uploadAvatar($filename, empty($data) ? [] : $data);
	}

	public function resetAvatar($type = 'avatar')
	{
		$usercontext = vB::getUserContext();
		if (!($userid = $usercontext->fetchUserId()) OR  !$usercontext->hasPermission('genericpermissions', 'canmodifyprofile'))
		{
			throw new vB_Exception_Api('no_permission_use_avatar');
		}

		$userpic = new vB_DataManager_Userpic_Avatar(vB_DataManager_Constants::ERRTYPE_ARRAY_UNPROCESSED);
		$userpic->condition = ['userid'  => $userid];
		$userpic->delete();

		//ignoring gif checks since this is for reseting to what's allowed as the default avatar.
		if ($userpic->has_errors(false))
		{
			throw $userpic->get_exception();
		}

		return vB_Api::instanceInternal('user')->fetchAvatar($userid, $type);
	}

	public function cropFileData($filedataid, $data = array())
	{
		$usercontext = vB::getUserContext();
		if (
			!$usercontext->fetchUserId()
				OR
			!$usercontext->hasPermission('genericpermissions', 'canuseavatar')
				OR
			!$usercontext->hasPermission('genericpermissions', 'canmodifyprofile')
		)
		{
			throw new vB_Exception_Api('no_permission_use_avatar');
		}

		//Did we get a valid url?
		if (empty($filedataid))
		{
			throw new vB_Exception_Api('upload_invalid_url');
		}

		//add @ to suppress warnings caused by invalid url
		$filedata = vB_Api::instanceInternal('filedata')->fetchImageByFiledataid($filedataid);
		if (empty($filedata))
		{
			throw new vB_Exception_Api('upload_invalid_url');
		}
		$imageHandler = vB_Image::instance();
		$extension_map = $imageHandler->getExtensionMap();
		if(!array_key_exists(strtolower($filedata['extension']), $extension_map))
		{
			throw new vB_Exception_Api('error_thumbnail_notcorrectimage');
		}

		//Make a local copy
		$filename = vB_Utilities::getTmpFileName('', 'vbprofile', ".$filedata[extension]");

		file_put_contents($filename, $filedata['filedata']);
		$crop = array();
		if (!empty($data) AND is_array($data) AND array_key_exists('crop', $data))
		{
			$crop = $data['crop'];
		}

		$this->checkProfileGifPerms($filename);

		return vB_Library::instance('user')->uploadAvatar($filename, $crop);
	}

	/**
	 * Lists the media for a user
	 *
	 * @param	array
	 * @param	int
	 * @param	int
	 * @param	mixed, optional- sort (ASC/DESC), time limit, type (photo/video/all)
	 *
	 * @return	mixed	array of media data- format is getContent
	 */
	public function fetchMedia($mediaFilter, $page = 1, $perpage = 12, $params = array())
	{
		$assertor = vB::getDbAssertor();

		$currentUser = vB::getCurrentSession()->get('userid');
		$albumChannel = vB_Library::instance('node')->fetchAlbumChannel();
		$userContext = vB::getUserContext();

		$fetchContent = true;
		if (isset($mediaFilter['userId']) AND intval($mediaFilter['userId']))
		{
			// we are filtering per user
			$hashKey = "vB_ProfMedia_{$mediaFilter['userId']}" . '_' . $currentUser;
			$events = [
				'nodeChg_' . $albumChannel,
				'fUserContentChg_' . $mediaFilter['userId'],
				'userPrivacyChg_' . $mediaFilter['userId'],
				'followChg_' . $mediaFilter['userId'],
				'rebuild_group_access',
			];

			// let's filter by privacy
			$userInfo = vB_Api::instanceInternal('user')->fetchProfileInfo($mediaFilter['userId']);
			if (!$userInfo['showPhotos'] AND !$userInfo['showVideos'])
			{
				$fetchContent = false;
			}
			else if (!$userInfo['showPhotos'])
			{
				$mediaFilter['type'] = 'video';
			}
			else if (!$userInfo['showVideos'])
			{
				$mediaFilter['type'] = 'gallery';
			}
		}
		else if(isset($mediaFilter['channelId']) AND intval($mediaFilter['channelId']))
		{
			// we are filtering per channel
			$hashKey = "vB_ChannelMedia_{$mediaFilter['channelId']}" . '_' . $currentUser;
			// TODO: check that this event is triggered when modifying the content of a subchannel
			$events = [
				'nodeChg_' . $mediaFilter['channelId'],
				'rebuild_group_access',
			];
		}
		else
		{
			throw new vB_Exception_Api('invalid_data');
		}

		$cache = vB_Cache::instance();
		$page = max(1, intval($page));
		$perpage = max(1, intval($perpage));
		$data = $cache->read($hashKey);

		if ($data === false AND $fetchContent)
		{
			$nodeQry = $assertor->assertQuery('vBForum:fetchProfileMedia', $mediaFilter);
			$data = [];
			$childnodes = [];

			if ($nodeQry->valid())
			{
				foreach($nodeQry AS $node)
				{
					$data[$node['nodeid']] = $node;
					$childnodes[$node['childnode']] = $node['nodeid'];
				}
			}

			if (!empty($childnodes))
			{
				//The childnodes point to either attachments or photos.  Let's try photos first.
				$childQry = $assertor->assertQuery('vBForum:photo', ['nodeid' => array_keys($childnodes)]);
				if ($childQry->valid())
				{
					foreach($childQry AS $child)
					{
						$parentNodeId = $childnodes[$child['nodeid']];
						$data[$parentNodeId]['filedataid'] = $child['filedataid'];
						$data[$parentNodeId]['photoid'] = $child['nodeid'];
						unset($childnodes[$child['nodeid']]);
					}
				}

				//And now attach records
				if (!empty($childnodes))
				{
					$childQry = $assertor->assertQuery('vBForum:attach', ['nodeid' => array_keys($childnodes)]);

					if ($childQry->valid())
					{
						foreach($childQry AS $child)
						{
							$parentNodeId = $childnodes[$child['nodeid']];
							$data[$parentNodeId]['filedataid'] = $child['filedataid'];
							$data[$parentNodeId]['attachid'] = $child['nodeid'];
						}
					}
				}
			}

			$cache->write($hashKey, $data, 30, $events);
		}
		else if (!$fetchContent)
		{
			$data = [];
			$cache->write($hashKey, $data, 30, $events);
		}

		$nodes = array_slice($data,($page - 1) * $perpage, $perpage);
		$count = count($data);
		$cancreateVideo = 0;
		$cancreatePhoto = 0;
		if ($userContext->isAdministrator() OR (!empty($mediaFilter['userId']) AND ($currentUser == $mediaFilter['userId'])))
		{
			if ($userContext->hasPermission('forumpermissions', 'canview', $albumChannel))
			{
				$createPerms = $userContext->getCanCreate($albumChannel);
				$cancreateVideo = $createPerms['vbforum_video'];
				$cancreatePhoto = $createPerms['vbforum_gallery'];
			}

		}
		else if (!empty($mediaFilter['channelId']))
		{
			// todo: should this be checking albumChannel or channelId?
			if ($userContext->hasPermission('forumpermissions', 'canview', $albumChannel))
			{
				$createPerms = $userContext->getCanCreate($mediaFilter['channelId']);
				$cancreateVideo = $createPerms['vbforum_video'];
				$cancreatePhoto = $createPerms['vbforum_gallery'];
			}

		}

		$return = [
			'nodes' => $nodes,
			'count' => $count,
			'paging' => $this->getMediaNav($page, $perpage, $count),
			'cancreateVideo' => $cancreateVideo,
			'cancreatePhoto' => $cancreatePhoto,
		];

		return $return;
	}

	/**
	 * Get languages for current user settings
	 * @param	int		Id of the default user language
	 *
	 * @return	mixed	Array of languages.
	 */
	public function getLanguages($userLanguageId = 0)
	{
		$userContext = vB::getUserContext();
		$languages = vB::getDatastore()->getValue('languagecache');
		$userLanguages = array();
		foreach($languages as $language)
		{
			if ($language['userselect'] OR $userContext->hasPermission('adminpermissions', 'cancontrolpanel'))
			{
				$userLanguages[$language['languageid']] = array('title' => $language['title'], 'userselect' => $language['userselect']);
				$userLanguages[$language['languageid']]['selected'] = ($userLanguageId == $language['languageid'] ? true : false);
			}
		}

		return $userLanguages;
	}

	/**
	 * Get styles for current user settings
	 *
	 * @return mixed	Array of styles
	 */
	public function getStyles()
	{
		$userContext = vB::getUserContext();
		$stylelib = vB_Library::instance('Style');
		$styles = $stylelib->fetchStyles(false, false);
		$userStyles = array();
		foreach ($styles as $style)
		{
			if ($style['userselect'] OR $userContext->hasPermission('adminpermissions', 'cancontrolpanel'))
			{
				$userStyles[] = $style;
			}
		}

		return $userStyles;
	}


	/**
	 * Lists the media navigationfor a user
	 *
	 *	@param	int
	 * 	@param	int
	 *	@param	int
	 * 	@param	mixed, optional- sort (ASC/DESC), time limit, type (photo/video/all), and currentPage
	 *
	 *	@return	mixed	array include previous, next, currentPage, totalcount and totalpages
	 */
	protected function getMediaNav($page, $perpage, $qty)
	{
		$paging = array();
		$pageCount = ceil($qty / $perpage);
		$paging['previous'] = ($page > 1) ? 1 : 0;
		$paging['next'] = ($page < $pageCount) ? 1 : 0;
		$paging['totalpages'] = $pageCount;
		$paging['currentpage'] = $page;
		$paging['totalcount'] = $qty;
		return $paging;
	}

	private function getAlbumCacheKey($params)
	{
		$userContext = vB::getUserContext();
		$currentUserid = $userContext->fetchUserId();

		ksort($params);
		$cachekey = 'vbProfMedia_' . $currentUserid . '_' . md5(serialize($params));

		return $cachekey;
	}

	private function getAlbumFromCache($cachekey)
	{
		$cached = vB_Cache::instance(vB_Cache::CACHE_LARGE)->read($cachekey);
		// Just a meta flag useful for debugging.
		if ($cached)
		{
			$cached['fromCache'] = true;
		}
		return $cached;
	}

	private function writeAlumToCache($cachekey, $album, $invalidateCacheEvents = [])
	{
		$cacheTTL = vB_Api_Search::getCacheTTL();
		if ($cacheTTL == 0)
		{
			return false;
		}

		// Event $lifetime_mins is minutes while getCacheTTL returns seconds.
		$cacheTTLMins = $cacheTTL / 60;
		vB_Cache::instance(vB_Cache::CACHE_LARGE)->write($cachekey, $album, $cacheTTLMins, $invalidateCacheEvents);
	}

	private function albumFiltersToParams($filters)
	{
		$nodeid = intval($filters['nodeid'] ?? 0);
		$page = max(intval($filters['page'] ?? 1), 1);
		$perpage = max(intval($filters['perpage'] ?? 60), 1);
		$userid = intval($filters['userid'] ?? 0);
		$channelid = intval($filters['channelid'] ?? 0 );
		$dateFilter = !empty($filters['dateFilter']) ? $filters['dateFilter'] : 'time_all';
		$showFilter = !empty($filters['showFilter']) ? $filters['showFilter'] : 'show_all';
		// Conversation display's photos tab
		$sort = $filters['sort'] ?? null;


		if ($perpage <= 0)
		{
			$perpage = 60;
		}

		if ($page <= 0)
		{
			$page = 1;
		}


		// All Videos
		if ($nodeid == -1)
		{
			$params = [
				'nodeid' => $nodeid,
				'userid' => $userid,
				'dateFilter' => $dateFilter,
				vB_dB_Query::PARAM_LIMIT => $perpage,
				vB_dB_Query::PARAM_LIMITPAGE => $page,
			];
		}
		// All Images (non-album gallery-photos or image-attachments)
		else if($nodeid == -2)
		{
			// todo:
			// append with content-type: image/*  mime type extensions from attachmenttype table
			// (reminder, only white-listed extensions go through forceRewrite() meant to destroy
			// potentially harmful data embedded in image uploads, so this might be a problem...)
			$extensions = vB_Api::instanceInternal('content_attach')->getImageExtensions();
			$extensions = $extensions['extensions'];

			$params = [
				'nodeid' => $nodeid,
				'userid' => $userid,
				'channelid' => $channelid,
				'dateFilter' => $dateFilter,
				'showFilter' => $showFilter,
				'extensions' => $extensions,
				vB_dB_Query::PARAM_LIMIT => $perpage,
				vB_dB_Query::PARAM_LIMITPAGE => $page,
				'sort' => $sort,
			];

			if (isset($filters['module_filter_nodes']))
			{
				$params['module_filter_nodes']  = $filters['module_filter_nodes'];
			}

			if (isset($filters['date_range']))
			{
				$params['date_range']  = $filters['date_range'];
			}

		}
		else if ($nodeid == 0)
		{
			// error
			throw new vB_Exception_Api('invalid_request');
		}
		// Specific album
		else
		{
			$params = [
				'nodeid' => $nodeid,
				vB_dB_Query::PARAM_LIMIT => $perpage,
				vB_dB_Query::PARAM_LIMITPAGE => $page,
			];
			$nodeid = intval($filters['nodeid'] ?? 0);
			$page = max(intval($filters['page'] ?? 1), 1);
			$perpage = max(intval($filters['perpage'] ?? 60), 1);
		}

		return $params;
	}

	private function getVideosAlbum($params)
	{
		$assertor = vB::getDbAssertor();
		// Note, with current usage, $nodeid = -1 always for this function, see getImagesAlbum() below.
		$nodeid = $params['nodeid'];
		$perpage = $params[vB_dB_Query::PARAM_LIMIT];
		$page = $params[vB_dB_Query::PARAM_LIMITPAGE];

		// Needs target userid
		if (!$params['userid'])
		{
			throw new vB_Exception_Api('invalid_request');
		}

		$videoQry = $assertor->assertQuery('vBForum:fetchVideoNodes', $params);

		if (!$videoQry->valid())
		{
			return [];
		}

		$videoNodes = [];
		foreach($videoQry AS $node)
		{
			$videoNodes[] = $node['nodeid'];
		}
		$videoCount = $assertor->getRow('vBForum:fetchVideoCount' , $params);
		$videoCount = $videoCount['count'];

		if ($videoCount)
		{
			$pagenav = $this->getMediaNav($page, $perpage, $videoCount);
		}
		else
		{
			$pagenav = $this->getMediaNav(1, $perpage, $videoCount);
		}

		$videoInfo[$nodeid] = [
			'nodeid' => $nodeid,
			'title' => '',
			'videos' => vB_Library::instance('node')->getFullContentforNodes($videoNodes),
			'pagenav' => $pagenav,
			'videocount' => $videoCount,
		];
		return $videoInfo;

	}

	private function getImagesAlbum($params)
	{
		$assertor = vB::getDbAssertor();
		// Note, with current usage, $nodeid = -2 always for this function, because
		// nodeid isn't actually a nodeid most of the time, instead it's a hint for which type of
		// completely different content the caller to getAlum() wants:
		// -1: all videos -- probably profile media
		// -2: all images -- media tab on channel display (if channelid is provided) or profile media (if userid is provided)
		// > 0: A specific "album" nodeid. Beware that album != gallery. I think album is specificially profile media albums,
		//    while galleries are any vBForum_Gallery contenttype topics.
		$nodeid = $params['nodeid'];
		$perpage = $params[vB_dB_Query::PARAM_LIMIT];
		$page = $params[vB_dB_Query::PARAM_LIMITPAGE];

		/*
			It's possible to have duplicate filedata used for multiple photos/attachments.
			Initially I had been grouping by filedataid, but since different photos/attaches
			with the same filedata might have different captions, I went back to having each
			node be its own counted "photo item".

			At the moment, attach.caption doesn't hold anything. Captions were added to attachments
			later, but captions are actually saved (along with other image settings) as part of the
			bbcode text in text.rawtext rather than on the attach table. As such it's nonfeasible to
			pull that out unless we refactor attachments to store captions separately in the attach
			table. For attachments, I'll use the filename as the title, unless node.title happens
			to hold something.
			*/

		// TODO CACHE THIS???


		// vBForum:fetchPostedPhotoCount removed, VBV-15227
		//$photoCount = $assertor->getRow('vBForum:fetchPostedPhotoCount' , $params);
		//$photoCount = $photoCount['count'];


		// "Max count" added back below, VBV-17950

		$photoQuery = $assertor->assertQuery('vBForum:fetchGalleryPhotos' , $params);
		if (!$photoQuery->valid())
		{
			return [];
		}

		$totalPhotoCount = $assertor->getRow('vBForum:fetchGalleryPhotosCount', $params);
		$totalPhotoCount = $totalPhotoCount['count'];

		/*
			profile_textphotodetail_block template currently requires the following:
				nodeid
				title
				htmltitle
				authorname
				publishdate

			vB5_Frontend_Controller_Profile::actiongetPhotoTabContent() & photo_item template (rendered downstream of
			actiongetPhotoTabContent()) currently require the following:
				filedataid
				title
				isAttach
				imgUrl - required by photo_item is built by profile controller's actiongetPhotoTabContent()


			getNodeAttachmentsPublicInfo() returns:
				- nodeid
				- parentid
				- filedataid
				- filename
				- filesize
				- settings
				- counter
				- dateline
				- resize_dateline
				- extension
				- userid
				- visible


			It seems like for photo contenttypes, the "caption" you add to each photo gets set as node.title.
			For photo attachments, you can save the caption but it's saved in the rawtext currently.
			I think I'll use the filename for now.
			*/

		$userContext = vB::getUserContext();
		$currentUserid = $userContext->fetchUserId();
		[
			'imgfullchannels' => $imgfullchannels,
			'imgthumbchannels' => $imgthumbchannels,
		] = $userContext->getAllChannelAccess();

		$cleaner = vB::getCleaner();
		$phrases = vB_Api::instanceInternal('phrase')->fetch(['posted_photos']);

		//we really need to synchornize this better with the regular gallery/albumn data returns
		//so callers can depend on what data they're actually getting back.  For now we'll hard
		//code the 'canedit' field to zero because we probably shouldn't attempt to edit this
		//artificition gallery.  But the field should be there.
		$photoInfo[$nodeid] = [
			'nodeid' => $nodeid,
			'title' => $phrases['posted_photos'],
			'photo' => [],
			'canedit' => 0,
		];

		$types = vB_Types::instance();

		foreach ($photoQuery AS $photo)
		{
			//$count++;
			if (empty($photo['title']) AND !empty($photo['filename']))
			{

				$photo['title'] = $photo['filename'];
			}
			if (empty($photo['htmltitle']) AND !empty($photo['filename']))
			{
				$photo['htmltitle'] = $cleaner->clean($photo['filename'], vB_Cleaner::TYPE_NOHTML);
			}
			unset($photo['filename']);

			// why oh why do we have 3 different returnable "photo-like" arrays in 3 different places...
			// photo full vs thumb display conditions.
			// Note seems to be purely presentation flavor and should be moved out of this function...
			// photos search module does not use this, so either media tabs or profile media albums
			// *may* use this...
			$isOwner = ($photo['gallery_userid'] == $currentUserid);
			$photo['showfull'] = ($isOwner OR isset($imgfullchannels[$photo['channelid']]));
			$photo['showthumb'] = ($photo['showfull'] OR isset($imgthumbchannels[$photo['channelid']]));

			$photo['contenttypeclass'] = $types->getContentTypeClass($photo['contenttypeid']);

			$photoInfo[$nodeid]['photo'][$photo['nodeid']] = $photo;
		}

		$photoInfo[$nodeid]['photocount'] = $totalPhotoCount;
		$pagenav = $this->getMediaNav($page, $perpage, $totalPhotoCount);
		$photoInfo[$nodeid]['pagenav'] = $pagenav;

		return $photoInfo;
	}

	/**
	 * Returns the album data for presentation on the media detail page for either a node, or one of the two pseudo-Albums
	 *
	 * @param int
	 * @param int $page
	 * @param int $perpage
	 * @param int $userid
	 * @param bool $dateFilter
	 *
	 * @return mixed array with key nodeid, node values and photo and/or attachment sub-arrays
	 */
	public function getAlbum($filters)
	{
		$params = $this->albumFiltersToParams($filters);
		$nodeid = $params['nodeid'];
		$perpage = $params[vB_dB_Query::PARAM_LIMIT];
		$page = $params[vB_dB_Query::PARAM_LIMITPAGE];

		$cachekey = $this->getAlbumCacheKey($params);
		$check = $this->getAlbumFromCache($cachekey);
		if ($check)
		{
			return $check;
		}

		$doCache = true;
		$album = [];
		// Different scenarios likely have different strategies for cache invalidation, because
		// this method does a lot of different things.
		// Note that with all of the different types, the search cache TTL always applies.
		// Will NOT be cached if search cache TTL is set to 0.
		$invalidateCacheEvents = [];
		// These base invalidate events are based on fetchMedia()
		$invalidateCacheEvents[] = 'rebuild_group_access';
		// userid & channelid may or may not be set. nodeid will always be set, but
		// its values may not actually be a true nodeid.
		if (!empty($params['userid']))
		{
			$invalidateCacheEvents[] = 'fUserContentChg_' . $params['userid'];
			$invalidateCacheEvents[] = 'userPrivacyChg_' . $params['userid'];
			$invalidateCacheEvents[] = 'followChg_' . $params['userid'];
		}

		if ($params['nodeid'] > 0)
		{
			$invalidateCacheEvents[] = 'nodeChg_' . $params['nodeid'];
		}

		if (!empty($params['channelid']))
		{
			$invalidateCacheEvents[] = 'nodeChg_' . $params['channelid'];
		}

		switch ($nodeid)
		{
			case 0:
				// Undefined / unused.
				throw new vB_Exception_Api('invalid_request');
				break;
			case -1:
				//All Videos
				$album = $this->getVideosAlbum($params);
				// This is for a specific user's media tab's video pseudo-album.
				// This will be covered by the fUserContentChg_ above.
				break;
			case -2:
				//All non-Album photos and attachments
				// Currently also used by channel display's media tab & photos-search module, simply
				// because these queries support searching by extensions unlike the current search API.
				$album = $this->getImagesAlbum($params);
				// This might be a specific user's pseudo album, or a specific channel's media tab, or a
				// photos search module.
				// For the first case, user's pseudo album, fUserContentChg_<userid> event above should
				// cover it.
				// For the second case, a channel's media tab, the nodeChg_<channelid> above should cover
				// it, although that likely causes a LOT of invalidations for little gain for a busy
				// channel -- e.g. a posts that do not contain any images will all invalidate this cache,
				// when ideally only posts with images should...
				// For photos modules, I'm not sure if anything *should* invalidate it, as we generally
				// don't do that for "search results" and only rely on the the searchCacheTTL time expiry...

				// module_filter_nodes used by photos search modules:
				// So this is a bit complex, because this param could include one or all or anywhere in between
				// number of channels. Increasing # of nodeids that can invalidate this also generally means
				// that the cache is not very good at caching since it'll be more likely to be invalidated.
				// Since this filter is currently only used by the search-photos module, let's just NOT
				// let node changes invalidate it, and lean on the search cache TTL.
				// IF we want to actually associate this cache with nodes, see
				// vB_Library_Widget::cleanFilterNodes() & vB_Library_Search::convertToParentChannels()
				// if (!empty($params['module_filter_nodes']))
				// {
				// 	//$invalidateCacheEvents[] = ...;
				// }

				break;
			default:
				// I believe that this case handles a specific album-nodeid.
				// For the album case, let's actually not bother writing to cache and instead
				// rely on the node api/library's own caching, so that its own cache invalidation
				// rules ETC get applied. I don't think we're going to gain a whole lot from
				// double caching here (if getNodeFullContent() does expensive calculations post-cache
				// it should do its own caching..) vs bloating the cache.
				$album = vB_Api::instanceInternal('node')->getNodeFullContent(
					$params['nodeid'],
					false,
					[
						'attach_options' => [
							'perpage' => $perpage,
							'page' => $page,
						]
					]
				);
				$doCache = false;

				// Leaving this in case we change our mind sabout caching this.
				// Since this is for a specific album, make the album changes kick the cache.
				// $invalidateCacheEvents = [
				// 	'nodeChg_' . $params['nodeid'],
				// ];
				break;
		}

		if ($doCache)
		{
			$this->writeAlumToCache($cachekey, $album, $invalidateCacheEvents);
		}

		return $album;
	}

	/**
	 * Meant to be a template helper method only. Do not rely on it for security.
	 * @see vB_Api_Gallery::getGalleryDisplayConditions() for more info. Used for
	 * switching display behavior in profile media templates.
	 *
	 * @param   array   $filters   @see getAlbum()
	 *
	 * @return   array  [bool 'showfull' => true if gallery allows fullsized images
	 *                   bool 'showthumb' => true if gallery allows thumbnail images
	 *                   bool 'showrestricted' => true if gallery has a mix of full
	 *                          and thumbnail images]
	 */
	public function getAlbumDisplayConditions($filters)
	{
		$nodeid    = intval($filters['nodeid'] ?? 0);
		$userid    = intval($filters['userid'] ?? 0);
		$channelid = intval($filters['channelid'] ?? 0);

		$albumChannel = vB_Library::instance('node')->fetchAlbumChannel();

		$return = [
			'showfull'       => false,
			'showthumb'      => false,
			'showrestricted' => false,
		];

		/*
		$nodeid
		0: unknown
		-1: all videos
		-2: all photos/attachments
		default: actual nodeid.
		 */
		switch ($nodeid)
		{
			case 0:
				return $return;
			case -1:
				// Not sure if there are any video-view-related permissions yet
				// This is probably not used for videos, but let's return permissive.
				return [
					'showfull'  => true,
					'showthumb' => true,
				];
			case -2:
				/*
				very similar to gallery display checks, but for the profile albums,
				But this is kind of a mess, because -2 is a pseudo-album that's supposed
				to return "all visible photos or image attachments posted by this user",
				so each photo or attachment has its own channel that may restrict its
				full/thumb view permissions.
				Let's just do our best to approximate (each individual image's thumb vs
				full loading is handled by a combination of
				vB_Library_Gallery::getPhotos() & the filedata::actionGallery controller,
				while attachments still need more work).
				 */
				$userContext = vB::getUserContext();
				$currentUserid = $userContext->fetchUserId();
				[
					'imgfullchannels' => $imgfullchannels,
					'imgthumbchannels' => $imgthumbchannels,
					// This does not work well because it ends up returning stuff like
					// infractions channel, which is technically restricted but not really
					// the right spirit.
					//'imgrestrictedchannels' => $imgrestrictedchannels,
				] = $userContext->getAllChannelAccess();
				$thumbonlychannels = array_diff($imgthumbchannels, $imgfullchannels);
				$isOwner = ($userid > 0 AND $userid == $currentUserid);
				/*
					Special override to explain why some images may show as thumbnails
					etc. Initially tried doing some heavy-handed channel checking (see
					imgrestrictedchannels above) but did not work well in practice,
					so we'll just fudge it and only consider the channels that they
					may see  ANY images on (so if they can't view images in ANY
					channel, we won't show any error messages, because we don't know
					which "restricted" channels are supposed to be for mass consumption
					vs special like infractions or PM channels).
				*/
				//$return['showrestricted'] = !empty($imgrestrictedchannels);
				$return['showfull'] = ($isOwner OR
					// only true if they ONLY have at least one channel that can show images AND
					// full images perms on all such channels.
					(!empty($imgfullchannels) AND empty($thumbonlychannels))
				);
				// show restricted warning iff they have a mix of full and thumb channels
				$return['showrestricted'] = (!$return['showfull'] AND
					!empty($imgfullchannels) AND
					!empty($thumbonlychannels)
				);
				// show thumb warning if they only have access to thumbonly.
				// $isOwner check is here because being the gallery owner gives you
				// access to full images currently.
				$return['showthumb'] = (!$isOwner AND !empty($thumbonlychannels));

				return $return;
			default:
				break;
		}

		// if we're here, $nodeid is an actual album nodeid, so let's go through the gallery API.
		$return = vB_Api::instanceInternal('content_gallery')->getGalleryDisplayConditions($nodeid);
		$return['showrestricted'] = false;

		return $return;
	}

	public function getSlideshow($filters)
	{
		$assertor = vB::getDbAssertor();

		$userid = intval($filters['userid'] ?? 0);
		$channelid = intval($filters['channelid'] ?? 0);
		$dateFilter = !empty($filters['dateFilter']) ? $filters['dateFilter'] : 'time_all';
		$searchlimit = (isset($filters['searchlimit']) AND !empty($filters['searchlimit'])) ? $filters['searchlimit'] : 60;
		$startIndex = (isset($filters['startIndex']) AND !empty($filters['startIndex'])) ? $filters['startIndex'] : 0;
		$pagelimit =  floor($startIndex /$searchlimit) + 1;

		/*
			Conversation display's photos tab. Some of these are shared with searchlimit/startIndex
			params. While the startIndex code does not make any sense to me, I don't want to break
			any existing behavior, so I'm just overriding them if these are present.
			Furthermore I don't know why we have nearly the same code in this function & getAlbum(),
			and what purpose this function serves (other than caching, which we could still do without
			the dupe code).

			TODO: collapse this & getAlbum()
		 */
		$pageno = max($filters['pageno'] ?? 0, 0);
		$perpage = max($filters['perpage'] ?? 0, 0);
		$sort = $filters['sort'] ?? null;
		if (!empty($perpage) AND !empty($pageno))
		{
			$pagelimit = $pageno;
			$searchlimit = $perpage;
		}
		$showFilter = !empty($filters['showFilter']) ? $filters['showFilter'] : 'show_all';

		$userContext = vB::getUserContext();
		$currentUserid = $userContext->fetchUserId();
		$commonFilterStr = '_' .implode('_', [
			$currentUserid,
			$pagelimit,
			$searchlimit,
			$dateFilter,
			$showFilter
		]);
		if (isset($filters['userid']) AND intval($filters['userid']))
		{
			// we are filtering per user
			$cacheKey = "vB_ProfDefaultAlbumSlideShow_{$filters['userid']}"
							. $commonFilterStr;
			$events = ['fUserContentChg_' . $filters['userid']];
		}
		else if(isset($filters['channelid']) AND intval($filters['channelid']))
		{
			// we are filtering per channel
			$cacheKey = "vB_ChannelDefaultAlbumSlideShow_{$filters['channelid']}"
							. $commonFilterStr;
			// TODO: check that this event is triggered when modifying the content of a subchannel
			$events = ['nodeChg_' . $filters['channelid']];
		}
		else
		{
			throw new vB_Exception_Api('invalid_data');
		}

		$extensions = vB_Api::instanceInternal('content_attach')->getImageExtensions();
		$extensions = $extensions['extensions'];

		$params = [
			'userid' => $userid,
			'channelid' => $channelid,
			'dateFilter' => $dateFilter,
			'showFilter' => $showFilter,
			'extensions' => $extensions,
			vB_dB_Query::PARAM_LIMIT => $searchlimit,
			vB_dB_Query::PARAM_LIMITPAGE => $pagelimit,
			'sort' => $sort,
		];
		$cache = vB_Cache::instance();
		$data = $cache->read($cacheKey);

		if ($data === false)
		{
			$photoQuery = $assertor->assertQuery('vBForum:fetchGalleryPhotos' , $params);
			if (!$photoQuery->valid())
			{
				return [];
			}
			[
				'imgfullchannels' => $imgfullchannels,
				'imgthumbchannels' => $imgthumbchannels,
			] = $userContext->getAllChannelAccess();
			$data = [];
			foreach ($photoQuery AS $photo)
			{
				// Since we key the cachekey with currentUserId, it should be safe to
				// add these user-specific properties pre-cache-write.
				$isOwner = ($photo['gallery_userid'] == $currentUserid);
				$photo['showfull'] = ($isOwner OR isset($imgfullchannels[$photo['channelid']]));
				$photo['showthumb'] = ($photo['showfull'] OR isset($imgthumbchannels[$photo['channelid']]));

				$data[$photo['nodeid']] = $photo;
			}
			// Clear cached slideshow if anything might change the vBForum:fetchGalleryPhotos
			// resultset & the photos' showfull/showthumb properties.
			$events[] = 'rebuild_group_access';
			$cache->write($cacheKey, $data, 30, $events);
		}

		return $data;

	}
}

/*=========================================================================*\
|| #######################################################################
|| # Downloaded: 12:50, Tue Dec 24th 2024
|| # CVS: $RCSfile$ - $Revision: 114635 $
|| #######################################################################
\*=========================================================================*/
