<?php
/*========================================================================*\
|| ###################################################################### ||
|| # vBulletin 6.1.0 Alpha 4 Week 2 - Licence Number VBCW2VFT7A
|| # ------------------------------------------------------------------ # ||
|| # Copyright 2000-2024 MH Sub I, LLC dba vBulletin. All Rights Reserved.  # ||
|| # This file may not be redistributed in whole or significant part.   # ||
|| # ----------------- VBULLETIN IS NOT FREE SOFTWARE ----------------- # ||
|| # http://www.vbulletin.com | http://www.vbulletin.com/license.html   # ||
|| ###################################################################### ||
\*========================================================================*/

/**
 * vB_Api_User
 *
 * @package vBApi
 */
class vB_Api_User extends vB_Api
{
	//for historical reasons USERINFO_AVATAR means both USERINFO_AVATAR_INFO and USERINFO_AVATAR_DATA
	//and should be considered deprecated.
	const USERINFO_AVATAR = 'avatar'; // Get avatar
	const USERINFO_AVATAR_INFO = 'avatarinfo'; // Get avatar info
	const USERINFO_AVATAR_DATA = 'avatardata'; // Get avatar filedata -- it's not clear that we need this anywhere
	const USERINFO_ADMIN = 'admin'; // Join the administrator table to get various admin options
	const USERINFO_SIGNPIC = 'signpic'; // Join the sigpic table to get the userid just to check if we have a picture
	const USERINFO_ISFRIEND = 'isfriend'; // Is the logged in User a friend of this person?

	protected $disableWhiteList = [
		'fetchCurrentUserinfo',
		'fetchProfileInfo',
		'fetchUserinfo',
		'fetchUserSettings',
		'hasPermissions',
		'login',
		'login2',
		'loginSpecificUser',
		'setCurrentUserPrivacyConsent',
		'updateGuestPrivacyConsent',
		'checkPrivacyOption',
	];
	protected $disableFalseReturnOnly = ['fetchAvatar'];

	protected $users = [];

	protected $groupInTopic = [];
	protected $moderatorsOf = [];
	protected $membersOf = [];
	protected $permissionContext = [];
	protected $referrals = [];

	/** @var vB_Library_User */
	protected $library;


	/**
	 * Current locale to revert back to after setLocale() was called.
	 * @var String locale
	 */
	protected $currentlocale = '';

	/**
	 * Instance of vB_Utility_Date() used for date/time output format conversions
	 * @var vB_Utility_Date instance
	 */
	protected $dateUtil;

	/**
	 * Constructor
	 */
	protected function __construct()
	{
		parent::__construct();
		$this->library = vB_Library::instance('user');
		$this->dateUtil = new vB_Utility_Date();
	}

	/**
	 * This gets the information needed for a user's profile. Only public information unless this is an admin or the user.
	 *
	 * @param int $userid -- uses the current logged in user if not given.  Error if the user is a guest.
	 * @return array -- the profile information.
	 */
	public function fetchProfileInfo($userid = false)
	{
		$options = vB::getDatastore()->getValue('options');
		$currentUserId = vB::getCurrentSession()->get('userid');

		if (empty($userid))
		{
			$userid = $currentUserId;
		}
		else
		{
			$userid = intval($userid);
		}

		if (($userid < 1))
		{
			throw new vB_Exception_Api('invalid_data_w_x_y_z', [$userid, 'userid', __CLASS__, __FUNCTION__]);
		}

		$userContext = vB::getUserContext();
		$requestedUserContext = vB::getUserContext($userid);

		$hashKey = 'vBProfileUser_' . $userid;

		$fastCache = vB_Cache::instance(vB_Cache::CACHE_FAST);
		$userInfo = $fastCache->read($hashKey);

		if (empty($userInfo))
		{
			$userInfo = vB_User::fetchUserinfo($userid,
				[
					vB_Api_User::USERINFO_AVATAR_INFO,
					vB_Api_User::USERINFO_SIGNPIC,
				]
			);

			//strip the private fields here before we cache.
			$userInfo = $this->stripPrivateUserFields($userInfo);


			//
			// Fields for the user's profile pages
			//

			// Show hidden fields only if the user views his own profile or if it has the permission to see them
			$showHidden = (($currentUserId == $userid) OR $userContext->hasPermission('genericpermissions', 'canseehiddencustomfields'));
			$customFields = $this->library->getCustomFields($userid, $showHidden);

			$userInfo['customFields'] = $customFields;

			//
			// Check whether user has permission to use friends list (follow users)
			//
			$userInfo['canusefriends'] = $requestedUserContext->hasPermission('genericpermissions2', 'canusefriends');
			$userInfo['canviewmembers'] = $requestedUserContext->hasPermission('genericpermissions', 'canviewmembers');

			$assertor = vB::getDbAssertor();


			// User counts

			//The library doesn't do any permission checks so be careful what we pass on.
			//Counts are okay, but the details are not.  For performance we might want to generate just the counts
			$followLib = vB_Library::instance('follow');
			if ($currentUserId == $userid OR $userInfo['canusefriends'])
			{
				$follows = $followLib->getFollowing($userid);
				$userInfo['followsCount'] = $follows['paginationInfo']['totalcount'];
			}
			$followers = $followLib->getFollowers($userid);
			$userInfo['followersCount'] = $followers['paginationInfo']['totalcount'];

			if (isset($this->referrals[$userid]))
			{
				$referrals = $this->referrals[$userid];
			}
			else
			{
				$referrals = $assertor->getRow('vBForum:getReferralsCount', ['userid' => $userid]);
				$this->referrals[$userid] = $referrals;
			}

			$userInfo['birthdayTimestamp'] = 0;
			$userInfo['referralsCount'] = $referrals['referrals'];

			if ($userInfo['birthday_search'])
			{
				[$year, $month, $day] = explode("-", $userInfo['birthday_search']);
				$userInfo['birthdayTimestamp'] = mktime(0, 0, 0, $month, $day, $year);
				$userInfo['age'] = (date("md") < $month . $day ? date("Y") - $year - 1 : date("Y") - $year);
			}

			//this is only used on the profile "about" tab and not many of the other places we use the
			//profile info function.  However seperating it out plays merry havoc with the caching and
			//unlike the code it replaces it probably
			$vmInfo = $assertor->getRow('vBForum:fetchUserVmInfo', ['setfor' => $userid]);
			$userInfo['vmCount'] = $vmInfo['count'];
			$userInfo['vmMostRecent'] = $vmInfo['mostrecent'] ?? 0;

			/**
			 * Let's get posts per day
			 */
			$timeIn = (vB::getRequest()->getTimeNow() - $userInfo['joindate']) / (24 * 60 * 60);
			if (($timeIn >= 1) AND ($userInfo['posts'] > 0))
			{
				$userInfo['postPerDay'] = vb_number_format(($userInfo['posts'] / $timeIn), 2);
			}
			else
			{
				$userInfo['postPerDay'] = $userInfo['posts'];
			}

			$fastCache->write($hashKey, $userInfo, 1440, 'userChg_' . $userid);
		}

		//strip the user fields after we cache.  Otherwise infromation is determined by the
		//permissions of whoever triggered the cache write and not the current user.
		//this isn't a huge problem since the fast cache current only really works with local memory
		//but if we ever fix using memcache for that ...
		//Note that this will rerun stripPrivateUserFields called above, but that's harmless
		//and trying to replicate the rest of the behavior of this function was causing needless
		//duplication of logic.
		$this->sanitizeUserInfo($userInfo, $currentUserId);

		if (($userInfo['userid'] != $currentUserId) AND !$this->hasAdminPermission('canadminusers'))
		{
			$userInfo = $this->blankUserOnlyFields($userInfo);
		}

		// add current user flags
		// if user is the profile owner..
		$userInfo['showAvatar'] = 1;
		if ($currentUserId == $userid)
		{
			if ($userContext->hasPermission('genericpermissions', 'canuseavatar'))
			{
				$userInfo['canuseavatar'] = 1;
				$userInfo['avatarmaxwidth'] = $userContext->getLimit('avatarmaxwidth');
				$userInfo['avatarmaxheight'] = $userContext->getLimit('avatarmaxheight');
				$userInfo['avatarmaxsize'] = ($userContext->getLimit('avatarmaxsize') / 1024);
			}
			else
			{
				$userInfo['canuseavatar'] = 0;
			}

			//Are there any default avatars this user could assign?
			//Default avatars don't currently function and if we restore them we'll need to update the frontend to
			//handle them.  The vestigates of logic have been removed from the front end UI.  It's also not clear
			//that we want to set this to true when canuseavatar is true -- they're really seperate things.
			$avatars = vB_Api::instanceInternal('profile')->getDefaultAvatars();
			$userInfo['defaultAvatarCount'] = count($avatars);
			if (($userInfo['defaultAvatarCount']) OR ($userInfo['canuseavatar'] > 0))
			{
				$userInfo['showAvatarOptions'] = 1;
			}
			else
			{
				$userInfo['showAvatarOptions'] = 0;
			}
		}
		else
		{
			$userInfo['canuseavatar'] = $userInfo['showAvatarOptions'] = 0;

			//Check the privacy settings and see if this user has hidden his
			if ($userInfo['privacy_options'] AND $requestedUserContext->hasPermission('usercsspermissions', 'caneditprivacy'))
			{
				switch ($userInfo['privacy_options']['profile_picture'])
				{
					case 1:
						//visible only if the current user is a subscriber.
						if (($currentUserId == 0) OR (vB_Api::instanceInternal('follow')->isFollowingUser($userid) != vB_Api_Follow::FOLLOWING_YES))
						{
							$userInfo['showAvatar'] = 0;
						}
						break;
					case 2:
						//visible only if the current user is a registered user.
						if ($currentUserId == 0)
						{
							$userInfo['showAvatar'] = 0;
						}
						break;
				} // switch
			}
		}

		//add the privacy flags in context.
		$flags = $this->library->getCurrentUserPrivacyFlags($userInfo);
		foreach ($flags AS $key => $value)
		{
			$userInfo[$key] = $value;
		}

		// Add online status
		$this->library->fetchOnlineStatus($userInfo);
		return $userInfo;
	}

	/**
	 * Fetches the needed info for user settings
	 */
	public function fetchUserSettings($userid = false)
	{
		$currentUserId = vB::getCurrentSession()->get('userid');
		if (empty($userid))
		{
			$userid = $currentUserId;
		}
		else
		{
			$userid = intval($userid);
		}

		if (($userid < 1))
		{
			throw new vB_Exception_Api('invalid_data_w_x_y_z', [$userid, 'userid', __CLASS__, __FUNCTION__]);
		}

		$userInfo = vB_User::fetchUserinfo($userid,
			[
				vB_Api_User::USERINFO_AVATAR,
				vB_Api_User::USERINFO_SIGNPIC,
			]
		);

		$userInfo = $this->sanitizeUserInfo($userInfo, $currentUserId);

		/**
		 * * Fields for the user's profile pages
		 */
		$fields = $this->library->getRawCustomFields($userid);

		// CustomFields for user settings
		$settingsCustomFields = [];
		// Types of userfields that have data array
		$fieldsWithData = ['radio', 'checkbox', 'select', 'select_multiple'];

		// Web is not a customField we are grabbing this from user.homepage record -- however it acts like a custom field
		$settingsCustomFields[0]['fields']['-1'] = [
			'text' => 'usersetting_web',
			'field' => 'homepage',
			'value' => $userInfo['homepage'],
			'type' => 'text',
			'editable' => true,
			'required' => false,
		];

		$assertor = vB::getDbAssertor();
		$fieldsInfo = $assertor->getRows('vBForum:fetchCustomProfileFields', ['hidden' => [0,1]]);
		foreach ($fieldsInfo as $customField)
		{
			// Setting the category in which the profile field belongs to
			if (!isset($settingsCustomFields[$customField['profilefieldcategoryid']]))
			{
				$catNameString = ($customField['profilefieldcategoryid']) ? (string) new vB_Phrase('cprofilefield', 'category' . $customField['profilefieldcategoryid'] . '_title') : '';
				$catDescString = ($customField['profilefieldcategoryid']) ? (string) new vB_Phrase('cprofilefield', 'category' . $customField['profilefieldcategoryid'] . '_desc') : '';
				$settingsCustomFields[$customField['profilefieldcategoryid']] = [
					'name' => $catNameString,
					'desc'  => $catDescString,
					'fields' => [],
				];
			}

			$value = $fields['field'.$customField['profilefieldid']];
			// Adding general field information
			$settingsCustomFields[$customField['profilefieldcategoryid']]['fields'][$customField['profilefieldid']] = [
				'text' => 'field' . $customField['profilefieldid'],
				'field' => 'field' . $customField['profilefieldid'],
				'value' => $value,
				'type' => $customField['type'],
				'hidden' => $customField['hidden'],
				'id' => $customField['profilefieldid'],
				'def' => $customField['def'],
				'maxlength' => $customField['maxlength'],
				//allow editing when otherwise we wouldn't for blank "registration only" fields
				'editable' => ($customField['editable'] == 1 OR ($customField['editable'] == 2 AND empty($value))),
				'required' => (bool) $customField['required'],
			];

			// For specific field types (defined in $fieldsWithData) adding the data array and setting if that option is selected
			if (in_array($customField['type'], $fieldsWithData))
			{
				$multi = ($customField['type'] == 'select_multiple' OR $customField['type'] == 'checkbox');

				$selectedtype = '';
				if ($multi)
				{
					$selectedtype = ($customField['type'] == 'select_multiple' ?  'selected="selected"' : 'checked="checked"');
					$selectedbits = intval($fields['field' . $customField['profilefieldid']]);
				}

				$tmpData = unserialize($customField['data']);
				foreach ($tmpData as $key => $value)
				{
					$selected = '';
					if ($multi AND ($selectedbits & pow(2, $key)))
					{
						$selected = $selectedtype;
					}

					$settingsCustomFields[$customField['profilefieldcategoryid']]['fields'][$customField['profilefieldid']]['data'][$key+1] = [
						'value' => $value,
						'selected' => $selected,
					];
				}
			}
		}

		$userInfo['settings_customFields'] = $settingsCustomFields;

		/**
		 * Let's get day month and year from birthday
		 *
		 */
		if ($userInfo['birthday_search'] != '0000-00-00')
		{
			$elements = explode('-', $userInfo['birthday_search']);
		}
		else
		{
			$elements = ['', '', ''];
		}

		[$userInfo['bd_year'], $userInfo['bd_month'], $userInfo['bd_day']] = $elements;

		/**
		 * @TODO remove when templates support perm checks
		 */
		$userInfo['canusecustomtitle'] = vB::getUserContext()->hasPermission('genericpermissions', 'canusecustomtitle');

		/**
		 * @TODO timezone options
		 */
		$userInfo['timezones'] = $this->library->fetchTimezonesArray();

		$profileApi = vB_Api::instanceInternal('profile');
		/**
		 * style options
		 */
		$styles = $profileApi->getStyles();
		$userInfo['styles']['count'] = count($styles);

		if (count($styles) > 1)
		{
			foreach ($styles as $style)
			{
				if ($style['depth'] > 1)
				{
					$identation = '';
					for ($x = 1; $x < $style['depth']; $x++)
					{
						$identation .= '--';
					}
					$style['title'] = $identation . $style['title'];
				}

				$userInfo['styles']['options'][] = $style;
			}
		}

		/**
		 * fetch language options
		 */
		$languages = $profileApi->getLanguages($userInfo['languageid']);
		$userInfo['languages']['count'] = count($languages);
		$userInfo['languages']['options'] = $languages;

		$userOptions = vB::getDatastore()->getValue('bf_misc_useroptions');
		foreach ($userOptions as $option => $value)
		{
			$userInfo["$option"] = ($userInfo['options'] & $value) ? true : false;
		}

		/**
		 * User max posts
		 */
		foreach ([-1, 5, 10, 20, 30, 40] AS $maxPostOption)
		{
			if ($maxPostOption == $userInfo['maxposts'])
			{
				$userInfo['maxposts_options'][$maxPostOption]['selected'] = true;
			}
			else
			{
				$userInfo['maxposts_options'][$maxPostOption]['selected'] = false;
			}
		}

		/**
		 * DST options
		 */
		$selectdst = 0;
		if ($userInfo['dstauto'])
		{
			$selectdst = 2;
		}
		else if ($userInfo['dstonoff'])
		{
			$selectdst = 1;
		}

		$userInfo['dst_options'] = [
			2 => ['phrase' => 'automatically_detect_dst_settings', 'selected' => ($selectdst == 2)],
			1 => ['phrase' => 'dst_corrections_always_on', 'selected' => ($selectdst == 1)],
			0 => ['phrase' => 'dst_corrections_always_off', 'selected' => ($selectdst == 0)]
		];

		/**
		 * SoW options
		 */
		foreach ($this->library->getDayOfWeekPhrases() AS $idx => $day)
		{
			$userInfo['sow_options'][$idx] = ['day' => $day, 'selected' => ($userInfo['startofweek'] == $idx)];
		}
		$options = vB::getDatastore()->getValue('options');
		//user maxresults for the autocomplete display for the moment
		$userInfo['minuserlength'] = ($options['minuserlength']) ? $options['minuserlength'] : 1;
		$userInfo['maxresults'] = ($options['maxresults']) ? $options['maxresults'] : 20;

		//if facebook connect is enabled
		$userInfo['facebookactive'] = (bool)$options['facebookactive'];

		//user signature
		$userInfo['allow_signatures'] = ((bool)$options['allow_signatures']) & vB::getUserContext()->hasPermission('genericpermissions', 'canusesignature');
		//user ignorelist
		$usernames = $this->library->fetchUserNames(explode(' ', $userInfo['ignorelist']));
		$userInfo['ignorelist'] = implode(',', $usernames);

		//profile options
		 $userInfo['profile_options']['options'] = [];
		foreach (['everyone', 'followers', 'members'] AS $phrase)
		{
			$userInfo['profile_options']['options'][] = $phrase;
		}

		//notifications settings
		$notificationOptions = vB::getDatastore()->getValue('bf_misc_usernotificationoptions');
		$optVals = [];
		foreach ($notificationOptions AS $key => $option)
		{
			$optVals[$key] = ($option & $userInfo['notification_options']) ? 'true' : 'false';
		}
		$userInfo['notification_options'] = ['options' => $userInfo['notification_options'], 'values' => $optVals];

		//email notification setting
		$emailOptions = [
			'0' => ['phrase' => 'usersetting_emailnotification_none'],
			'1' => ['phrase' => 'usersetting_emailnotification_on'],
			'2' => ['phrase' => 'usersetting_emailnotification_daily'],
			'3' => ['phrase' => 'usersetting_emailnotification_weekly'],
		];
		foreach ($emailOptions AS $key => $emailOption)
		{
			if ($userInfo['emailnotification'] == $key)
			{
				$emailOptions[$key]['selected'] = 1;
			}
		}
		$userInfo['email_notifications'] = $emailOptions;

		// moderator notifications settings
		$moderatorNotificationOptions = vB::getDatastore()->getValue('bf_misc_moderatornotificationoptions');
		$modOptVals = [];
		foreach ($moderatorNotificationOptions AS $key => $option)
		{
			$modOptVals[$key] = (bool) ($option & $userInfo['moderatornotificationoptions']);
		}
		$userInfo['moderatornotificationoptions'] = [
			'options' => $userInfo['moderatornotificationoptions'],
			'values' => $modOptVals,
		];

		// moderator email notifications settings
		$moderatorEmailNotificationOptions = vB::getDatastore()->getValue('bf_misc_moderatoremailnotificationoptions');
		$modEmailOptVals = [];
		foreach ($moderatorEmailNotificationOptions AS $key => $option)
		{
			$modEmailOptVals[$key] = (bool) ($option & $userInfo['moderatoremailnotificationoptions']);
		}
		$userInfo['moderatoremailnotificationoptions'] = [
			'options' => $userInfo['moderatoremailnotificationoptions'],
			'values' => $modEmailOptVals,
		];

		// Permission for invisible mode
		$userInfo['caninvisible'] = vB::getUserContext()->hasPermission('genericpermissions', 'caninvisible');

		/**
		 * advanced editor interface
		 */
		$editorOptions = [
			'0' => ['phrase' => 'basic_editor_simple_text_box'],
			'1' => ['phrase' => 'standard_editor_extra_formatting'],
			'2' => ['phrase' => 'enhanced_interface_wysiwyg']
		];
		foreach ($editorOptions AS $key => $val)
		{
			if ($key == $userInfo['showvbcode'])
			{
				$editorOptions[$key]['selected'] = true;
			}
		}

		/**
		 *	MFA Information
		 */

		//we want to be a little cagey about MFA status for security reasons.  Only disclose the
		//information if the user if this is user in question requesting it or an appropriate admin
		$userInfo['showMFATab'] = false;
		if ($userid == $currentUserId OR $this->hasAdminPermission('canadminusers'))
		{
			$thisUserContext = vB::getUserContext($userid);
			$isAdmin = $thisUserContext->isAdministrator();
			$isMod = $thisUserContext->isModerator();
			$config = vB::getConfig();
			if (!empty($config['Security']['mfa_enabled']))
			{
				//for now we only use MFA for cpsessions so if this isn't a moderator
				//MFA is irrelevant.
			 	if ($isAdmin OR $isMod)
				{
					//this is true if
					//a) The requester is somebody allowed to know it
					//b) MFA is enabled
					//c) The user queried is an admin or a mod
					$userInfo['showMFATab'] = true;
				}
			}
			// let's also stick in the isAdmin / isMod data here.
			// ATM this is used in the usersettings_privacy template to display a warning for
			// privacy consent withdrawal for admins.
			$userInfo['is_admin'] = $isAdmin;
			//$userInfo['is_mod'] = $isMod; // not used yet.
		}

		$userInfo['editor_options'] = $editorOptions;
		return $userInfo;
	}

	/**
	* Fetches an array containing info for the specified user, or false if user is not found
	*
	* Values for Option parameter:
	* avatar - Acts as both avatarinfo and avatardata and should be considered deprecated.
	* avatarinfo - Get avatar information
	* avatardata - Get the binary filedata / local file path for the avatar.
	* admin - Join the administrator table to get various admin options
	* signpic - Join the sigpic table to get the userid just to check if we have a picture
	* isfriend - Is the logged in User a friend of this person?
	* Therefore: ['avatar', 'location'] means 'Get avatar' and 'Process online location'
	*
	 * @param integer $ User ID
	 * @param array $ Fetch Option (see description)
	 * @param integer $ Language ID. If set to 0, it will use user-set languageid (if exists) or default languageid
	 * @param boolean $ If true, the method won't use user cache but fetch information from DB.
	* @return array The information for the requested user
	*/
	public function fetchUserinfo($userid = false, $option = [], $languageid = false, $nocache = false)
	{
		$currentUserId = vB::getCurrentSession()->get('userid');
		$userid = intval($userid);

		if ($userid <= 0 AND $currentUserId)
		{
			$userid = $currentUserId;
		}

		if ($languageid === false)
		{
			$languageid = vB::getCurrentSession()->get('languageid');
		}

		//If we just want avatar info, we can proceed.
		if (($userid != $currentUserId) AND ($option != [vB_Api_User::USERINFO_AVATAR]))
		{
			if (!$this->hasAdminPermission('canadminusers'))
			{
				return $this->fetchProfileInfo($userid);
			}
		}

		$userInfo = $this->library->fetchUserinfo($userid, $option, $languageid, $nocache);

		if ($userInfo)
		{
			$userInfo = $this->sanitizeUserInfo($userInfo, $currentUserId);
		}

		return $userInfo;
	}

	/**
	 * Fetches an array containing info for the current user
	 *
	 * @return array The information for the requested user. Userinfo record plus language information
	 */
	public function fetchCurrentUserinfo()
	{
		$session = vB::getCurrentSession();

		//if this is called if there's an error during initialization, and we have nothing yet
		if (empty($session))
		{
			return [];
		}

		$userInfo = $session->fetch_userinfo();

		// Templates can use this flag to display/skip pmchat specific stuff.
		$check = vB_Api::instanceInternal('pmchat')->canUsePMChat();
		$userInfo['canUsePMChat'] = (bool) $check['canuse'];

		//this is needed by the vBulletin mobile app.  It's no longer a useful thing
		//so hard code it to unknown.
		$userInfo['eustatus'] = 0;
		return $this->sanitizeUserInfo($userInfo, $session->get('userid'));
	}

	/**
	 * Fetches the username for a userid, or false if user is not found
	 *
	 * @param integer $ User ID
	 * @return string
	 */
	public function fetchUserName($userid)
	{
		if (!intval($userid))
		{
			return false;
		}

		return $this->library->fetchUserName($userid);
	}

	/**
	 * fetches the proper username markup and title
	 *
	 * @param array $user User info array
	 * @param string $displaygroupfield Name of the field representing displaygroupid in the User info array
	 * @param string $usernamefield Name of the field representing username in the User info array
	 * @return string Username with markup and title
	 */
	public function fetchMusername($user, $displaygroupfield = 'displaygroupid', $usernamefield = 'displayname')
	{
		vB_User::fetchMusername($user, $displaygroupfield, $usernamefield);
		return $user['musername'];
	}

	/**
	 * Returns true if enabledisplayname is on or if enabledisplayname is off but username & displayname
	 * are not equivalent. Used for templates that cannot run certain functions required perform this check.
	 *
	 * @param array $user User info array, e.g. from fetchUserinfo()
	 * @return ['check' => bool should show both displayname and username]
	 */
	public function doShowDisplaynameAndUsername($user)
	{
		return [
			'check' => vB_User::doShowDisplaynameAndUsername($user),
		];
	}

	/**
	 * Fetch user by its username
	 *
	 * @param string $username Username
	 * @param array $option Fetch Option (see description of fetchUserinfo())
	 * @return array The information for the requested user
	 */
	public function fetchByUsername($username, $option = [])
	{
		$userid = vB::getDbAssertor()->getField('user', [
			'username' => $username,
			vB_dB_Query::COLUMNS_KEY => ['userid'],
		]);

		if (!$userid)
		{
			return false;
		}
		else
		{
			//if this was added we might need a cache refresh.
			$result = $this->fetchUserinfo($userid, $option);

			//not entirely sure what this is for.  It's problematic in a lot of ways.  The correct
			//solution is to clear the cache for whatever is causing an incorrect result to appear
			//from the first call.  Due to the wierd fetchProfileInfo hack in fetchUserinfo we can't
			//just call that with the cache clear either.  It's not clear that due to that hack
			//that the function will return precisely the same information if we hit this case.
			//However cleaning all this up is beyond the scope of the current effort.
			if (empty($result))
			{
				//we know the information is there. We got a userid force so we need to force a refresh.
				$currentUserId = vB::getCurrentSession()->get('userid');
				$result = vB_User::fetchUserinfo($userid, $option, vB::getCurrentSession()->get('languageid'), true);
				$result = $this->sanitizeUserInfo($result, $currentUserId);
			}
			return $result;
		}
	}

	/**
	 * Fetch user by its email
	 *
	 * @param string $email Email
	 * @param array $option Fetch Option (see description of fetchUserinfo())
	 * @return array The information for the requested user
	 */
	public function fetchByEmail($email, $option = [])
	{
		$userid = vB::getDbAssertor()->getField('user', [
			'email' => $email,
			vB_dB_Query::COLUMNS_KEY => ['userid'],
		]);

		if (!$userid)
		{
			return false;
		}
		else
		{
			return $this->fetchUserinfo($userid, $option);
		}
	}

	/**
	 * Fetch a list of user based on the provided criteria
	 *
	 * Will only return a user if their primary user group has the
	 * viewable on the memberslist option set.
	 *
	 * @param array $criteria
	 * 	values for criteria:
	 * 	int $pagenumber the page to start from
	 * 	int $perpage number of members to display on a page
	 * 	string $sortfield the foeld to sort by
	 * 	string $sortorder the sort order (asc/desc)
	 * 	string $startswith the first letter(s) the username should match
	 *
	 * @return array
	 * 		members - the list of members that match the criteria
	 * 		pagingInfo - pagination information
	 */
	public function memberList($criteria = [])
	{
		if (!vB::getUserContext()->hasPermission('genericpermissions', 'canviewmembers'))
		{
			throw new vB_Exception_Api('no_permission');
		}

		$default = [
			'pagenumber' => 1,
			'perpage' => 25,
			'sortfield' => 'username',
			'sortorder' => 'ASC',
		];

		if (!is_array($criteria))
		{
			$criteria = $default;
		}

		$criteria = $criteria + $default;
		$pagingInfo = [
			'currentpage' => $criteria['pagenumber'],
			'perpage' => $criteria['perpage'],
		];

		$data = [
			vB_dB_Query::PARAM_LIMITPAGE => $criteria['pagenumber'],
			vB_dB_Query::PARAM_LIMIT => $criteria['perpage'],
			'sortfield' => $criteria['sortfield'],
			'sortorder' => $criteria['sortorder'],
		];

		if (!empty($criteria['startswith']))
		{
			$data['startswith'] = $criteria['startswith'];
			// We only have a-z or "#" for non-alphabet 'startswith', so we don't care about the html-escaped ness of usernames vs displaynames
			// for this condition that's used by the buttons, not the search box.
		}
		if (!empty($criteria['username']))
		{
			$data['username'] = vB_String::htmlSpecialCharsUni($criteria['username']);
			$data['displayname'] = $criteria['username'];
		}

		$usergroupids = vB_Library::instance('usergroup')->getMemberlistGroups();
		$data['usergroupid'] = $usergroupids;

		$db = vB::getDbAssertor();

		$members = [];
		$members_list = $db->assertQuery('fetchMemberList', $data);
		foreach ($members_list AS $member)
		{
			vB_User::expandOptions($member);
			$members[$member['userid']] = $member;
		}

		$pagingInfo['records'] = $db->getField('fetchMemberListCount', $data);
		$pagingInfo['totalpages'] = ceil($pagingInfo['records'] / $pagingInfo['perpage']);

		$avatars = $this->fetchAvatars(array_keys($members), false);
		foreach ($avatars AS $userid => $avatar)
		{
			$members[$userid]['avatar'] = $avatar;
		}

		return ['members' => $members, 'pagingInfo' => $pagingInfo];
	}

	/**
	 * Find user
	 *
	 * @param array $user An array of common conditions for user search
	 * @param array $profile An array of user profile field conditions for user search
	 * @param string $orderby Order by
	 * @param string $direction Order direction
	 * @param integer $limitstart Limit start
	 * @param integer $limitnumber Limit number
	 * @return bool |array False if no user found. Otherwise it returns users array as result.
	 *		 The array also contains a field that stores total found user count.
	 */
	public function find($user, $profile, $orderby, $direction, $limitstart = 0, $limitnumber = 25)
	{
		$this->checkHasAdminPermission('canadminusers');
		require_once(DIR . '/includes/class_core.php');
		require_once(DIR . '/includes/adminfunctions_user.php');
		require_once(DIR . '/includes/adminfunctions_profilefield.php');

		$db = vB::getDbAssertor();

		$conditions = $this->fetchUserSearchCondition($user, $profile);
		$countusers = $db->getField('userFindCount', [
			'filters' => $conditions['filters'],
			'joins' => $conditions['joins'],
			'exceptions' => $conditions['exceptions'],
			'unions' => $conditions['unions'] ?? [],
			'do_username_or_displayname' => $conditions['do_username_or_displayname'] ?? [],
		]);

		$users = $db->getRows('userFind', [
			'filters' => $conditions['filters'],
			'joins' => $conditions['joins'],
			'exceptions' => $conditions['exceptions'],
			'unions' => $conditions['unions'] ?? [],
			'do_username_or_displayname' => $conditions['do_username_or_displayname'] ?? [],
			'orderby' => $orderby,
			'direction' => $direction,
			'limitstart' => $limitstart,
			vB_dB_Query::PARAM_LIMIT => $limitnumber,
		]);

		if ($countusers == 0)
		{
			// no users found!
			return false;
		}
		else
		{
			return [
				'users' => $users,
				'count' => $countusers,
			];
		}
	}

	/**
	 * This returns a user's additional permissions from the groupintopic table
	 *
	 *	@param int $userid
	 *	@param int $nodeid -- optional
	 *	@param boolean $forceReload -- optional defaults to false
	 *
	 *	@return	array -- Array of ['nodeid' => nodeid, 'groupid' => groupid];
	 */
	public function getGroupInTopic($userid = false, $nodeid = false, $forceReload = false)
	{
		$userInfo = vB::getCurrentSession()->fetch_userinfo();
		$currentUserId = $userInfo['userid'];

		//we need a single int for userid;
		if (!$userid)
		{
			$userid = $currentUserId;
		}
		else if (!is_numeric($userid) OR !intval($userid))
		{
			throw new vB_Exception_Api('invalid_request');
		}
		else
		{
			$userid = intval($userid);
		}

		//check permissions
		if (($userid != $currentUserId) AND
			!vB::getUserContext()->getChannelPermission('moderatorpermissions', 'canaddowners', $nodeid))
		{
			throw new vB_Exception_Api('no_permission');
		}

		return $this->library->getGroupInTopic($userid, $nodeid, $forceReload);
	}

	/**
	 * This is a wrapper for userContext getCanCreate- it returns the content types a user can create
	 *
	 *	@param	int $nodeid
	 *	@return array -- types the user can create in that node
	 */
	public function getCanCreate($nodeid)
	{
		if (empty($nodeid))
		{
			return false;
		}
		return vB::getUserContext()->getCanCreate($nodeid);
	}

	/**
	 * This grants a user additional permissions in a specific channel, by adding to the groupintopic table
	 *
	 * @param	int $userid
	 * @param	array|int $nodeids
	 * @param	int $usergroupid
	 *
	 * @return	bool
	 */
	public function setGroupInTopic($userid, $nodeids, $usergroupid)
	{
		//check the data.
		if (!is_numeric($userid) OR !is_numeric($usergroupid))
		{
			throw new vB_Exception_Api('invalid_data');
		}

		if (!is_array($nodeids))
		{
			$nodeids = [$nodeids];
		}
		else
		{
			$nodeids = array_unique($nodeids);
		}

		$usercontext = vB::getUserContext();
		//check permissions
		foreach ($nodeids AS $nodeid)
		{
			if (!$usercontext->getChannelPermission('moderatorpermissions', 'canaddowners', $nodeid ))
			{
				throw new vB_Exception_Api('no_permission');
			}

		}

		//class vB_User does the actual work. Here we just want to clean the data.
		return vB_User::setGroupInTopic($userid, $nodeids, $usergroupid);
	}


	/**
	 * This removes additional permissions a user was given in a specific channel, by removing from the groupintopic table
	 *
	 *	@param	int		$userid		user for whom we are unsetting GIT records
	 *	@param	array|int	$nodeids	(integer or array of integers) nodeid(s) of the GIT record(s) to unset
	 * 	@param	int		$usergroupid	usergroupid of the GIT record to unset
	 *
	 *	@return	bool
	 */
	public function unsetGroupInTopic($userid, $nodeids, $usergroupid)
	{
		//check the data.
		if (!is_numeric($userid) OR !is_numeric($usergroupid))
		{
			throw new vB_Exception_Api('invalid_data');
		}

		if (!is_array($nodeids))
		{
			$nodeids = [$nodeids];
		}
		else
		{
			$nodeids = array_unique($nodeids);
		}

		//check permissions
		$usercontext = vB::getUserContext();
		//this requires moderatorpermissions->canmoderatetags
		foreach ($nodeids as $nodeid)
		{
			if (
				(!$usercontext->getChannelPermission('moderatorpermissions', 'canaddowners', $nodeid )) AND
				!($userid == $usercontext->fetchUserId())
			)
			{
				throw new vB_Exception_Api('no_permission');
			}
		}

		//and do the deletes
		foreach ($nodeids as $nodeid)
		{
			vB::getDbAssertor()->assertQuery('vBForum:groupintopic', [
				vB_dB_Query::TYPE_KEY => vB_dB_Query::QUERY_DELETE,
				'userid'  => $userid,
				'nodeid'  => $nodeid,
				'groupid' => $usergroupid
			]);

			//deny any pending request
			$pending = vB::getDbAssertor()->assertQuery('vBForum:fetchPendingChannelRequestUser', [
				'msgtype' => 'request',
				'aboutid' => $nodeid,
				'about' => [
					vB_Api_Node::REQUEST_TAKE_MODERATOR,
					vB_Api_Node::REQUEST_TAKE_OWNER,
					vB_Api_Node::REQUEST_SG_TAKE_MODERATOR,
					vB_Api_Node::REQUEST_SG_TAKE_OWNER
				],
				'userid' => $userid
			]);
			if ($pending)
			{
				$messageLib = vB_Library::instance('content_privatemessage');
				foreach ($pending as $p)
				{
					$messageLib->denyRequest($p['nodeid'], $userid);
				}
			}
		}
		vB_Cache::allCacheEvent(["userPerms_$userid", "followChg_$userid", "sgMemberChg_$userid"]);
		vB_Api::instanceInternal('user')->clearChannelPerms($userid);
		vB::getUserContext($userid)->reloadGroupInTopic();
		vB::getUserContext()->clearChannelPermissions();
		//if we got here all is well.
		return true;
	}


	/**
	 * This method clears remembered channel permission
	 *
	 * @param int The userid to be cleared
	 */
	public function clearChannelPerms($userid)
	{
		$this->library->clearChannelPerms($userid);
		return ['success' => true];
	}

	/**
	 * Registers userids that we will later be fetching avatars for. If we
	 * register the userids here, they can be fetched in batches.
	 *
	 * @param array Array if integer user IDs for the users whose avatars we will be fetching later.
	 */
	public function registerNeedAvatarForUsers($userids)
	{
		$this->library->registerNeedAvatarForUsers($userids);
		return ['success' => true];
	}

	/**
	 * Fetches the URL for a User's Avatar
	 *
	 * @param int $userid
	 * @param string|bool $typekey
	 * @param array	$userinfo -- Array of userinfo, possibly already containing the avatar information
	 * @return array Information regarding the avatar
	 */
	public function fetchAvatar($userid, $typekey = false, $userinfo = [])
	{
		// fetchAvatars wants an array of userinfos
		if ($userinfo)
		{
			$userinfo = [$userinfo['userid'] => $userinfo];
		}
		else
		{
			$userinfo = [];
		}

		$result = $this->library->fetchAvatars([$userid], $typekey, $userinfo);

		//This shouldn't be possible.  The library function should return the default avatar
		//if all else fails regardless of he userid.  Leaving this in in case that changes.
		if (empty($result[$userid]))
		{
			throw new vB_Exception_Api('invalid_user_specified');
		}

		return $result[$userid];
	}

	/**
	 * Fetch the Avatars for a userid array
	 *
	 * @param array $userids
	 * @param string|bool $typekey
	 * @param array	$userinfo -- array of $userid => userinfo, possibly already containing the avatar information
	 * @return array Information regarding the avatar
	 */
	public function fetchAvatars($userids = [], $typekey = false, $userinfo = [])
	{
		if (!$userinfo)
		{
			$userinfo = [];
		}

		return $this->library->fetchAvatars($userids, $typekey, $userinfo);
	}

	/**
	 * Fetches the Profile Fields that needs to be displayed in Registration From
	 *
	 * @param array $userinfo User information as fields' current value
	 * @return array Profile fields
	 */
	public function fetchProfileFieldsForRegistration($userinfo = [])
	{
		$profilefields = vB::getDbAssertor()->getRows('user_fetchprofilefieldsforregistration');
		$this->_processProfileFields($profilefields, $userinfo);
		return $profilefields;
	}

	/**
	 * Process Profile Fields for templates
	 *
	 * @param array $profilefields (ref) Profile fields (database records array) to be processed.
	 * @param array $currentvalues Current values of the profile fields
	 * @return void
	 */
	protected function _processProfileFields(&$profilefields, $currentvalues)
	{
		$phraseapi = vB_Api::instanceInternal('phrase');

		$customfields_other = [];
		$customfields_profile = [];
		$customfields_option = [];

		foreach ($profilefields AS $field)
		{
			$field['fieldname'] = "field$field[profilefieldid]";
			$field['optionalname'] = $field['fieldname'] . '_opt';

			$titleanddescription = $phraseapi->fetch([$field['fieldname'] . '_title', $field['fieldname'] . '_desc']);

			$field['title'] = $titleanddescription[$field['fieldname'] . '_title'];
			$field['description'] = $titleanddescription[$field['fieldname'] . '_desc'];

			$field['foundfield'] = 0;

			$field['currentvalue'] = '';
			if ($currentvalues)
			{
				$field['currentvalue'] = $currentvalues['userfield'][$field['fieldname']];
			}

			//this really needs to be standardized because the fields that are set are *all* over the place
			//and appear to be very keyed to the specifics of the display.
			if ($field['type'] == 'select')
			{
				$field['data'] = vb_unserialize($field['data']);

				$field['bits'] = [];
				foreach ($field['data'] as $key => $val)
				{
					$key++;
					$field['bits'][$key]['val'] = $val;
					$field['bits'][$key]['selected'] = false;
					if (isset($field['currentvalue']))
					{
						if (trim($val) == $field['currentvalue'])
						{
							$field['bits'][$key]['selected'] = true;
							$field['foundfield'] = 1;
						}
					}
					else if ($field['def'] AND $key == 1)
					{
						$field['bits'][$key]['selected'] = true;
						$field['foundfield'] = 1;
					}
				}

				// No empty option
				if (!$field['foundfield'])
				{
					$field['selected'] = true;
				}
				else
				{
					$field['selected'] = false;
				}
			}
			elseif ($field['type'] == 'select_multiple')
			{
				$field['data'] = unserialize($field['data']);
				if ($field['height'] == 0)
				{
					$field['height'] = count($field['data']);
				}

				$current = intval($field['currentvalue']);
				$field['bits'] = [];
				foreach ($field['data'] AS $key => $val)
				{
					$key++;
					$field['bits'][$key]['val'] = $val;
					$field['bits'][$key]['selected'] = boolval($current & pow(2, $key - 1));
				}
			}
			elseif ($field['type'] == 'checkbox')
			{
				$field['data'] = unserialize($field['data']);

				$current = intval($field['currentvalue']);
				$field['bits'] = [];
				foreach ($field['data'] AS $key => $val)
				{
					$key++;
					$field['bits'][$key]['val'] = $val;
					$field['bits'][$key]['selected'] = boolval($current & pow(2, $key - 1));
				}
			}
			elseif ($field['type'] == 'radio')
			{
				$field['data'] = unserialize($field['data']);

				$field['bits'] = [];
				foreach ($field['data'] AS $key => $val)
				{
					$key++;
					$field['bits'][$key]['val'] = $val;
					$field['bits'][$key]['checked'] = false;

					//this needs to be cleaned up because it's *way* to tied to expected usage
					if (!$field['currentvalue'] AND $key == 1 AND $field['def'] == 1)
					{
						$field['bits'][$key]['checked'] = true;
					}
					else if (trim($val) == $field['currentvalue'])
					{
						$field['bits'][$key]['checked'] = 'checked="checked"';
						$field['foundfield'] = 1;
					}
				}
			}


			if ($field['required'] == 2)
			{
				// not required to be filled in but still show
				$customfields_other[] = $field;
			}
			else // required to be filled in
			{
				if ($field['form'])
				{
					$customfields_option[] = $field;
				}
				else
				{
					$customfields_profile[] = $field;
				}
			}

		}

		$profilefields = [
			'other' => $customfields_other,
			'option' => $customfields_option,
			'profile' => $customfields_profile,
		];
	}

	/**
	 * Delete a user
	 *
	 * @param integer 	int 	 	The ID of user to be deleted
	 * @param bool 		boolean 	Whether to transfer the Groups and Blogs owned by the user to current logged-in admininstrator
	 */
	public function delete($userid, $transfer_groups = true)
	{
		$this->checkHasAdminPermission('canadminusers');

		// Admin userid to transfer groups & blogs to.
		if ($transfer_groups)
		{
			$adminuserid = vB::getCurrentSession()->fetch_userinfo_value('userid');
		}
		else
		{
			$adminuserid = null;
		}

		return $this->library->delete($userid, $transfer_groups, $adminuserid);
	}

	/**
	 * Shortcut to saving only email and password if user only has permission to modify password and email
	 *
	 * Saves the email and password for the current logged in user.
	 *
	 * @param array $extra Generic flags or data to affect processing.
	 * @param string email
	 * @param string newpass
	 * @param string password -- existing password to verify (we verify passwords before changing email/password)
	 * @return integer New or updated userid.
	 */
	private function saveEmailPassword($email, $newpass, $password)
	{
		$context = vB::getUserContext();
		$userid = $context->fetchUserId();
		if (!$userid)
		{
			throw new vB_Exception_Api('no_permission');
		}

		// Password & email
		if ($newpass OR $email)
		{
			if (!$password)
			{
				throw new vB_Exception_Api('enter_current_password');
			}

			/** @var vB_Library_Login */
			$loginlib = vB_Library::instance('login');

			$userinfo = vB_User::fetchUserinfo($userid);
			$login = array_intersect_key($userinfo, array_flip(['userid', 'token', 'scheme', 'rememberme_secret',]));
			$auth = $loginlib->verifyPasswordFromInfo($login, [['password' => $password, 'encoding' => 'text']]);

			if (!$auth['auth'])
			{
				throw new vB_Exception_Api('badpassword', vB5_Route::buildUrl('lostpw|fullurl'));
			}

			$userdata = new vB_DataManager_User(vB_DataManager_Constants::ERRTYPE_ARRAY_UNPROCESSED);
			$userdata->set_existing($userinfo);

			if ($newpass)
			{
				$loginlib->setPassword($userinfo['userid'], $newpass,
					['passwordhistorylength' => $context->getUsergroupLimit('passwordhistory')]
				);

				//the secret really isn't related to the password, but we want to change it
				//periodically and for now "every time the user changes their password"
				//works (we previously used the password salt so that's when it got changed
				//prior to the refactor).
				/** @var vB_Library_User */
				$userLib = vB_Library::instance('user');
				$secret = $userLib->generateUserSecret();
				$userdata->set('secret', $secret);
			}

			//save the email if set
			if ($email)
			{
				$userdata->set('email', $email);
			}

			if ($userdata->has_errors(false))
			{
				throw $userdata->get_exception();
			}
			$userdata->save();

			// clear user info cached
			$this->library->clearUserInfo([$userid]);
			vB_Cache::instance(vB_Cache::CACHE_FAST)->event('userChg_' . $userid);
			vB_Cache::instance(vB_Cache::CACHE_LARGE)->event('userChg_' . $userid);
		}
		else
		{
			//don't fail quietly if we got here and *didn't* save the username/password
			throw new vB_Exception_Api('no_permission');
		}

		return vB::getUserContext()->fetchUserId();
	}

	/**
	 *	Skip some checks (current save profile permission and birthday required) when updating an existing
	 *	user if only specific elements are set in the params.  We want the user to be able to update these
	 *	items (usually via some side call the user isn't explicitly aware of) regardless of their
	 *	permissions.
	 *
	 *	We never want to skip these checks when creating a new user.
	 */
	private function alwaysAllowSave(
		$userid,
		$password,
		$user,
		$options,
		$adminoptions,
		$userfield,
		$notificationOptions,
		$hvinput,
		$extra,
		$moderatorNotificationOptions,
		$moderatorEmailNotificationOptions
	)
	{
		if (!$userid OR $password OR $userfield OR $adminoptions OR $notificationOptions OR $moderatorNotificationOptions OR $moderatorEmailNotificationOptions)
		{
			return false;
		}

		$allowed = [
			[$options, ['dstonoff']],
			[$user, ['location', 'privacyconsent']],
			[$extra, ['acnt_settings']],
		];

		foreach ($allowed AS $pair)
		{
			if (array_diff(array_keys($pair[0]), $pair[1]))
			{
				return false;
			}
		}

		return true;
	}

	/**
	 * Insert or Update an user
	 *
	 * @param integer $userid Userid to be updated. Set to 0 if you want to insert a new user.
	 * @param string $password Password for the user. Empty means no change.  May be overriden by the $extra array
	 * @param array $user Basic user information such as email or home page
	 * 	* username
	 * 	* email
	 * 	* usertitle
	 * 	* birthday
	 * 	* usergroupid (will get no_permissions exception without administrate user permissions)
	 * 	* membergroupids (will get no_permissions exception without administrate user permissions)
	 *  * privacyconsent   int  -1|0|1 meaning Privacy-Consent Withdrawn|Unknown|Given respectively.
	 *	* list not complete
	 * @param array $options vB options for the user
	 * @param array $adminoptions Admin Override Options for the user
	 * @param array $userfield User's User Profile Field data
	 * @param array $notificationOptions
	 * @param array $hvinput Human Verify input data. @see vB_Api_Hv::verifyToken()
	 * @param array $extra Generic flags or data to affect processing.
	 *	* email
	 *	* newpass
	 *	* password
	 *	* acnt_settings => 1 if we are editing the user as a normal user (suppresses
	 *		adminoverride if the user is an admin.  This is really misnamed and only treats
	 *		the request as from a normal user even if the user is an admin.
	 *	* fbautoregister => true if we are using the FB quick registration.  This skips some checks
	 *		such as the HV *if* we actually have a facebook account
	 * @param array $moderatorNotificationOptions
	 * @param array $moderatorEmailNotificationOptions
	 * @return integer New or updated userid.
	 */
	public function save(
		$userid,
		$password,
		$user,
		$options,
		$adminoptions,
		$userfield,
		$notificationOptions = [],
		$hvinput = [],
		$extra = [],
		$moderatorNotificationOptions = [],
		$moderatorEmailNotificationOptions = []
	)
	{
		$db = vB::getDbAssertor();
		$datastore = vB::getDatastore();
		$userContext = vB::getUserContext();
		$request = vB::getRequest();

		$vboptions = $datastore->getValue('options');
		$currentUserId = $userContext->fetchUserId();
		$userid = intval($userid);
		$coppauser = false;

		//set up some booleans to control behavior.  This is done to simply/document the later code
		$newuser = (!$userid);
		$canadminusers = $this->hasAdminPermission('canadminusers');
		/*
		 * If this was called from the account settings or registration pages
		 * (not the Admin Control Panel) then we shouldn't be setting admin override.
		 * Should also make sure that the admin is logged in and its not just a case of someone
		 * telling the API that we're in the ACP
		 */
		$adminoverride = ($canadminusers AND empty($extra['acnt_settings']) AND empty($extra['registration']));
		$changingCurrentUser = ($userid == $currentUserId);


		//Somebody added the email/password to a seperate array to avoid having to call the API properly
		//by setting the fields in their proper places.  We should unwind that but that involves finding
		//and testing the caller.  For now we'll do it here and make sure that the two ways are
		//equivilent.  Based on prior usage (where we *weren't* consisistent in terms of how the two
		//ways of passing the info behaved) the fields in the extra array will take precendence if
		//both are passed (which shouldn't happen anyway).
		//
		//The extra array fields should not be used after this point.
		if (!empty($extra['email']))
		{
			$user['email'] = $extra['email'];
		}

		//new password to set
		if (!empty($extra['newpass']))
		{
			$password = $extra['newpass'];
		}

		//the user's existing password -- needed to verify to set certain sensative fields.
		if (!empty($extra['password']))
		{
			$user['password'] = $extra['password'];
		}

		$targetUserIsAdmin = false;
		$facebookemailVerified = false;
		if (!$newuser)
		{
			$targetUserContext = vB::getUserContext($userid);
			$targetUserIsAdmin = $targetUserContext->isAdministrator();
			if (isset($user['privacyconsent']) AND $user['privacyconsent'] == -1 AND $targetUserIsAdmin)
			{
				throw new vB_Exception_Api('privacyconsent_admincannotwithdraw');
			}

			//make sure these are defined
			$isfacebooksignup = false;
			$fbautoregister = false;
		}
		else
		{
			$fblib = vB_Library::instance('facebook');

			//if this is an override scenario then the FB user is the admin user and we don't want to
			//process as a facebook signup -- we don't know if the end user is an FB user and we won't link
			//the accounts.
			$isfacebooksignup = (!$adminoverride AND $fblib->isFacebookEnabled() AND $fblib->userIsLoggedIn());

			//we'll be in "autoregister" mode if a) facebook is on, b) we're configured to do it, c) we request it
			//the front end.  The front end shouldn't request it if it isn't configured but we don't trust the front end.
			$fbautoregister = ($isfacebooksignup AND $vboptions['facebookautoregister'] AND !empty($extra['fbautoregister']));

			if ($fbautoregister)
			{
				//we might want a check like this for the normal facebook sign in:
				//If the fb user already has a FB account don't allow them to create an new one
				//In auto register mode we *have* to connect to an FB account or this isn't going to work
				if ($fblib->getVbUseridFromFbUserid())
				{
					throw new vB_Exception_Api('facebook_user_already_connected');
				}

				//if the fb email matches the email the user is using we don't need to verify it.
				//we won't use this until later but let's keep the FB logic in one place, especially
				//things that need the library.
				$facebookemailVerified = ($fblib->getFbUserInfo()['email'] == $user['email']);

				//we don't require a password with FB autoregister (and, in fact, actively avoid it).
				//Ideally we'd set the password hash to something invalid like '*' which would prevent
				//a login via password entirely.  However, a bunch of logic below aggressively vaidates
				//the existence of a password and figuring out how to skip all that is more effort than
				//it's worth right now.  Instead will randomly generate a long, secure password and then
				//not tell anybody about it.
				if (!$password)
				{
					$random = new vB_Utility_Random();
					$password = $random->alphanumeric(32);
				}
			}

			// check referral code; add referrerid, which is what the datamanager understands
			if (!empty($user['referralcode']))
			{
				$referUserLibrary = vB_Library::instance('referuser');
				$referrerid = $referUserLibrary->getUseridFromReferralCode($user['referralcode']);
				if ($referrerid)
				{
					$user['referrerid'] = $referrerid;
				}
				unset($user['referralcode'], $referrerid);
			}
		}

		// Not sure why we do this at all.  The caller should handle this appropriately.
		// We shouldn't set $userid = $currentUserId if $userid == 0 here
		// Cause we may need to allow logged-in user to register again
		if ($userid < 0 AND $currentUserId)
		{
			$userid = $currentUserId;
		}

		//we'll need this all over the place if this isn't a new user.
		$userinfo = []; // Also passed into checkEmail() (though not used) for new user, so we need to set it.
		if (!$newuser)
		{
			$userinfo = vB_User::fetchUserinfo($userid);
		}

		//something of a hack, but we don't want the DST autocorrect or privacy updates to fail
		//because of general permission or validation checks failures
		$alwaysAllow = $this->alwaysAllowSave($userid, $password, $user, $options, $adminoptions,
			$userfield, $notificationOptions, $hvinput, $extra, $moderatorNotificationOptions, $moderatorEmailNotificationOptions);

		//check some permissions.  If we can admin users we can skip all of these checks.  Some checks
		//only apply to some cases, such as registering a newuser.  We also check various fields
		//in some cases and not others.
		if (!$canadminusers)
		{
			if ($newuser)
			{
				// Check if registration is allowed
				if (!$vboptions['allowregistration'])
				{
					throw new vB_Exception_Api('noregister');
				}

				// Check Multiple Registrations Per User
				if ($currentUserId AND !$vboptions['allowmultiregs'])
				{
					$currentUser = vB::getCurrentSession()->fetch_userinfo();
					throw new vB_Exception_Api('signing_up_but_currently_logged_in_msg', [
						$currentUser['username'],
						$vboptions['frontendurl'] . '/auth/logout?logouthash=' . $currentUser['logouthash']
					]);
				}

				// If it's a new registration, we need to verify the HV
				// VBV-9386: HV is disabled when accessing through the VB_API in vb4.
				// There is also a comment saying that it should be enabled once it goes live???
				if (!$fbautoregister AND (!defined('VB_API') OR VB_API !== true))
				{
					vB_Api::instanceInternal('hv')->verifyToken($hvinput, 'register');
				}

				// Verify Stop Forum Spam
				//we're going to reject this user when we check the email, so not point in bothering
				//3rd parties about it.  Probably best to move the checkEmail call above this block
				//so we don't need to bother, but I'm not 100% sure how that interacts with the
				//Email/Password save call in the next block (which probably be moved to the newer
				//alwaysAllow logic
				if (!empty($user['email']))
				{
					$nospam = vB_StopForumSpam::instance();
					if (!$nospam->checkRegistration($user['username'], $request->getIpAddress(), $user['email']))
					{
						throw new vB_Exception_Api('noregister');
					}
				}
			}

			//existing user
			else
			{
				//attempting to update somebody else's profile -- only admins can do this
				if (!$changingCurrentUser)
				{
					throw new vB_Exception_Api('no_permission');
				}

				if (!$userContext->hasPermission('genericpermissions', 'canmodifyprofile'))
				{

					//if we are only changing stuff that we allow without the permission than skip this
					//and just do the normal save.
					if (!$alwaysAllow)
					{
						//this is wierd.
						//1) We need to check that we aren't trying to do anything else
						//2) Should check that there is something in $extra to save.  Otherwise
						//	it succees while doing nothing
						//3) should throw "no permission" if we aren't just saving the email
						//4) saving DST and updating password without permission is technically
						//	valid (but not actually going to happen) and currently will quietly
						//	change the password without doing anything else
						//Declining to fix as part of DST bug because of potential regression.

						return $this->saveEmailPassword($user['email'] ?? null, $password, $user['password'] ?? null);
					}
				}

				if (isset($user['privacy_options']) AND !$userContext->hasPermission('usercsspermissions', 'caneditprivacy'))
				{
					// User doesn't have permission to update privacy
					throw new vB_Exception_Api('no_permission');
				}

				if (isset($options['invisible']) AND !empty($options['invisible']) AND !$userContext->hasPermission('genericpermissions', 'caninvisible'))
				{
					// User doesn't have permission to go invisible
					throw new vB_Exception_Api('no_permission');
				}
			}

			//handle some fields that users should not be able to set (the admin can do what he wants)
			if (isset($user['usergroupid']))
			{
				throw new vB_Exception_Api('no_permission');
			}

			if (isset($user['membergroupids']))
			{
				throw new vB_Exception_Api('no_permission');
			}
		}

		/*
		 * Some checks for all cases.
		 */

		//don't allow changes to an unalterable user unless the user themselves requests it.  We might want to lock down what the
		//user can edit in this case.
		require_once(DIR . '/includes/adminfunctions.php');
		if (!$changingCurrentUser AND is_unalterable_user($userid))
		{
			throw new vB_Exception_Api('user_is_protected_from_alteration_by_undeletableusers_var');
		}

		// TODO: What's the difference in data between $userinfo & $olduser? Why do we need both?
		$olduser = [];
		if ($userid != 0)
		{
			// Get old user information
			$olduser = $db->getRow('user_fetchforupdating', [
				'userid'              => $userid,
			]);

			if (!$olduser)
			{
				throw new vB_Exception_Api('invalid_user_specified');
			}
		}

		// if birthday is required -- but don't trigger the error if this is an existing user and we are only
		// updating the DST value.  This isn't the cleanest thing, but we need the DST autocorrect to work
		// regardless of most permission/validation issues.
		if (!$alwaysAllow AND $vboptions['reqbirthday'] AND empty($olduser['birthday']) AND empty($user['birthday']))
		{
			if (count($userfield))
			{
				throw new vB_Exception_Api('birthdayfield');
			}
			else
			{
				throw new vB_Exception_Api('birthdayfield_nonprofile_tab');
			}
		}


		/*
		 *	If we are changing the password or email from the account setting we need to validate the users
		 *	existing password.
		 */


		$this->checkEmail($newuser, $user, $userinfo, $adminoverride);

		//we never want to save a blank email.  If the email isn't set and it
		//passed the check function its because we don't want to change the
		//existing email.
		if (empty($user['email']))
		{
			unset($user['email']);
		}

		//if we are setting the password or the email we may need to check the user's existing
		//password as an extra precaution.
		// * If this is an existing user
		// * If we are changing the password or email
		// * If we are not overriding as an admin

		if (!$newuser AND (!empty($password) OR !empty($user['email'])) AND !$adminoverride)
		{
			/** @var vB_Library_Login */
			$loginlib = vB_Library::instance('login');
			if (empty($user['password']))
			{
				throw new vB_Exception_Api('enter_current_password');
			}

			$login = array_intersect_key($userinfo, array_flip(['userid', 'token', 'scheme', 'rememberme_secret',]));
			$auth = $loginlib->verifyPasswordFromInfo($login, [['password' => $user['password'], 'encoding' => 'text']]);

			if (!$auth['auth'])
			{
				throw new vB_Exception_Api('badpassword', vB5_Route::buildUrl('lostpw|fullurl'));
			}
		}
		//this is the user's existing password which we don't need now that we've verified it.
		//attempting to set it to the DM, which we do below for all user fields causes problems.
		unset($user['password']);

		//if this is a newuser we need to have a password -- even if this is an admin creating the user
		if ($newuser AND empty($password))
		{
			throw new vB_Exception_Api('invalid_password_specified');
		}


		if ($adminoverride)
		{
			if (!isset($user['ipaddress']))
			{
				if ($newuser)
				{
					$user['ipaddress'] = "0.0.0.0";
				}
				else
				{
					$user['ipaddress'] = $userinfo['ipaddress'];
				}
			}
		}
		else
		{
			if ($newuser || $changingCurrentUser)
			{
				$user['ipaddress'] = $request->getIpAddress();
			}
			else
			{
				$user['ipaddress'] = $userinfo['ipaddress'];
			}
		}

		// user DM checks moved to API.
		$this->checkAndFormatBirthday($newuser, $user, $olduser, $adminoverride, $vboptions);
		$this->checkUsernameInternal($newuser, $user, $olduser, $adminoverride, $vboptions);
		// Ignore non-admin attempts to set displayname when feature is disabled
		$canChangeDisplayname = $this->canChangeDisplaynameInternal($newuser, $user, $olduser, $adminoverride, $vboptions);
		if (!$canChangeDisplayname)
		{
			unset($user['displayname']);
		}
		$this->checkDisplaynameInternal($newuser, $user, $olduser, $adminoverride, $vboptions);

		// Note, COPPA check is currently reproduced in the library. That might change in the future.
		// COPPA check is done here due to setUsergroup() requiring it (needs to set usergroupid to 4
		// if coppauser)
		$coppauser = false;
		if (!$adminoverride AND $newuser AND $this->useCoppa())
		{
			$coppauser = $this->library->checkCoppa($user);
		}

		$this->validateUserTitle($user, $olduser, $adminoverride);

		$this->validateMembergroupids($user, $newuser, $vboptions, $isfacebooksignup);

		$this->setUserLocation($vboptions, $request, $newuser, $changingCurrentUser, $adminoverride, $userinfo, $user);

		//we only set the usergroup for a newuser but need to check the FB logic here if the email the user gives us
		//matches the facebook email we can skip the email verification step.  We'll treat it as if it was turned off entirely
		$verifyemail = ($vboptions['verifyemail'] AND !$facebookemailVerified);

		//this will be repeated in the library without the fb override.
		$this->library->setUsergroup($user, $newuser, $vboptions, $verifyemail, $coppauser);

		// custom profile fields
		$userfieldscope = "normal";
		if (!empty($userfield) AND is_array($userfield))
		{
			$userfieldscope ="admin";
			if (!$adminoverride)
			{
				if ($newuser)
				{
					$userfieldscope = "register";
				}
				else
				{
					$userfieldscope = "normal";
				}
			}
		}

		$userOptions = [
			'options' => $options,
			'adminoptions' => $this->cleanEmptyAjaxArray($adminoptions),
			'notificationOptions' => $notificationOptions,
			'moderatorNotificationOptions' => $moderatorNotificationOptions,
			'moderatorEmailNotificationOptions' => $moderatorEmailNotificationOptions,
		];

		$saveOptions = [];
		// Splitting up the various checks into own vars to allow fine tuning later.
		if ($adminoverride)
		{
			$saveOptions = [
				'skippasswordhistory' => true,
				'skipactivationemail' => true,
				'skipcoppa' => true,
				'allowdisplayname' => true,
			];
		}
		else
		{
			$saveOptions = [
				'skippasswordhistory' => false,
				'skipactivationemail' => false,
				'skipcoppa' => false,
				'allowdisplayname' => false,
			];
		}
		$saveOptions['userfieldscope'] = $userfieldscope;

		$newuserid = $this->library->save(
			$userid,
			$password,
			$user,
			$userfield,
			$userOptions,
			$saveOptions
		);

		//We shouldn't change these values in the library save so we can depend on them
		//We already set the correct usergroup for email validation in setUsergroup (or didn't
		//in which case verifyEmail should be false) if that gets moved to the library,
		//we'll need to do something here to ensure that we generate same value for
		//$verifyEmail that we do in the library function.
		$verifyEmail = (!$saveOptions['skipactivationemail'] AND isset($user['usergroupid']) AND $user['usergroupid'] == 3);
		vB::getHooks()->invoke('hookUserAfterSave', [
			'adminoverride' => $adminoverride,
			'userid' => $newuserid,
			'newuser' => $newuser,
			'emailVerificationRequired' => $verifyEmail,
			'userIsModerated' => (!$adminoverride AND $newuser AND $vboptions['moderatenewmembers'])
		]);

		return $newuserid;
	}

	private function canChangeDisplaynameInternal(bool $newuser, array $user, array $olduser, bool $adminoverride, array $vboptions) : bool
	{
		// We may need to figure out how to handle NEW users separately here -- i.e. does a registering user setting a display
		// name require the GUEST group to have it, or one of the likely RESULTING group (e.g. REGISTERED, or
		// AWAITINGEMAIL_SYSGROUPID) to have it?
		// For now, since we don't have displayname on the registration form, ignoring that detail.
		// Note that this is also checking permissions on the CURRENT user, not the target user... that detail is also being
		// ignored here because if the current user != target user, we're probably in $adminoverride, otherwise the api::save()
		// will exception out before saving data.
		return $this->canEditDisplayname()['caneditdisplayname'];
	}

	/**
	 * Check if the current user can change/display their displayname.
	 *
	 * @return array{caneditdisplayname:bool}
	 */
	public function canEditDisplayname() : array
	{
		$canadminusers = $this->hasAdminPermission('canadminusers');
		$displaynameEnabled = vB::getDatastore()->getOption('enabledisplayname');
		$canusedisplayname = vB::getUserContext()->hasPermission('genericpermissions2', 'canusedisplayname');

		return [
			// If they have canadminusers, they can modify displaynames. Otherwise check option & permissions.
			'caneditdisplayname' => (
				$canadminusers OR
				$displaynameEnabled AND $canusedisplayname
			),
		];
	}

	// The PHP query string to array encoding doesn't allow for empty arrays.  As we tighten things
	// up the workarounds are showing flaws where they aren't really the correct value.
	// We should come up with a genral solution in the AJAX marshalling but for now we'll patch around
	// known issues.
	private function cleanEmptyAjaxArray(array $array) : array
	{
		if (count($array) == 1 AND isset($array[0]) AND $array[0] === '')
		{
			return [];
		}

		return $array;
	}

	private function validateUserTitle(&$user, $olduser, $adminoverride)
	{
		// If usertitle isn't set or null, just completely remove both usertitle &
		// customtitle and return as to not change *anything*.
		if (!isset($user['usertitle']))
		{
			unset($user['usertitle']);
			unset($user['customtitle']);
			return;
		}

		//if not given assume "user set" as the custom title
		$customtitle = $user['customtitle'] ?? 2;
		$user['customtitle'] = $customtitle;
		$usertitle = ($user['usertitle'] ? $user['usertitle'] : '');
		$titlechanged = (($olduser['usertitle'] ?? '') != $usertitle);
		$userContext = vB::getUserContext();
		$canusecustom = $userContext->hasPermission('genericpermissions', 'canusecustomtitle');

		/*
			Firstly, if the current user does not have canusecustomtitle permission, any attempts
			to change their title or reset it will be interpretted as a reset request.
			However, if their current title is an adminset (customtitle = 1) one, they cannot
			even reset it.

			Apparently $adminoverride can bypass all of that (though I'm not sure when you'd
			have admin perms but no customtitle perms...
		 */
		if (!$canusecustom AND !$adminoverride)
		{
			// without canusecustomtitle, user cannot change or reset an admin-set title.
			if (($olduser['customtitle'] ?? 2) == 1)
			{
				unset($user['usertitle']);
				unset($user['customtitle']);
				return;
			}
			else
			{
				// Per old behavior tests, any requests to their custom title without
				// canusecustomtitle, while their old title is NOT admin-set, is
				// rerouted as a reset request.
				$user['usertitle'] = '';
				$user['customtitle'] = 0;
				return;
			}
		}

		// Reset request. Note that reset takes precedence over the "same title" check below.
		if ($customtitle == 0)
		{
			// This doesn't matter, but let's just blank it out and return.
			$user['usertitle'] = '';
			return;
		}

		// If title has not changed, we don't want to hit any errors or change it in any way,
		// even if the *current* user normally won't be able to set their title to this.
		// This is to prevent a user's saving their profile from mucking up a usertitle
		// that's set by the admin.
		if (!$titlechanged)
		{
			unset($user['usertitle']);
			unset($user['customtitle']);
			return;
		}

		// If they changed the title, and they have canusecustomtitle, they may or
		// may not be allowed to use HTML. Using raw HTML is signaled by customtitle == 1,
		// but is only allowed for admins coming through adminCP. Admins going through
		// the profile get treated as customtitle = 2.
		if ($customtitle == 1 AND !$adminoverride)
		{
			$customtitle = 2;
			// This is important to prevent XSS while we work on removing admin checks out of
			// the user DM.
			$user['customtitle'] = 2;
		}

		$vboptions = vB::getDatastore()->getValue('options');
		//we aren't resetting the title, it's changed and we aren't an admin.  Check the title length.
		//note that we should probably be checking $adminoverride instead of isAdmin (which is already implicit)
		//but that will enforce the limit on admins on the front end which might annoy them since they aren't
		//used to it.  (The overall rule is to treat admins as regular users when editing using normal user
		//UI (which doesn't pass the override flag).
		if (
			vB_String::vbStrlen($usertitle) > $vboptions['ctMaxChars'] AND
			!$userContext->isAdministrator()
		)
		{
			throw new vB_Exception_Api('please_enter_user_title_with_at_least_x_characters', $vboptions['ctMaxChars']);
		}
	}

	private function validateMembergroupids(&$user, $newuser, $vboptions, $isfacebooksignup)
	{
		$membergroupids = false;
		if (isset($user['membergroupids']) AND is_array(($user['membergroupids'])))
		{
			$membergroupids = $user['membergroupids'];
		}

		if ($newuser)
		{
			//if configured and FB is enabled then set the fb usergroup.
			if ($vboptions['facebookusergroupid'] AND $isfacebooksignup)
			{
				if (is_array($membergroupids))
				{
					$membergroupids[] = $vboptions['facebookusergroupid'];
				}
				else
				{
					$membergroupids = [$vboptions['facebookusergroupid']];
				}
			}
		}

		//actually set the usergroup array if we have one
		if (is_array($membergroupids))
		{
			$user['membergroupids'] = $membergroupids;
		}
	}

	private function checkAndFormatBirthday($newuser, &$user, $olduser, $adminoverride, $vboptions)
	{
		if (!isset($user['birthday']))
		{
			// If birthday isn't set, we don't change anything. Only thing to check is
			// if this is a new user and we require a birthday.
			if ($newuser AND $vboptions['reqbirthday'])
			{
				throw new vB_Exception_Api('birthdayfield');
			}

			return;
		}

		/*
			This block preserves a couple of legacy behaviors, restricted to user edits :
			A) If user never set a birthday in the first place, and birthday is not required,
			we quietly ignore an "empty birthday".
			B) (Legacy user DM behavior) If birthday is required, and user previously set a
			legitimate birthday, and we don't have adminoverride, quietly ignore an "empty
			birthday". Note that this is an edge case when birthday is empty, because if
			birthday is NOT empty, we used to hit the 'has_no_permission_change_birthday'
			API check before the DM check.
			We unset & skip the rest of the checks, as otherwise we'll hit other errors with
			and empty birthday at this point (& outside of above cases, we WANT to hit those
			errors).
			That (B) check is extermely edgy and probably not intentional, but at this point
			I'm trying to walk back any unintended changes before we try to simplify some of
			this and make it sane again.
			Legacy code had a distinction between birthday => '' and birthday => []. I don't
			believe this distinction was ever intentional, so I'm flattening both to be treated
			like '' for these edge cases.
		 */
		if (!$newuser AND empty($user['birthday']))
		{
			// Before removing conditionA, fix frontend controller sending blank birthday for
			// VBV-20606
			$conditionA = (!$vboptions['reqbirthday'] AND $olduser['birthday'] == $user['birthday']);
			// Note, $olduser should be populated for !$newuser, no need to check isset.
			// Let's not change the $olduser array in case a check below needs the canonical string
			// format.
			$oldBirthday = $olduser['birthday'];
			$oldBirthdayOk = $this->library->formatAndValidateBirthday($oldBirthday);
			// (B) addendum, old user DM code also restricted the "use existing birthday" year
			// to a range. I'm not sure what the significance of 1901 is, but let's keep the old
			// logic until we can just get rid of this entire block. This is nearly identical to
			// the validation in formatAndValidateBirthday(), except it specifically disallows
			// 0 => '1996' shorthand(?) for the year field for an existing birthday.
			$oldBirthdayOk = ($oldBirthdayOk AND
				$oldBirthday['year'] > 1901 AND
				$oldBirthday['year'] <= date('Y')
			);
			$conditionB = ($vboptions['reqbirthday'] AND !$adminoverride AND $oldBirthdayOk);
			if ($conditionA OR $conditionB)
			{
				unset($user['birthday']);
				return;
			}
		}

		if ($vboptions['reqbirthday'] AND !$newuser AND !$adminoverride)
		{
			/*
			User DM had some code that quietly skipped changing birthdays if it didn't have
			adminoverride, AND current birthday was "OK". This is now done in the above block.

			This seems to implicitly allow setting birthday when none was set previously.
			Keeping the old logic.
			 */
			if (
				$user['birthday'] AND $olduser['birthday'] AND
				$user['birthday'] != $olduser['birthday']
			)
			{
				throw new vB_Exception_Api('has_no_permission_change_birthday');
			}
			// Note, we are implicitly allowing admins to change or even unset the birthday here.
		}

		// Note, formatAndValidateBirthday can modify the birthday.
		$check = $this->library->formatAndValidateBirthday($user['birthday']);
		// This is placed down here to preserve some of the order of checks/exceptions
		// from old code. In particular, when birthday is required and a non admin tries
		// to change the birthday, we should throw the has_no_permission_change_birthday
		// before validation errors. However, remaining check(s) relies on birthday being
		// in a canonical array format.
		if (!$check)
		{
			// The user DM will also call formatAndValidateBirthday() and error
			// out. Might want to remove that redundancy someday.
			throw new vB_Exception_Api('birthdayfield');
		}

		if ($vboptions['reqbirthday'] AND !$adminoverride)
		{
			$birthday = $user['birthday'];
			// Negative month and day signals the user DM to unset the birthday.
			// When birthday is required, only admin is allowed to do this.
			// This specific check checks a bit more than that (e.g. year, OR instead of AND)
			// but that is intended to preserve the old user DM check near verbatim for
			// sake of consistency with legacy behavior. Might tighten this up in the future.
			if (!$adminoverride AND
				($birthday['day'] <= 0 OR $birthday['month'] <= 0 OR $birthday['year'] <= 0)
			)
			{
				throw new vB_Exception_Api('birthdayfield');
			}
		}
	}

	private function setUserLocation($vboptions, $request, $newuser, $changingCurrentUser, $adminoverride, $userinfo, &$user)
	{
		$optionLib = vB_Library::instance('options');
		if ($optionLib->isLocationOptionSet('enable_privacy_registered') OR $optionLib->isLocationOptionSet('enable_account_removal'))
		{
			//we don't have a status (most likely we already know the answer and don't want to check again)
			if (!isset($user['location']))
			{
				//we aren't the current user so we can't look this up from the IP Address
				if ($adminoverride OR (!$newuser AND !$changingCurrentUser))
				{
					$user['location'] = ($newuser ? 'UNKNOWN' : $userinfo['location']);
				}
				else
				{
					//if this is "unknown" because of a failed lookup we may be looking up an additional time but the cache
					//should stop that from overloading the service.
					$user['location'] = $this->library->getIpLocation($request->getIpAddress());
				}
			}
			else
			{
				//let's not change this once it's set unless it's an admin request.
				if (!$newuser AND $userinfo['location'] != 'UNKNOWN' AND !$adminoverride)
				{
					$user['location'] = $userinfo['location'];
				}
			}

			//if we are saving an euuser (or an unknown user) and we don't have Privacy consent, then
			//we need to have the consent flagged.

			//either we have consent given in the params or we have consent in the user record already
			$haveConsent = (!empty($user['privacyconsent']) OR (!$newuser AND $userinfo['privacyconsent'] == 1));
			if (!$adminoverride AND !$haveConsent AND $this->library->checkPrivacyOption('enable_privacy_registered', $user['location']))
			{
				throw new vB_Exception_Api('privacyconsent_required');
			}
		}
		else if ($newuser)
		{
			//if we aren't tracking this and it's a new user, we should set this to "unknown"
			$user['location'] = 'UNKNOWN';
		}
	}

	/**
	 * Checks if email is empty -- and throws an exception if that's a problem.
	 * New users always require a non-empty email address.
	 * Existing users may not blank out an existing email address.
	 * Existing users with an already empty email address are allowed to maintain
	 * it, although it's not recommended (legacy behavior support).
	 *
	 * This function does not validate the email. It only checks if the email is empty.
	 *
	 * @param	boolean   $newuser    True if user is new one
	 * @param	array     $user       Incoming user data to check
	 * @param	array     $userinfo   Current user information (if availiable)
	 * @param   boolean   $adminoverride  true if admin is saving this user "as an admin"
	 *
	 * @throws	vB_Exception_Api('fieldmissing_email')
	 * @throws	vB_Exception_Api('banemail')
	 */
	private function checkEmail($newuser, $user, $userinfo, $adminoverride)
	{
		//if we have a new user the email is always required.
		if ($newuser)
		{
			if (empty($user['email']))
			{
				throw new vB_Exception_Api('fieldmissing_email');
			}
		}
		else
		{
			//otherwise if we have an email address for the existing user
			//and we have a value passed in, but that value is blank
			if (!empty($userinfo['email']) AND array_key_exists('email', $user) AND !$user['email'])
			{
				throw new vB_Exception_Api('fieldmissing_email');
			}

			//if we don't have a user email and the email is blank we want to assume that they didn't
			//change it and allow the save to happen. This is explicitly to prevent legacy cases where
			//there is no email to pass if other fields are being changed.

			//if the email field is not set in the new user data we assume that the caller of the API
			//is not changing the users email value.  Therefore we allow it to be "blank" in this case.
		}

		if (isset($user['email']))
		{
			if ($this->isBannedEmail($user['email']) AND !$adminoverride)
			{
				/*
				A user may *keep* their existing email even if it's banned
				if allowkeepbannedemail option is enabled.
				However, an email cannot be *changed* to a banned email
				whether the user is new or existing.
				 */
				$vboptions = vB::getDatastore()->getValue('options');
				if ($newuser)
				{
					throw new vB_Exception_Api('banemail');
				}
				else if (
					!$vboptions['allowkeepbannedemail'] OR
					$userinfo['email'] !== $user['email']
				)
				{
					throw new vB_Exception_Api('banemail');
				}
			}
		}

		// unique email requirement is checked in user DM.
	}

	public function sendActivateEmail($email)
	{
		$userinfo = $this->fetchByEmail($email);
		$vboptions = vB::getDatastore()->getValue('options');

		if (empty($userinfo))
		{
			throw new vB_Exception_Api('invalidemail', ['mailto:' . $vboptions['webmasteremail']]);
		}

		$this->library->sendActivateEmail($userinfo['userid']);
	}

	/**
	 * Activate an user with an activate ID and Username
	 *
	 * @param string $username Username
	 * @param string $activateid Activate ID
	 *
	 * @throws vB_Exception_Api
	 * @return string User status after activation. Possible values:
	 *         1) moderateuser: user is put into moderate queue
	 *         2) emailchanged: user's email address has been updated successfully
	 *         3) registration_complete: user's registration is completed
	 */

	public function activateUserByUsername($username, $activateid)
	{
		$userinfo = $this->fetchByUsername($username);

		if (!$userinfo)
		{
			throw new vB_Exception_Api('invalid_username');
		}

		return $this->activateUser($userinfo['userid'], $activateid);
	}

	/**
	 * Activate an user with an activate ID
	 *
	 * @param int $userid User ID
	 * @param string $activateid Activate ID
	 *
	 * @throws vB_Exception_Api
	 * @return string User status after activation. Possible values:
	 *		 1) moderateuser: user is put into moderate queue
	 *		 2) emailchanged: user's email address has been updated successfully
	 *		 3) registration_complete: user's registration is completed
	 */
	public function activateUser($userid, $activateid)
	{
		$dbassertor = vB::getDbAssertor();
		$userinfo = vB_User::fetchUserinfo($userid);
		$usercontext = vB::getUserContext($userid);
		$userid = intval($userid);
		$usergroupcache = vB::getDatastore()->getValue('usergroupcache');
		$vboptions = vB::getDatastore()->getValue('options');

		if (!$userinfo)
		{
			throw new vB_Exception_Api('invalidid', [vB_Phrase::fetchSinglePhrase('user')]);
		}

		if ($userid == 0)
		{
			throw new vB_Exception_Api('invalidactivateid', [
				vB5_Route::buildUrl('activateuser|fullurl'),
				vB5_Route::buildUrl('activateemail|fullurl'),
				vB5_Route::buildUrl('contact-us|fullurl')
			]);
		}
		else if ($userinfo['usergroupid'] == 3)
		{
			// check valid activation id
			$user = $dbassertor->getRow('useractivation', [
				'activationid' => $activateid,
				'userid' => $userid,
				'type' => 0
			]);

			if (!$user OR $activateid != $user['activationid'])
			{
				// send email again
				throw new vB_Exception_Api('invalidactivateid', [
					vB5_Route::buildUrl('activateuser|fullurl'),
					vB5_Route::buildUrl('activateemail|fullurl'),
					vB5_Route::buildUrl('contact-us|fullurl')
				]);
			}

			// delete activationid
			$dbassertor->delete('useractivation', ['userid' => $userid, 'type' => 0]);

			if (empty($user['usergroupid']))
			{
				$user['usergroupid'] = 2; // sanity check
			}

			// ### DO THE UG/TITLE UPDATE ###

			$getusergroupid = ($userinfo['displaygroupid'] != $userinfo['usergroupid']) ? $userinfo['displaygroupid'] : $user['usergroupid'];

			$display_usergroup =& $usergroupcache["$getusergroupid"];

			// init user data manager
			$userdata = new vB_DataManager_User(vB_DataManager_Constants::ERRTYPE_STANDARD);
			$userdata->set_existing($userinfo);
			$userdata->set('usergroupid', $user['usergroupid']);
			$userdata->set_usertitle(
				!empty($user['customtitle']) ? $user['usertitle'] : '',
				false,
				$display_usergroup,
				($usercontext->hasPermission('genericpermissions', 'canusecustomtitle')) ? true : false,
				($usercontext->isAdministrator()) ? true : false
			);

			if ($userinfo['coppauser'] OR ($vboptions['moderatenewmembers'] AND !$userinfo['posts']))
			{
				// put user in moderated group
				$userdata->save();
				$result = ['moderateuser', $this->fetchUserName($userid), vB5_Route::buildHomeUrl('fullurl')];
			}
			else
			{
				// activate account -- the datamanager handles statistics updates and permission cache event calls.
				$userdata->save();

				if (!$user['emailchange'])
				{
					if ($vboptions['welcomemail'])
					{
						$string = vB::getString();
						$displayname_safe = $string->htmlspecialchars($userinfo['displayname']);
						$bbtitle_escaped = $string->htmlspecialchars($vboptions['bbtitle']);
						// Send welcome mail
						$maildata = vB_Api::instanceInternal('phrase')->fetchEmailPhrases(
							'welcomemail',
							[
								$displayname_safe,
								$bbtitle_escaped,
							],
							[$vboptions['bbtitle']],
							$userinfo['languageid'] ?? $vboptions['languageid']
						);
						// Skip vbmailWithUnsubscribe(). This should be a once-off email. Note that we send
						// the welcome email from two separate paths, see vB_Library_User::sendNewUserEmails()
						// for the other location.
						vB_Mail::vbmail2($userinfo['email'], $maildata['subject'], $maildata['message'], true);
					}

					$userdata->send_welcomepm(null, $userid);
				}

				if ($user['emailchange'])
				{
					$result = 'emailchanged';
				}
				else
				{
					$result = ['registration_complete',
						vB_String::htmlSpecialCharsUni($userinfo['username']),
						vB5_Route::buildUrl('profile|fullurl', $userinfo),
						vB5_Route::buildUrl('settings|fullurl', ['tab' => 'account']),
						vB5_Route::buildUrl('settings|fullurl', ['tab' => 'account']),
						// Leaving this alone instead of switching to buildHomeUrl()
						// The phrasing refers to "go back to the Forums and start posting...", so going
						// to the forum default page seems to make sense here, regardless of home page
						// (in case of a modified home page).
						vB5_Route::buildUrl('home|fullurl')
					];
				}
			}

			vB::getHooks()->invoke('hookUserAfterActivation', [
				'userid' => $userid,
				'newuser' => !$user['emailchange'],
				'userIsModerated' => ($user['usergroupid'] == 4),
			]);

			return $result;
		}
		else
		{
			if ($userinfo['usergroupid'] == 4)
			{
				// In Moderation Queue
				vB_Cache::instance(vB_Cache::CACHE_FAST)->event(["userPerms_$userid", "userChg_$userid"]);
				vB_Cache::instance(vB_Cache::CACHE_LARGE)->event(["userPerms_$userid", "userChg_$userid"]);
				return 'activate_moderation';
			}
			else
			{
				// Already activated
				throw new vB_Exception_Api('activate_wrongusergroup');
			}
		}
	}


	//this function appears to only be called from the registration controller action and that
	//action doesn't appear to be used anywhere.  This is almost identical to killActivation
	//but not quite.
	public function deleteActivation($userid, $activateid)
	{
		$userid = intval($userid);

		$dbassertor = vB::getDbAssertor();

		$userinfo = vB_User::fetchUserinfo($userid);
		if (!$userinfo)
		{
			throw new vB_Exception_Api('invalidid', [vB_Phrase::fetchSinglePhrase('user'), vB5_Route::buildUrl('contact-us|fullurl')]);
		}

		if ($userinfo['usergroupid'] == 3)
		{
			// check valid activation id
			$user = $dbassertor->getRow('useractivation', [
				'activationid' => $activateid,
				'userid' => $userid,
				'type' => 0
			]);

			if (!$user OR $activateid != $user['activationid'])
			{
				throw new vB_Exception_Api('invalidactivateid',
					[
						vB5_Route::buildUrl('activateuser|fullurl'),
						vB5_Route::buildUrl('activateemail|fullurl'),
						vB5_Route::buildUrl('contact-us|fullurl')
					]
				);
			}

			return ['activate_deleterequest', $user['activationid'], $user['userid']];
		}
		else
		{
			throw new vB_Exception_Api('activate_wrongusergroup');
		}
	}

	/**
	 *
	 */
	public function killActivation($userid, $activateid)
	{
		$userid = intval($userid);
		$dbassertor = vB::getDbAssertor();

		$userinfo = vB_User::fetchUserinfo($userid);
		if (!$userinfo)
		{
			throw new vB_Exception_Api('invalidid',	[vB_Phrase::fetchSinglePhrase('user'), vB5_Route::buildUrl('contact-us|fullurl')]);
		}

		if ($userinfo['usergroupid'] == 3)
		{
			// check valid activation id
			$user = $dbassertor->getRow('useractivation', [
				'activationid' => $activateid,
				'userid' => $userid,
				'type' => 0
			]);

			if (!$user OR $activateid != $user['activationid'])
			{
				throw new vB_Exception_Api('invalidactivateid',
					[
						vB5_Route::buildUrl('activateuser|fullurl'),
						vB5_Route::buildUrl('activateemail|fullurl'),
						vB5_Route::buildUrl('contact-us|fullurl')
					]
				);
			}

			$userdata = new vB_DataManager_User(vB_DataManager_Constants::ERRTYPE_SILENT);
			$userdata->set_existing($userinfo);
			$userdata->set_bitfield('options', 'noactivationmails', 1);
			$userdata->save();

			$dbassertor->delete('useractivation', ['useractivationid' => intval($user['useractivationid'])]);

			return ['activate_requestdeleted'];
		}
		else
		{
			return ['activate_wrongusergroup'];
		}
	}

	private function getFiledataIdsFromSignature($signature)
	{
		$img2Filedataids = [];
		if ($signature AND preg_match_all('#\[(?<tag>attach|img2)=json\](?<jsondata>{(?:(?!}\[/\k<tag>\]).)*})\[/\k<tag>\]#i', $signature, $matches))
		{
			$vboptions = vB::getDatastore()->getValue('options');
			$frontendurl = $vboptions['frontendurl'];
			$ourUrl = parse_url($frontendurl);
			$ourUrl1 = trim($ourUrl['host'], "/") . "/" . trim($ourUrl['path'], "/") . "/core/filedata/fetch";
			$ourUrl2 = trim($ourUrl['host'], "/") . "/" . trim($ourUrl['path'], "/") . "/filedata/fetch";
			foreach ($matches['jsondata'] AS $key => $__data)
			{
				$custom_config = json_decode($__data, true);

				if (empty($custom_config))
				{
					$custom_config = [];
				}

				if (!empty($custom_config['src']))
				{
					$urlData = parse_url($custom_config['src']);
					$checkUrl = trim($urlData['host'], "/") . "/" . trim($urlData['path'], "/");
					if ($checkUrl === $ourUrl1 OR $checkUrl === $ourUrl2)
					{
						parse_str($urlData['query'], $queryData);
						if (!empty($queryData['filedataid']) AND is_numeric($queryData['filedataid']))
						{
							$img2Filedataids[] = intval($queryData['filedataid']);
						}
					}

				}
			}
		}

		return $img2Filedataids;
	}

	/**
	 * Verifies and saves a signature for current logged in user. Returns the signature.
	 * @param string $signature
	 * @param array $filedataids
	 * @return string
	 */
	public function saveSignature($signature, $filedataids = [])
	{
		// This code is based on profile.php
		$options = vB::getDatastore()->getValue('options');

		// *********************** CHECKS **********************
		// *****************************************************

		$userid = vB::getCurrentSession()->get('userid');
		$userid = intval($userid);

		if ($userid <= 0)
		{
			throw new vB_Exception_Api('no_permission_logged_out');
		}

		$userContext = vB::getUserContext($userid);
		if (
			!$userContext->hasPermission('genericpermissions', 'canusesignature')
				OR
			!$userContext->hasPermission('genericpermissions', 'canmodifyprofile')
		)
		{
			throw new vB_Exception_Api('no_permission_signatures');
		}

		if (!empty($filedataids))
		{
			if (!$userContext->hasPermission('signaturepermissions', 'cansigpic'))
			{
				throw new vB_Exception_Api('no_permission_images');
			}

			// Max number of images in the sig if imgs are allowed.
			if ($maxImages = $userContext->getLimit('sigmaximages'))
			{
				if (count($filedataids) > $maxImages)
				{
					throw new vB_Exception_Api('max_attachments_reached');
				}
			}
		}

		// Count the raw characters in the signature
		if (($maxRawChars = $userContext->getLimit('sigmaxrawchars')) AND vB_String::vbStrlen($signature) > $maxRawChars)
		{
			throw new vB_Exception_Api('sigtoolong_includingbbcode', [$maxRawChars]);
		}

		// Image2 hack. Remove the tempid to force any img.bbcode-attachment into img2 bbcode.
		// This forces the Wysiwyg->HTML parser to convert these to img2 tags instead of attach tags, see vB_WysiwygHtmlParser::handleWysiwygAdvancedImageImg()
		// using the filedataid URL in an image2 tag in addition to setting filedata.publicview++/refcount++ allows the images to be visible by other users,
		// and any customizations on it is also rendered by the parser ala image2 bbcode handler.
		if (preg_match_all('#<img(?:(?!>).)*(?<tempidtag>data-tempid=(?<quot>\'|")temp_\\d+_\\d+_\\d+\\k<quot>)(?:(?!>).)*>#i', $signature, $matches))
		{
			$str_search = [];
			$str_replace = [];
			foreach ($matches['tempidtag'] AS $key => $__data)
			{
				$str_search[$__data] = $__data;
				$str_replace[$__data] = '';
			}
			$signature = str_replace($str_search, $str_replace, $signature);
		}

		// *****************************************************
		//Convert signature to BBcode
		$bbcodeApi = vB_Api::instanceInternal('bbcode');
		$signature = $bbcodeApi->parseWysiwygHtmlToBbcode($signature);
		//removing consecutive spaces
		$signature = preg_replace('# +#', ' ', $signature);
		$hasBbcode = $bbcodeApi->hasBbcode($signature);
		if ($hasBbcode AND !$userContext->hasPermission('signaturepermissions', 'canbbcode'))
		{
			throw new vB_Exception_Api('bbcode_not_allowed');
		}

		// add # to color tags using hex if it's not there
		$signature = preg_replace('#\[color=(&quot;|"|\'|)([a-f0-9]{6})\\1]#i', '[color=\1#\2\1]', $signature);

		// Turn the text into bb code.
		if ($userContext->hasPermission('signaturepermissions', 'canbbcodelink'))
		{
			$signature = $bbcodeApi->convertUrlToBbcode($signature);
		}

		/*
			Let's pull out any filedataids we need to make public.

		 */
		$img2Filedataids = $this->getFiledataIdsFromSignature($signature);


		// Create the parser with the users sig permissions
		require_once(DIR . '/includes/class_sigparser.php');
		$sig_parser = new vB_SignatureParser(vB::get_registry(), $bbcodeApi->fetchTagList(), $userid);
		// Parse the signature
		$paresed = $sig_parser->parse($signature);
		if ($error_num = count($sig_parser->errors))
		{
			$e = new vB_Exception_Api();
			foreach ($sig_parser->errors AS $tag => $error_phrase)
			{
				if (is_array($error_phrase))
				{
					$phrase_name = key($error_phrase);
					$params = $error_phrase[$phrase_name];
					$e->add_error($phrase_name, $params);
				}
				else
				{
					$e->add_error($error_phrase, [$tag]);
				}
			}

			throw $e;
		}

		unset($sig_parser);

		// Count the characters after stripping in the signature
		if (($maxChars = $userContext->getLimit('sigmaxchars')) AND (vB_String::vbStrlen(vB_String::stripBbcode($signature, false, false, false)) > $maxChars))
		{
			throw new vB_Exception_Api('sigtoolong_excludingbbcode', [$maxChars]);
		}

		if (($maxLines = $userContext->getLimit('sigmaxlines')) > 0)
		{
			require_once(DIR . '/includes/class_sigparser_char.php');
			$char_counter = new vB_SignatureParser_CharCount(vB::get_registry(), $bbcodeApi->fetchTagList(), $userid);
			$line_count_text = $char_counter->parse(trim($signature));

			if ($options['softlinebreakchars'] > 0)
			{
				// implicitly wrap after X characters without a break
				//trim it to get rid of the trailing whitechars that are inserted by the replace
				$line_count_text = trim(preg_replace('#([^\r\n]{' . $options['softlinebreakchars'] . '})#', "\\1\n", $line_count_text));
			}

			// + 1, since 0 linebreaks still means 1 line
			$line_count = substr_count($line_count_text, "\n") + 1;

			if ($line_count > $maxLines)
			{
				throw new vB_Exception_Api('sigtoomanylines', [$maxLines]);
			}
		}

		// *****************************************************

		// Check for monitored words in signature and send notifications
		$this->library->monitorWords($signature, 'user-signature', null, $userid);

		// Censored Words
		$signature = vB_String::fetchCensoredText($signature);

		// init user data manager
		$userinfo = vB_User::fetchUserinfo($userid);
		$userdata = new vB_DataManager_User(vB_DataManager_Constants::ERRTYPE_STANDARD);
		$userdata->set_existing($userinfo);
		$userdata->set('signature', $signature);

		$db = vB::getDbAssertor();

		/*
			Image2 - Increment & publicize any new filedataids, decrement any old filedataids
		 */
		if (!empty($img2Filedataids))
		{
			$db->assertQuery('incrementFiledataRefcountAndMakePublic', ['filedataid' => $img2Filedataids]);
		}
		$oldImg2Filedataids = $this->getFiledataIdsFromSignature($userinfo['signature']);
		if (!empty($oldImg2Filedataids))
		{
			$db->assertQuery('decrementFiledataRefcount', ['filedataid' => $oldImg2Filedataids]);
		}

		$userdata->save();

		// I did not put this in the userdm as it only applies to saveSiganture
		// Clear autosave table of this items entry
		$db->delete('vBForum:autosavetext', [
			'userid'   => $userid,
			'nodeid'   => 0,
			'parentid' => 0
		]);

		// update userinfo
		$this->library->clearUserInfo([$userid]);

		return $bbcodeApi->parseSignature($userid, $signature, true);
	}

	/**
	 * Fetch a list of users who are awaiting moderate or Coppa
	 *
	 * @return array A list of users that are awaiting moderation
	 */
	public function fetchAwaitingModerate()
	{
		$this->checkHasAdminPermission('canadminusers');
		return vB::getDbAssertor()->getRows('user_fetchmoderate', []);
	}

	/**
	 * Moderate users
	 *
	 * @param array $validate Validate information
	 * @param bool $send_validated Whether to send email to users who have been accepted
	 * @param bool $send_deleted Whether to send email to users who have been deleted
	 * @return bool True if user accounts validated successfully
	 */
/*
	//this is appears to be a port of the admincp/user.php domoderate actions but
	//that code was never updated to call the API function.  We should eventually
	//resurrect this function and call it from the admincp but we need to make sure
	//that its the same as the running code when we do.  This does not appear to have
	//ever been used or properly tested.
	public function moderate($validate, $send_validated, $send_deleted)
	{
		$this->checkHasAdminPermission('canadminusers');

		if (empty($validate))
		{
			throw new vB_Exception_Api('please_complete_required_fields');
		}

		$evalemail_validated = [];
		$evalemail_deleted = [];
		$vboptions = vB::getDatastore()->getValue('options');
		$usergroupcache = vB::getDatastore()->getValue('usergroupcache');
		$bf_ugp_genericpermissions = vB::getDatastore()->getValue('bf_ugp_genericpermissions');

		if ($vboptions['welcomepm'])
		{
			if ($fromuser = vB_User::fetchUserinfo($vboptions['welcomepm']))
			{
				cache_permissions($fromuser, false);
			}
		}

		foreach ($validate AS $userid => $status)
		{
			$userid = intval($userid);
			$user = vB::getDbAssertor()->getRow('user', [
				vB_dB_Query::TYPE_KEY => vB_dB_Query::QUERY_SELECT,
				'#filters' => ['userid' => $userid]
			]);
			if (!$user)
			{
				// use was likely deleted
				continue;
			}
			$username = unhtmlspecialchars($user['username']);

			$chosenlanguage = iif($user['languageid'] < 1, intval($vboptions['languageid']), intval($user['languageid']));

			if ($status == 1)
			{
				// validated

				// init user data manager
				$displaygroupid = ($user['displaygroupid'] > 0 AND $user['displaygroupid'] != $user['usergroupid']) ? $user['displaygroupid'] : 2;

				$userdata = new vB_DataManager_User(vB_DataManager_Constants::ERRTYPE_ARRAY_UNPROCESSED);
				$userdata->set_existing($user);
				$userdata->set('usergroupid', 2);
				$userdata->set_usertitle($user['customtitle'] ? $user['usertitle'] : '',
					false,
					$usergroupcache["$displaygroupid"],
					($usergroupcache['2']['genericpermissions'] &$bf_ugp_genericpermissions['canusecustomtitle']) ? true : false,
					false
				);
				$userdata->save();
				if ($userdata->has_errors(false))
				{
					throw $userdata->get_exception();
				}

				if ($send_validated)
				{
					if (!isset($evalemail_validated["$user[languageid]"]))
					{
						// note that we pass the "all languages" flag as true all the time because if the function does
						// caching internally and is not smart enough to check if the language requested the second time
						// was cached on the first pass -- so we make sure that we load and cache all language version
						// in case the second user has a different language from the first
						$route = vB5_Route::buildUrl('home|fullurl');
						$settings = vB5_Route::buildUrl('settings|fullurl');
						$evalemail_deleted["$user[languageid]"] = vB_Api::instanceInternal('phrase')->fetchEmailPhrases(
							'moderation_validated',
							[
								$route,
								$username,
								$vboptions['bbtitle'],
								$settings,
							],
							[$vboptions['bbtitle']],
							$chosenlanguage
						);
					}
					vB_Mail::vbmail($user['email'], $evalemail_deleted["$user[languageid]"]['subject'], $evalemail_deleted["$user[languageid]"]['message'], true);
				}

				if ($vboptions['welcomepm'] AND $fromuser AND !$user['posts'])
				{
					$userdata = new vB_DataManager_User(vB_DataManager_Constants::ERRTYPE_STANDARD);
					$userdata->send_welcomepm(null, $user['userid']);
				}
			}
			else if ($status == -1)
			{
				// deleted

				if ($send_deleted)
				{
					if (!isset($evalemail_deleted["$user[languageid]"]))
					{
						// note that we pass the "all languages" flag as true all the time because if the function does
						// caching internally and is not smart enough to check if the language requested the second time
						// was cached on the first pass -- so we make sure that we load and cache all language version
						// in case the second user has a different language from the first
						$evalemail_deleted["$user[languageid]"] = vB_Api::instanceInternal('phrase')->fetchEmailPhrases(
							'moderation_deleted',
							[
								$username,
								$vboptions['bbtitle'],
							],
							[$vboptions['bbtitle']],
							$chosenlanguage
						);
					}
					vB_Mail::vbmail($user['email'], $evalemail_deleted["$user[languageid]"]['subject'], $evalemail_deleted["$user[languageid]"]['message'], true);
				}

				$userdm = new vB_DataManager_User(vB_DataManager_Constants::ERRTYPE_SILENT);
				$userdm->set_existing($user);
				$userdm->delete();
				unset($userdm);
			} // else, do nothing
		}
		// rebuild stats so new user displays on forum home
		require_once(DIR . '/includes/functions_databuild.php');
		build_user_statistics();

		return true;
	}
*/

	/**
	 * Return a list of users for pruning or moving
	 *
	 * @param integer $usergroupid Usergroup where the users are in. -1 means all usergroups
	 * @param integer $daysprune   Has not logged on for x days, 0 mean any
	 * @param integer $minposts    Posts is less than, 0 means any
	 * @param array   $joindate    Join Date is Before. It's an array of 'month', 'day' and 'year'. Array means any
	 * @param string  $order       Order by one of the following: 'username', 'email', 'usergroup', 'posts',
	 *                             'lastactivity', 'joindate'. Default: 'username'
	 * @param int     $page        [optional] used with $perpage, resulting users limit offset
	 * @param int     $perpage     [optional] used with $page, resulting users limit rows
	 *
	 * @return array ['users' => array, 'count' => int] :
	 *            'users' => Users to be pruned or moved,
	 *            'count' => total users count (for pagination when using $page & $perpage)
	 */
	public function fetchPruneUsers(
		$usergroupid,
		$includeSecondary,
		$daysprune,
		$minposts,
		$joindate,
		$order,
		$page = 0,
		$perpage = 0
	)
	{
		$this->checkHasAdminPermission('canadminusers');

		//zero will be treated by the query as *no* filter.
		$pruneBefore = 0;
		if ($daysprune)
		{
			$pruneBefore = vB::getRequest()->getTimeNow() - ($daysprune * 86400);
		}

		$params = [
			'usergroupid' => $usergroupid,
			'includesecondary' => $includeSecondary,
			'prunebefore' => $pruneBefore,
			'minposts' => $minposts,
			'joindate' => $joindate,
			'order' => $order,
			'page' => $page,
			'perpage' => $perpage,
		];

		$users = vB::getDbAssertor()->getRows('fetchPruneUsers', $params);


		if ($page > 0 AND $perpage > 0)
		{
			$params['docount'] = true;
			$count = vB::getDbAssertor()->getRow('fetchPruneUsers', $params);
			$count = reset($count);
		}
		else
		{
			$count = count($users);
		}

		return [
			'users' => $users,
			'count' => $count,
		];
	}

	/**
	 * Do prune/move users (step 1)
	 *
	 * @param array $userids UserID to be pruned or moved
	 * @param string $dowhat 'delete' or 'move'
	 * @param integer $movegroup Usergroup ID that the users are going to be moved
	 */
	public function prune($userids, $dowhat, $movegroup = 0)
	{
		$this->checkHasAdminPermission('canadminusers');

		if (empty($userids))
		{
			throw new vB_Exception_Api('please_complete_required_fields');
		}

		$vboptions = vB::getDatastore()->getValue('options');
		if ($dowhat == 'delete')
		{
			foreach ($userids AS $userid)
			{
				$this->delete($userid);
			}
		}
		else if ($dowhat == 'move')
		{
			$group = vB::getDbAssertor()->getRow('user_fetchusergroup', ['usergroupid' => $movegroup]);

			if (!$group)
			{
				throw new vB_Exception_Api('invalidid',
					[vB_Phrase::fetchSinglePhrase('usergroup'), vB5_Route::buildUrl('contact-us|fullurl')]);
			}

			vB::getDbAssertor()->assertQuery('user_updateusergroup', [
				'usergroupid' => $movegroup,
				'userids' => $userids,
			]);
		}
		else
		{
			throw new vB_Exception_Api('user_prune_missing_action');
		}

		return true;
	}

	/**
	 * Do prune/move users (step 2). Userids to be updated are stored in adminutil table.
	 *
	 * @param integer $startat Start at index.
	 * @return integer |bool Next startat value. True means all users have been updated.
	 */
/*
//this function isn't called anywhere and it fundamentally doesn't work.
//(though the obvious errors have been corrected).
//There is a comment in the history about "restoring prune user functionality" so leaving
//it in for reference.  But I'm not sure what needs to be restored and if this function is
//really of any use for doing it.
	public function pruneUpdateposts($startat)
	{
		//function is currently unused and needs testing.
		$this->checkHasAdminPermission('canadminusers');

		$db = vB::getDbAssertor();

		require_once(DIR . '/includes/adminfunctions.php');
		$userids = fetch_adminutil_text('ids');
		if (!$userids)
		{
			$userids = '0';
		}

		//query copied for refernece -- should be a table query.
		//SELECT userid, username
		//FROM {TABLE_PREFIX}user
		//WHERE userid IN ({userids})
		//LIMIT {startat}, 50
		$users = $db->getRows('user_fetch', [
			'userids' => $userids,
			vB_dB_Query::PARAM_LIMITSTART => intval($startat),
		]);

		if ($users)
		{
			foreach ($users as $user)
			{
				$db->update('vBForum:node', ['userid' => 0, 'authorname' => $user['username']],
					['userid',  $user['userid']]);
			}

			return ($startat + 50);
		}
		else
		{
//These queries have been removed so copied here for reference.  The should be convered to table queries anyway.
//			DELETE FROM {TABLE_PREFIX}usertextfield WHERE userid IN({userids})
//			DELETE FROM {TABLE_PREFIX}userfield WHERE userid IN({userids})
//			DELETE FROM {TABLE_PREFIX}user WHERE userid IN({userids})

			$db->assertQuery('user_deleteusertextfield', ['userids' => $userids]);
			$db->assertQuery('user_deleteuserfield', ['userids' => $userids]);
			$db->assertQuery('user_deleteuser', ['userids' => $userids]);

			require_once(DIR . '/includes/functions_databuild.php');
			build_user_statistics();

			return true;
		}
	}
*/

	/**
	 * Merge two users
	 *
	 * @param integer $sourceuserid
	 * @param integer $destuserid
	 */
	public function merge($sourceuserid, $destuserid)
	{
		$this->checkHasAdminPermission('canadminusers');
		$result = $this->library->merge($sourceuserid, $destuserid);

		return $result;
	}



	/**
	 * Return the location for the current user's IP address
	 *
	 * @param string $ipaddress
	 *
	 * @return string.  The location string. Typically CountryCode:RegionCode.
	 * 	In some cases it may be just the CountryCode, the special value EU (for legacy EU users and in some cases
	 * 	where the geoip provider can't track it) and the special value "UNKNOWN".
	 */
	public function getIpLocation()
	{
		$request = vB::getRequest();
		$ipaddress = $request->getIpAddress();

		return ['location' => $this->library->getIpLocation($ipaddress)];
	}

	/**
	 * Search IP Addresses
	 *
	 * @param string $userid An userid. Find IP Addresses for user.
	 * @param integer $depth Depth to Search
	 * @return array 'regip' User's registration IP.
	 *			   'postips' IP addresses which the user has ever used to post
	 *			   'regipusers' Other users who used the same IP address to register
	 */
	public function searchIP($userid, $depth = 1)
	{
		try
		{
			$this->checkHasAdminPermission('canadminusers');
		}
		catch(vB_Exception_Api $e)
		{
			$userContext = vB::getUserContext();
			if (!$userContext->hasModeratorPermission('canviewips'))
			{
				throw $e;
			}
		}

		if (!$depth)
		{
			$depth = 1;
		}
		$userinfo = vB_User::fetchUserinfo(intval($userid));

		if (!$userinfo)
		{
			throw new vB_Exception_Api('invalid_user_specified');
		}

		$retdata['regip'] = $userinfo['ipaddress'];
		$retdata['postips'] = $this->_searchUserIP($userid, 0, $depth);

		if ($userinfo['ipaddress'])
		{
			$retdata['regipusers'] = $this->_searchRegisterIP($userinfo['ipaddress'], $userid, $depth);
		}
		else
		{
			$retdata['regipusers'] = [];
		}

		return $retdata;
	}

	/**
	 * Search IP Addresses
	 *
	 * @param string $ipaddress An IP Address. Find Users by IP Address.
	 * @param integer $depth Search depth
	 * @return array 'postipusers' Users who used the IP address to post
	 *			   'regipusers' Users who used the IP address to register
	 */
	public function searchUsersByIP($ipaddress, $depth)
	{
		try
		{
			$this->checkHasAdminPermission('canadminusers');
		}
		catch(vB_Exception_Api $e)
		{
			$userContext = vB::getUserContext();
			if (!$userContext->hasModeratorPermission('canviewips'))
			{
				throw $e;
			}
		}

		if (!$depth)
		{
			$depth = 1;
		}

		$retdata['postipusers'] = $this->_searchIPUsage($ipaddress, 0, $depth);
		$retdata['regipusers'] = $this->_searchRegisterIP($ipaddress, 0, $depth);

		return $retdata;
	}

	/**
	 * Rewrite function construct_ip_register_table()
	 */
	protected function _searchRegisterIP($ipaddress, $prevuserid, $depth = 1)
	{
		$depth--;

		if (!$ipaddress)
		{
			return [];
		}

		$users = vB::getDbAssertor()->assertQuery('userSearchRegisterIP', [
			'ipaddress' => $ipaddress,
			'prevuserid' => $prevuserid,
		]);

		$retdata = [];
		foreach ($users as $user)
		{
			$retdata[$depth][] = $user;

			if ($depth > 0)
			{
				$retdata += $this->_searchRegisterIP($user['ipaddress'], $user['userid'], $depth);
			}
		}

		return $retdata;
	}

	/**
	 * Rewrite function construct_user_ip_table()
	 */
	protected function _searchUserIP($userid, $previpaddress, $depth = 2)
	{
		$depth--;

		$ips = vB::getDbAssertor()->assertQuery('user_searchpostip', [
			'ipaddress' => $previpaddress,
			'userid' => $userid,
		]);

		$retdata = [];
		foreach ($ips as $ip)
		{
			$retdata[$depth][] = $ip;

			if ($depth > 0)
			{
				$retdata += $this->_searchUserIP($userid, $ip['ipaddress'], $depth);
			}
		}

		return $retdata;
	}

	/**
	 * Rewrite function construct_ip_usage_table()
	 */
	protected function _searchIPUsage($ipaddress, $prevuserid, $depth = 1)
	{
		$depth--;

		if (!$ipaddress)
		{
			return [];
		}

		$users = vB::getDbAssertor()->assertQuery('userSearchIPUsage', [
			'ipaddress' => $ipaddress,
			'prevuserid' => $prevuserid,
		]);

		$retdata = [];
		foreach ($users as $user)
		{
			$retdata[$depth][] = $user;

			if ($depth > 0)
			{
				$retdata += $this->_searchIPUsage($user['ipaddress'], $user['userid'], $depth);
			}
		}

		return $retdata;
	}

	/**
	 * Return a report of referrers
	 *
	 * @deprecated This function has been moved to the ReferUser API and will be
	 * removed from the User API in a future version.
	 *
	 * @param array $startdate Start Date of the report. an array of 'year', 'month', 'day', 'hour' and 'minute'
	 * @param array $enddate End Date of the report. an array of 'year', 'month', 'day', 'hour' and 'minute'
	 * @return array Referrers information
	 */
	public function fetchReferrers($startdate, $enddate)
	{
		return vB_Api::instance('referuser')->fetchReferrers($startdate, $enddate);
	}


	/**
	 * Check whether a user is banned.
	 *
	 * @param integer $userid User ID.
	 * @return bool Whether the user is banned.
	 */
	public function isBanned($userid)
	{
		$userid = intval($userid);
		$currentuserid = vB::getCurrentSession()->get('userid');

		if (!$userid)
		{
			$userid = $currentuserid;
		}

		if (($userid != $currentuserid) AND !$this->hasAdminPermission('canadminusers'))
		{
			throw new vB_Exception_Api('no_permission');
		}

		return $this->library->isBanned($userid);
	}

	/**
	 * Check whether an email address is banned from the forums
	 *
	 * @param string $email The email address to check
	 * @return bool Whether the email is banned.
	 */
	public function isBannedEmail($email)
	{
		$vboptions = vB::getDatastore()->getValue('options');
 		$banemail = vB::getDatastore()->getValue('banemail');

		if ($vboptions['enablebanning'] AND $banemail !== null)
		{
			$bannedemails = preg_split('/\s+/', $banemail, - 1, PREG_SPLIT_NO_EMPTY);

			foreach ($bannedemails AS $bannedemail)
			{
				if (is_valid_email($bannedemail))
				{
					$regex = '^' . preg_quote($bannedemail, '#') . '$';
				}
				else
				{
					$regex = preg_quote($bannedemail, '#') . ($vboptions['aggressiveemailban'] ? '' : '$');
				}

				if (preg_match("#$regex#i", $email))
				{
					return true;
				}
			}
		}

		return false;
	}

	/**
	 * Gets the relationship of one user to another.
	 *
	 * The relationship level can be:
	 *
	 * 	3 - User 2 is a Friend of User 1 or is a Moderator
	 *  2 - User 2 is on User 1's contact list
	 *  1 - User 2 is a registered forum member
	 *  0 - User 2 is a guest or ignored user
	 *
	 * @param integer $user1 Id of user 1
	 * @param integer $user2 Id of user 2
	 * @return integer Relationship level
	 */
/*
 	//removed for VBV-16866.  Leaving commented in case we need to reference the logic later.
	public function fetchUserRelationship($user1, $user2)
	{
		static $privacy_cache = [];

		$user1 = intval($user1);
		$user2 = intval($user2);

		if (!$user2)
		{
			return 0;
		}

		if (isset($privacy_cache["$user1-$user2"]))
		{
			return $privacy_cache["$user1-$user2"];
		}

		if ($user1 == $user2 OR can_moderate(0, '', $user2)) {
			$privacy_cache["$user1-$user2"] = 3;
			return 3;
		}

		$contacts = vB::getDbAssertor()->assertQuery('user_fetchcontacts', [
			'user1' => $user1,
			'user2' => $user2,
		]);

		$return_value = 1;
		foreach ($contacts as $contact)
		{
			if ($contact['friend'] == 'yes')
			{
				$return_value = 3;
				break;
			}
			else if ($contact['type'] == 'ignore')
			{
				$return_value = 0;
				break;
			}
			else if ($contact['type'] == 'buddy')
			{
				// no break here, we neeed to make sure there is no other more definitive record
				$return_value = 2;
			}
		}

		$privacy_cache["$user1-$user2"] = $return_value;
		return $return_value;
	}
 */


	/**
	 *	Reset the current user's MFA secret
	 *
	 *	@param string $password -- the user's current password
	 *	@param string $mfa_authcode -- the authcode for the current secret, not required if the user
	 *		does not currently have an auth secret
	 */
	public function resetMfaSecret($password, $mfa_authcode=null)
	{
		/** @var vB_Library_Login */
		$loginlib = vB_Library::instance('login');
		$userInfo = vB::getCurrentSession()->fetch_userinfo();

		//the verifyAuth function from this class recreates the session, which we don't
		//want to do here.  Copy some logic from there.
		$userInfo['username'] = vB_String::convertStringToCurrentCharset($userInfo['username']);
		$userInfo['email'] = vB_String::convertStringToCurrentCharset($userInfo['email']);
		$auth = $loginlib->verifyPasswordFromInfo($userInfo, [['password' => $password, 'encoding' => 'text']]);
		if (!$auth['auth'])
		{
			throw new vB_Exception_Api('badpassword', vB5_Route::buildUrl('lostpw|fullurl'));
		}

		$db = vB::getDbAssertor();
		$mfa_user = $db->getRow('userloginmfa', ['userid' => $userInfo['userid']]);
		if (!empty($mfa_user['enabled']))
		{
			$result = $loginlib->verifyMfa($mfa_user['secret'], $mfa_authcode, 'enabled');
			if (!$result)
			{
				throw new vB_Exception_Api('badmfa');
			}
		}

		$secret = $loginlib->resetMfaSecret($userInfo['userid']);
		return ['secret' => $secret];
	}

	/**
	 *	Enable the user's current MFA record after verify password and authcode
	 *
	 *	@param string $password -- the user's current password
	 *	@param string $mfa_authcode -- the authcode for the current secret, not required if the user
	 *		does not currently have an auth secret
	 */
	public function enableMfa($password, $mfa_authcode)
	{
		/** @var vB_Library_Login */
		$loginlib = vB_Library::instance('login');
		$userInfo = vB::getCurrentSession()->fetch_userinfo();

		//the verifyAuth function from this class recreates the session, which we don't
		//want to do here.  Copy some logic from there.
		$userInfo['username'] = vB_String::convertStringToCurrentCharset($userInfo['username']);
		$userInfo['email'] = vB_String::convertStringToCurrentCharset($userInfo['email']);
		$auth = $loginlib->verifyPasswordFromInfo($userInfo, [['password' => $password, 'encoding' => 'text']]);
		if (!$auth['auth'])
		{
			throw new vB_Exception_Api('badpassword', vB5_Route::buildUrl('lostpw|fullurl'));
		}

		$db = vB::getDbAssertor();
		$mfa_user = $db->getRow('userloginmfa', ['userid' => $userInfo['userid']]);
		if (!$mfa_user)
		{
			throw new vB_Exception_Api('mfa_not_created');
		}

		$result = $loginlib->verifyMfa($mfa_user['secret'], $mfa_authcode, 'enabled');
		if (!$result)
		{
			throw new vB_Exception_Api('badmfa');
		}

		if (!$mfa_user['enabled'])
		{
			$loginlib->setMfaEnabled($userInfo['userid'], true);
		}

		return ['alreadyenabled' => (bool) $mfa_user['enabled']];
	}

	/**
	 *	Sets the users MFA record to enabled or disabled
	 *
	 *	Requires canadminusers permission
	 *	@param int $userid
	 *	@param bool $enabled
	 *	@return ['success' => true]
	 */
	public function setMfaEnabled($userid, $enabled)
	{
		$this->checkHasAdminPermission('canadminusers');
		$loginlib = vB_Library::instance('login');
		$loginlib->setMfaEnabled($userid, $enabled);
		return ['success' => true];
	}

	/**
	 *	Gets whether or not the user has an enabled MFA record
	 *
	 *	Requires canadminusers permission
	 *	@param int $userid
	 * 	@return array
	 * 		-- bool enabled
	 */
	public function isMfaEnabled($userid)
	{
		$this->checkHasAdminPermission('canadminusers');
		$db = vB::getDbAssertor();
		$mfa_user = $db->getRow('userloginmfa', ['userid' => $userid]);
		return ['enabled' => !empty($mfa_user['enabled'])];
	}

	/**
	 * Indicates if the current user needs to provide an MFA code for login.
	 *
	 * Note that it's not entirely pointless to request this for a logged
	 * in user as we can still require a login for a cpsession even after
	 * a user is logged in.
	 *
	 * @param string $logintype  -- either '', 'cplogin', 'modcplogin', 'mfareset'
	 * 	mfareset is a psuedo login where we reauthorize the login in order to
	 * 	change the mfa code.
	 * @return array
	 * 	-- bool enabled -- true if MFA auth is needed, false if not
	 */
	public function needMFA($logintype)
	{
		$config = vB::getConfig();

		//avoid repeating logic for common groupings
		$validlogintype = in_array($logintype, ['', 'cplogin', 'modcplogin', 'mfareset']);
		$cplogin = in_array($logintype, ['cplogin', 'modcplogin']);

		//we currently only require MFA for cplogins or the mfa reset
		if (empty($config['Security']['mfa_enabled']) OR $logintype == '' OR !$validlogintype)
		{
			return ['enabled' => false];
		}

		if ($cplogin)
		{
			//default mfa_force_cp to true
			if (!isset($config['Security']['mfa_force_cp']) OR $config['Security']['mfa_force_cp'])
			{
				return ['enabled' => true];
			}
		}

		//for now show the field for guests.  We *might* need it for the user and
		//if they are logged out we can't tell.  It might be better to set it up so that
		//we trap a "badmfa" error and show the UI only in that case.  But that's more
		//effort and can be done later.
		$currentUserId = vB::getCurrentSession()->get('userid');
		if (!$currentUserId)
		{
			//if we are requesting a cp login we need to allow entry
			//a mfareset login should always have a user and if somehow that's not the
			//case better to not show the MFA field.
			return ['enabled' => $cplogin];
		}

		$db = vB::getDbAssertor();
		$mfa_user = $db->getRow('userloginmfa', ['userid' => $currentUserId, vB_dB_Query::COLUMNS_KEY => ['enabled', 'secret']]);

		return ['enabled' => !empty($mfa_user['enabled'])];
	}


	/**
	 * Login a user
	 *
	 * @param string $username
	 * @param string $password
	 * @param string $md5password
	 * @param string $md5passwordutf
	 * @param string $logintype
	 *
	 * @return array
	 *	'userid' => int the id of the vbulletin user logged in
	 *	'password' => string "remeber me token".  A value that can be used to create a new
	 *		session without the user explicitly logging in
	 *	'lastvisit'
	 *	'lastactivity'
	 *	'sessionhash' => the session value used to authenticate the user on subsequent page loads
	 *	'cpsessionhash' => value needed to access the admincp.  Defines being logged in "as an admin"
	 *
	 *	@deprecated use login2
	 */
	public function login($username, $password = null, $md5password = null, $md5password_utf = null, $logintype = null)
	{
		$passwords = [
			'password' => $password,
			'md5password' => $md5password,
			'md5password_utf' => $md5password_utf,
		];

		return $this->login2($username, $passwords, [], $logintype);
	}


	/**
	 * Login a user
	 *
	 * @param string $username
	 * @param array $passwords -- contains at least one of
	 * 	* string password -- plain text password
	 * 	* string md5password -- md5 encoded password (legacy)
	 * 	* string md5password_utf -- md5 encoded password with utf replacements (legacy)
	 * @param array $extraAuthInfo -- information that might be required to authorize
	 * 	a user, such as numeric code for MFA
	 * @param string $logintype
	 *
	 * @return array
	 *	'userid' => int the id of the vbulletin user logged in
	 *	'password' => string "remeber me token".  A value that can be used to create a new
	 *		session without the user explicitly logging in
	 *	'lastvisit'
	 *	'lastactivity'
	 *	'sessionhash' => the session value used to authenticate the user on subsequent page loads
	 *	'cpsessionhash' => value needed to access the admincp.  Defines being logged in "as an admin"
	 */
	public function login2($username, $passwords, $extraAuthInfo, $logintype = '')
	{
		$escapedUsername = vB_String::htmlSpecialCharsUni($username);
		$this->verifyCredentialExistanceError($escapedUsername);
		// getUserInfoByCredential() will check the escaped value against email field. I'm not sure if that's
		// intentional or if THIS function even ever gets an email in place of the username field, but I've left
		// it as is to reduce regression risk. Should probably verify this sometime.
		$userInfo = vB_User::getUserInfoByCredential($escapedUsername);
		return $this->loginInternal($userInfo, $username, $passwords, $extraAuthInfo, $logintype);
	}

	/**
	 * Login a user for which we have the userid
	 *
	 * @param int $userid
	 * @param array $passwords -- contains at least one of
	 * 	* string password -- plain text password
	 * 	* string md5password -- md5 encoded password (legacy)
	 * 	* string md5password_utf -- md5 encoded password with utf replacements (legacy)
	 * @param array $extraAuthInfo -- information that might be required to authorize
	 * 	a user, such as numeric code for MFA
	 * @param string $logintype
	 *
	 * @return array
	 *	'userid' => int the id of the vbulletin user logged in
	 *	'password' => string "remeber me token".  A value that can be used to create a new
	 *		session without the user explicitly logging in
	 *	'lastvisit'
	 *	'lastactivity'
	 *	'sessionhash' => the session value used to authenticate the user on subsequent page loads
	 *	'cpsessionhash' => value needed to access the admincp.  Defines being logged in "as an admin"
	 */
	public function loginSpecificUser($userid, $passwords, $extraAuthInfo, $logintype = '')
	{
		$userid = (int) $userid;

		if (!$userid)
		{
			throw new vB_Exception_Api('invalid_userid');
		}

		$userInfo = vB_User::fetchUserInfo($userid);
		// The flow here is a bit different than login2 -- specifically, we do not allow hooks to try to determine a missing
		// $userInfo from a $userid that failed to map to an existing vB User. This is because vB-userids are an autoincrement
		// column without specific meaning, and IMO trying to tie that to some external data for a non-existent vB-userid
		// is a bad idea. What are we going to do if the hook magically finds a user to import? Forcibly set the userid??
		// In any case, just leaving the old flow in place until someone explains why we need to allow hook lookups for a
		// missing userid.
		if (!$userInfo)
		{
			// I don't think this being $userid actually works, but I'm leaving this how it was as to reduce regression risk.
			[$strikes, $limit] = vB_User::verifyStrikeStatus($userid);
			$this->verifyStrikeError($strikes);
			throw new vB_Exception_Api('invalid_userid');
		}

		$username = $userInfo['username'] ?? null;
		// loginInternal needs the raw username, not the post-escaped username stored in DB.
		if (!is_null($username))
		{
			$username = vB_String::unHtmlSpecialChars($username);
		}

		return $this->loginInternal($userInfo, $username, $passwords, $extraAuthInfo, $logintype);
	}

	private function loginInternal($userInfo, $rawusername, $passwords, $extraAuthInfo, $logintype)
	{
		$username = vB_String::htmlSpecialCharsUni($rawusername);
		$result = null;
		$loginstate = vB_LoginState::LOGIN_DEFAULT;
		vB::getHooks()->invoke('hookLoginInternal', [
			'loginstate' => &$loginstate,
			'result' => &$result,
			'userInfo' => &$userInfo,
			'username' => $rawusername,
			// currently only supporting the default plaintext password, as the hash inputs are deprecated.
			'password' => $passwords['password'] ?? '',
			'extraAuthInfo' => $extraAuthInfo,
			'logintype' => $logintype,
		]);

		if ($loginstate === vB_LoginState::LOGIN_HANDLED)
		{
			return $result;
		}

		// If we don't have a userInfo, and the hooks failed to find one for us (or hook indicated to us
		// that we must reject this login attempt), fall back out to default errors because we can't do anything here.
		if ($loginstate === vB_LoginState::LOGIN_REJECTED OR empty($userInfo))
		{
			[$strikes, $limit] = vB_User::verifyStrikeStatus($username);
			$this->verifyStrikeError($strikes);
			$this->processLoginError($username, $logintype, $strikes, $limit);
		}

		// Note, $loginstate may be vB_LoginState::LOGIN_USERINFO_REPLACED, which indicates that $userInfo may have
		// been replaced by a hook, and we should respect $userInfo NOT $username as the intended login user.
		// However, some code below still refer to $username to explicitly mean "the username input" in certain contexts
		// e.g. the strikes system, or logging, and that is intentional.

		[$strikes, $limit] = vB_User::verifyStrikeStatus($userInfo['username']);
		$this->verifyStrikeError($strikes);

		$passwordInfo = [];

		if (!empty($passwords['password']))
		{
			$passwordInfo[] = ['password' => $passwords['password'], 'encoding' => 'text'];
		}

		if (!empty($passwords['md5password']))
		{
			$passwordInfo[] = ['password' => $passwords['md5password'], 'encoding' => 'md5'];
		}

		if (!empty($passwords['md5password_utf']))
		{
			$passwordInfo[] = ['password' => $passwords['md5password_utf'], 'encoding' => 'md5'];
		}

		$auth = $this->verifyAuthentication($userInfo, $passwordInfo, $logintype);
		if (!$auth)
		{
			$this->processLoginError($username, $logintype, $strikes, $limit);
		}

		//this should either succeed or it should throw an error.
		$result = $this->verifyMfaAuthentication($userInfo['userid'], $logintype, $extraAuthInfo);
		if (!$result)
		{
			$this->processMfaError($username, $logintype, $strikes, $limit);
		}

		vB_User::execUnstrikeUser($username);
		$res = vB_User::processNewLogin($auth, $logintype);

		return $res;
	}



	/**
	 *	Log in via a third party provider.
	 *
	 * 	For now facebook is the only provider supported.  We do not support control panel logins via
	 * 	external providers.
	 *
	 *	@param string $provider.  Currently ignored, should be passed as 'facebook' since that is the only
	 *		provider recognized.
	 *
	 *	@param array $info.  The various information needed for the provider to log in.   One of
	 *		'token' or 'signedrequest' must be provided.  If both are then 'token' will be tried first.
	 *		* 'token' string the facebook access/oAuth token. (optional)
	 *		* 'signedrequest' string the facebook signedrequest.  this is a one use token that can be used
	 *			to retrieve the auth token. (optional)
	 *
	 *	@param int $userid.  If given we will only log in the requested userid. This prevents weirdness
	 *		where the front end has an FB token that does not belong to the user the front end thinks is
	 *		logged in (it's very difficult to figure out which user the token belongs to).
	 *
	 *	@return array.
	 *		'login' => array (should match the return from "login" function).  Only present if the login succeeded.
	 *			'userid' => int the id of the vbulletin user logged in
	 *			'password' => string "remeber me token" will always be blank for this method
	 *			'lastvisit'
	 *			'lastactivity'
	 *			'sessionhash' => the session value used to authenticate the user on subsequent page loads
	 *			'cpsessionhash' => will never be set for this function
	 */
	public function loginExternal($provider, $info, $userid = null)
	{
		$fblib = vB_Library::instance('facebook');
		$vbuserid = $fblib->createSessionForLogin($info);

		if ($userid AND $vbuserid != $userid)
		{
			//clean up the session we just created -- probably doesn't matter
			//but it's good to be tidy.
			$fblib->clearSession();
			throw new vB_Exception_Api('error_external_wrong_vb_user', $provider);
		}

		if (!$vbuserid)
		{
			//shouldn't be here, should throw an exception if vbuserid isn't valid
			//this error isn't 100% correct but somes up the basic problem and we
			//don't really know what precisely happened.
			throw new vB_Exception_Api('error_external_no_vb_user', $provider);
		}

		$session = vB::getRequest()->createSessionForUser($vbuserid);
		$sessionUserInfo = $session->fetch_userinfo();

		//don't try to set "rememberme" for FB logins (the remember me token is called 'password' for legacy reasons.
		$auth = [
			'userid'       => $vbuserid,
			'password'     => $provider,
			'lastvisit'    => $sessionUserInfo['lastvisit'],
			'lastactivity' => $sessionUserInfo['lastactivity']
		];

		// create new session -- this is probably 90% unnecesary both for us and for the
		// normal login, but that's how we used to do it and using it doesn't make things
		// any worse.
		$res = vB_User::processNewLogin($auth);
		return ['login' => $res];
	}

	/**
	 * Verify credential existance error
	 * @param $username
	 * @throws Exception
	 * @throws vB_Exception_Api
	 */
	private function verifyCredentialExistanceError($username)
	{
		if (!$username)
		{
			$vboptions = vB::getDatastore()->getValue('options');
			if ($vboptions['logintype'] == 0) // email
			{
				throw new vB_Exception_Api('badlogin_logintypeemail', vB5_Route::buildUrl('lostpw'));
			}
			else if ($vboptions['logintype'] == 1) // username
			{
				throw new vB_Exception_Api('badlogin_logintypeusername', vB5_Route::buildUrl('lostpw'));
			}
			else // 2 ==  both
			{
				throw new vB_Exception_Api('badlogin_logintypeboth', vB5_Route::buildUrl('lostpw'));
			}
		}
	}

	/**
	 * Verifies strike errors.
	 * @param $strikes
	 * @throws Exception
	 * @throws vB_Exception_Api
	 */
	private function verifyStrikeError($strikes)
	{
		if ($strikes === false)
		{
			throw new vB_Exception_Api('strikes', vB5_Route::buildUrl('lostpw'));
		}
	}


	/**
	 * Processes login error.
	 * @param $credential
	 * @param $logintype
	 * @param $strikes
	 * @throws Exception
	 * @throws vB_Exception_Api
	 */
	private function processLoginError($credential, $logintype, $strikes, $limit)
	{
		$vboptions = vB::getDatastore()->getValue('options');

		vB_User::execStrikeUser($credential);
		if ($logintype === 'cplogin')
		{
			// log this error if attempting to access the control panel
			require_once(DIR . '/includes/functions_log_error.php');
			log_vbulletin_error($credential, 'security', ['strikes' => $strikes]);
		}

		$suffix = '';
		if ($vboptions['logintype'] == 0) // email
		{
			$suffix = 'logintypeemail';
		}
		else if ($vboptions['logintype'] == 1) // username
		{
			$suffix = 'logintypeusername';
		}
		else // 2 ==  both
		{
			$suffix = 'logintypeboth';
		}

		if ($vboptions['usestrikesystem'])
		{
			throw new vB_Exception_Api('badlogin_strikes_' . $suffix, [vB5_Route::buildUrl('lostpw|fullurl'), $strikes + 1, $limit]);
		}
		else
		{
			throw new vB_Exception_Api('badlogin_' . $suffix, vB5_Route::buildUrl('lostpw|fullurl'));
		}
	}


	/**
	 * Processes login error.
	 * @param $credential
	 * @param $logintype
	 * @param $strikes
	 * @throws Exception
	 * @throws vB_Exception_Api
	 */
	private function processMfaError($credential, $logintype, $strikes, $limit)
	{
		$vboptions = vB::getDatastore()->getValue('options');

		vB_User::execStrikeUser($credential);
		if ($logintype === 'cplogin')
		{
			// log this error if attempting to access the control panel
			require_once(DIR . '/includes/functions_log_error.php');
			log_vbulletin_error($credential, 'security', ['strikes' => $strikes]);
		}

		if ($vboptions['usestrikesystem'])
		{
			throw new vB_Exception_Api('badmfa_strikes', [$strikes + 1, $limit]);
		}
		else
		{
			throw new vB_Exception_Api('badmfa');
		}
	}


	/**
	 * Port of function verify_authentication()
	 *
	 * @param  $userInfo Recieves an array with username and email
	 * @param  $passwords @see vB_Library_Login::verifyPasswordFromInfo $passwords parameter
	 * @return array|bool false if auth failed. User info array if auth successfully.
	 * 	userid -- id of the user newly logged in
	 *	password -- remember me token
	 *	lastvisit -- the newly logged in user's last visit,
	 *	lastactivity -- the newly logged in user's last activity
	 */
	private function verifyAuthentication($userInfo, $passwords, $logintype = '')
	{
		$userInfo['username'] = vB_String::convertStringToCurrentCharset($userInfo['username']);
		$userInfo['email'] = vB_String::convertStringToCurrentCharset($userInfo['email']);

		/** @var vB_Library_Login */
		$loginlib = vB_Library::instance('login');
		$auth = $loginlib->verifyPasswordFromInfo($userInfo, $passwords);
		if (!$auth['auth'])
		{
			return false;
		}

		// We check the logintype here and disallow non-admin/mods from continuing so that
		// we do NOT create/switch the user-session.
		if ($userInfo['userid'] > 0 AND ($logintype == 'cplogin' OR $logintype == 'modcplogin'))
		{
			$usercontext = vB::getUserContext($userInfo['userid']);
			$allowed = ($usercontext->isAdministrator() OR $usercontext->isModerator());
			if (!$allowed)
			{
				throw new vB_Exception_Api('badlogin_notadminmod');
			}
		}

		$return_value = [
			'userid'      => $userInfo['userid'],
			'password'    => $auth['remembermetoken'],
		];

		return $return_value;
	}

	/**
	 *	Verify that the MFA information passes.
	 *
	 *	Either throws an exception or returns true.  Is always callable,
	 *	will check to ensure that the MFA check is require before
	 *	doing the validation (validation is considered passed if the
	 *	check is not required)
	 *
	 *	@param string $logintype -- either cplogin, modcplogin, or blank (regular login)
	 *	@param array $mfaAuth -- auth info for MFA with fields:
	 *		*
	 *		*
	 *	@return bool -- if the auth succeeded
	 */
	private function verifyMfaAuthentication($userid, $logintype, $mfaAuth)
	{
		$config = vB::getConfig();

		if (empty($config['Security']))
		{
			return true;
		}

		$mfaConfig = $config['Security'];

		$cpsession = ($logintype == 'cplogin' OR $logintype == 'modcplogin');

		//for the moment we only check the MFA for cp logins
		if (empty($mfaConfig['mfa_enabled']) OR !$cpsession)
		{
			return true;
		}

		$db = vB::getDbAssertor();
		$mfa_user = $db->getRow('userloginmfa', ['userid' => $userid]);

		//if we don't have a record or the record is not enabled.
		if (!$mfa_user OR !$mfa_user['enabled'])
		{
			//default mfa_force_cp to true
			$forced = (!isset($mfaConfig['mfa_force_cp']) OR $mfaConfig['mfa_force_cp']);
			return !$forced;
		}

		$loginlib = vB_Library::instance('login');
		$result = $loginlib->verifyMfa($mfa_user['secret'], $mfaAuth['mfa_authcode'], 'enabled');
		if (!$result)
		{
			return false;
		}

		return true;
	}

	/**
	 * Logout user
	 *
	 * @param $logouthash Logout hash
	 * @return bool
	 */
	public function logout($logouthash = null)
	{
		// process facebook logout first if applicable
		vB_Library::instance('facebook')->clearSession();
		$userinfo = vB::getCurrentSession()->fetch_userinfo();

		//Need to find a better way to deal with this than magic constants
		if (!(defined('VB_API') AND VB_API === true) OR (defined('VB_API_VERSION_CURRENT') AND VB_API_VERSION_CURRENT >= VB5_API_VERSION_START))
		{
			if ($userinfo['userid'] != 0 AND !vB_User::verifySecurityToken($logouthash, $userinfo['securitytoken_raw']))
			{
				throw new vB_Exception_Api('logout_error', [$userinfo['securitytoken']]);
			}
		}

		return vB_User::processLogout();
	}

	/**
	 * Logout user from all devices.
	 *
	 * @param string|null $logouthash
	 *
	 * @return array{success:bool, sessionhash:string, apiaccesstoken:string}
	 *	sessionhash -- hash identifying the new session, if logging out the current user.
	 *	apiaccesstoken -- the current api access token, if logging out the current user and this is a request through MAPI
	 */
	public function logoutAllDevices(?string $logouthash = null) : array
	{
		$userinfo = vB::getCurrentSession()->fetch_userinfo();
		if ($userinfo['userid'] != 0 AND !vB_User::verifySecurityToken($logouthash, $userinfo['securitytoken_raw']))
		{
			throw new vB_Exception_Api('logout_error', [$userinfo['securitytoken']]);
		}

		/** @var vB_Library_User */
		$userLib = vB_Library::instance('user');
		$logoutResult = $userLib->logoutAllDevices($userinfo['userid']);

		// Do we want to send out an email saying something like "You have been logged out... if it wasn't you reset your
		// password?"

		return $logoutResult;
	}

	/**
	 * Email user a password reset email
	 *
	 * @param integer $userid User ID
	 * @param string $email Email address
	 * @param array $hvinput Human Verify input data. @see vB_Api_Hv::verifyToken()
	 * @return success array
	 */
	public function emailPassword($userid, $email, $hvinput = [])
	{
		vB_Api::instanceInternal('hv')->verifyToken($hvinput, 'lostpw');
		vB_Library::instance('user')->sendPasswordEmail($userid, $email);
		//if we got here, we succeeded
		return ['success' => true];
	}

	/**
	 * Set a new password for a user. Used by "forgot password" function.
	 *
	 * @param	integer  $userid
	 * @param	string   $activationid  Activation ID
	 * @param	string   $newpassword
	 *
	 * @return string[]  keys 'password_reset' & 'setnewpw_message', values
	 */
	public function setNewPassword($userid, $activationid, $newpassword)
	{
		$currentUserId = vB::getCurrentSession()->get('userid');
		if (!empty($currentUserId))
		{
			$userinfo = $this->fetchUserinfo($currentUserId);
			throw new vB_Exception_Api('changing_password_but_currently_logged_in_msg', [$userinfo['username'], $userinfo['logouthash']]);
		}

		$useractivation = [];
		$userinfo = vB_User::fetchUserinfo($userid);
		$vboptions = vB::getDatastore()->getValue('options');

		if (isset($userinfo['userid']))
		{
			$useractivation = vB::getDbAssertor()->getRow('user_useractivation', ['userid' => $userinfo['userid']]);
		}

		if (empty($useractivation))
		{
			throw new vB_Exception_Api('resetbadid', vB5_Route::buildUrl('lostpw|fullurl'));
		}

		// Need to brake brute force attempts.
		$this->processPasswordResetLockout($userinfo, $useractivation, $activationid);

 		// Is it older than 24 hours ?
 		if ($useractivation['dateline'] < (vB::getRequest()->getTimeNow() - 86400))
		{
			// Note, we're intentionally NOT resetting reset_attempts here, meaning if they happened to
			// fail 9 times yesterday, and fail again today with a new activationid, they're locked out.
			// This also means a bot or user can't just re-request a new activationid to bypass the lockout.
			// However, by throwing an exception here, it means that spamming an expired activation record
			// does not increment reset_attempts.

			//fullurl shouldn't be necesary here, but it looks like the lostpw route doesn't quite handle things without it
			throw new vB_Exception_Api('resetexpired', vB5_Route::buildUrl('lostpw|fullurl'));
		}

 		// Wrong act id ?
 		if ($useractivation['activationid'] != $activationid)
		{
			//fullurl shouldn't be necesary here, but it looks like the lostpw route doesn't quite handle things without it
			throw new vB_Exception_Api('resetbadid', vB5_Route::buildUrl('lostpw|fullurl'));
		}

		/*
			If they got to this point, they are either very lucky, and/or have the correct userid & activationid combination, which
			implies that they have access to the email associated with this user account.

			They have free reign of this account.
		 */

		$userContext = vB::getUserContext($userid);
		$expires = $userContext->getUsergroupLimit('passwordexpires');
		// bypass if expiry = 0. Per password history desc, password history has no effect is expires == 0.
		$overridePasswordHistory = ($expires === 0);
		/** @var vB_Library_Login */
		$loginLib = vB_Library::instance('login');
		$loginLib->setPassword(
			$userid,
			$newpassword,
			['passwordhistorylength' => $userContext->getUsergroupLimit('passwordhistory')],
			['passwordhistory' => $overridePasswordHistory]
		);

		//the secret really isn't related to the password, but we want to change it
		//periodically and for now "every time the user changes their password"
		//works (we previously used the password salt so that's when it got changed
		//prior to the refactor).
		$userdata = new vB_DataManager_User(vB_DataManager_Constants::ERRTYPE_ARRAY_UNPROCESSED);
		$userdata->set_existing($userinfo);
		/** @var vB_Library_User */
		$userLib = vB_Library::instance('user');
		$secret = $userLib->generateUserSecret();
		$userdata->set('secret', $secret);

		if ($userdata->has_errors(false))
		{
			throw $userdata->get_exception();
		}
		$userdata->save();

		// If we got here without loginLIB throwing exceptions, password has been reset.

		// Delete old activation id
		vB::getDbAssertor()->assertQuery('user_deleteactivationid', ['userid' => $userid]);

		$string = vB::getString();
		$displayname_safe = $string->htmlspecialchars($userinfo['displayname']);
		$bbtitle_escaped = $string->htmlspecialchars($vboptions['bbtitle']);

		$maildata = vB_Api::instanceInternal('phrase')->fetchEmailPhrases(
			'setnewpw',
			[
				$displayname_safe,
				$vboptions['frontendurl'],
				$bbtitle_escaped,
			],
			[$vboptions['bbtitle']],
			$userinfo['languageid']
		);
		// Account security email, skip vbmailWithUnsubscribe() & isUserOptedOutOfEmail()
		vB_Mail::vbmail2($userinfo['email'], $maildata['subject'], $maildata['message'], true);

		/*
			We could potentially pass in $userinfo['languageid'] to the fetch() call below,
			but if the current page is on a different encoding than the requested language,
			this might have weird character corruption issues.
		 */
		$response = vB_Api::instanceInternal('phrase')->fetch(['password_reset', 'setnewpw_message']);

		return $response;
	}

	protected function processPasswordResetLockout($userinfo, $useractivation, $activationid)
	{
		/*
			If the particular activation record has had more than $attemptsLimit attempts, throw an exception and
			prevent it from being used for $lockDurationMinutes minutes, even if they have the correct activationid.

			When the lock is placed, the counter resets. This is the only way the counter resets, even if the 24
			expiry passes. This is intentional so that someone cannot bypass the lockout by just requesting a new
			activationid, and because we don't have a cron to check the expiry, but rather have a hard block on it
			@ the caller, trying to clear the counter after expiry is an added complexity that IMO is just not needed.

			This could allow a quick enough bot to perma-lock someone from resetting a password via this route,
			but they might as well be DDoSing at that point.
		 */

		// data validation. Meant for devs/unit testing really, if these values aren't present than some code changed
		// unintentionally.
		if (!isset($useractivation['reset_attempts']) OR !isset($useractivation['reset_locked_since']) OR !isset($useractivation['activationid']))
		{
			throw new vB_Exception_Api('incorrect_data');
		}

		$attemptsLimit = vB_Library_User::PASSWORD_RESET_ATTEMPTS;
		$lockDurationMinutes = vB_Library_User::PASSWORD_RESET_LOCK_MINUTES;
		$lostPWLink = vB5_Route::buildUrl('lostpw|fullurl');
		$exceptionArgs = [$lockDurationMinutes, $lostPWLink];

		/*
			If the lock is in place (checkPasswordResetLock()) or
			the placement of the lock invalidated the activationid,
			throw an exception.
		 */
		if (!empty($useractivation['reset_locked_since']))
		{
			// They need to generate a new id.
			throw new vB_Exception_Api('reset_password_lockout', $exceptionArgs);
		}
		// Currently this call is not needed as if checkPasswordResetLock() would have thrown an exception,
		// above will always throw an exception before we get here.
		// However I'm leaving it here in case of any refactor changes something about how the lock is checked.
		$this->library->checkPasswordResetLock($useractivation);

		/*
			If they have the right id, do not trigger a lockout.
			Note that the correct id does NOT allow them to bypass the lockout, see above.
		 */
 		if ($useractivation['activationid'] == $activationid)
		{
			// They pass. Caller will remove the useractivation record, so we don't have to
			// reset anything here.

			return true;
		}

		/*
			Increment the reset_attempts counter.
			Check it against the limit & do lockout if necessary
		*/
		$doLockout = (++$useractivation['reset_attempts'] >= $attemptsLimit);
		if ($doLockout)
		{
			$timeNow = vB::getRequest()->getTimeNow();
			//$useractivation['reset_attempts'] = 0;
			$useractivation['reset_locked_since'] = $timeNow;
		}

		vB::getDbAssertor()->update(
			'useractivation',
			[
				'reset_attempts'     => $useractivation['reset_attempts'],
				'reset_locked_since' => $useractivation['reset_locked_since']
			],	// values
			['useractivationid' => $useractivation['useractivationid']] // condition
		);

		if ($doLockout)
		{
			/*
				Warn the user when the lockout is started.
			 */
			$string = vB::getString();
			$displayname_safe = $string->htmlspecialchars($userinfo['displayname']);
			$vboptions = vB::getDatastore()->getValue('options');
			$bbtitle_escaped = $string->htmlspecialchars($vboptions['bbtitle']);
			$maildata = vB_Api::instanceInternal('phrase')->fetchEmailPhrases(
				'reset_password_lockout',
				[
					$displayname_safe, //1
					$attemptsLimit, 		//2
					$lockDurationMinutes, 	//3
					$lostPWLink,	//4
					vB5_Route::buildUrl('settings|fullurl', ['tab' => 'account']),	//5
					$bbtitle_escaped,	//6
				],
				[$vboptions['bbtitle']],
				$userinfo['languageid']
			);
			// Account security email, skip vbmailWithUnsubscribe() & isUserOptedOutOfEmail()
			vB_Mail::vbmail2($userinfo['email'], $maildata['subject'], $maildata['message'], true);

			throw new vB_Exception_Api('reset_password_lockout', $exceptionArgs);
		}
	}

	/**
	 * This checks whether a user needs COPPA approval based on birthdate. Responds to Ajax call
	 *
	 * @param array $dateInfo -- array of month/day/year.
	 * @return int
	 *   0 - no COPPA needed,
	 *   1 - Approve but require adult validation,
	 *   2 - Deny
	 */
	public function needsCoppa($dateInfo)
	{
		return $this->library->needsCoppa($dateInfo);
	}


	/**
	 * This checks whether the site uses COPPA review
	 *
	 *	@return	bool
	 */
	public function useCoppa()
	{
		$options = vB::getDatastore()->getValue('options');
		return (bool) $options['usecoppa'];
	}

	private function checkDisplaynameInternal($newuser, $user, $olduser, $adminoverride, $vboptions)
	{
		if (!isset($user['displayname']))
		{
			// If displayname is not set, the user LIB will handle it appropriately (usually just copying
			// the username). We have nothing specific to check here, assuming that the username checks will
			// be sufficient for copying over to the displayname later.
			return;
		}

		$displayname = $user['displayname'];
		$oldDisplayname = $olduser['displayname'] ?? false;
		$displaynameChanged = ($newuser OR $displayname !== $oldDisplayname);

		// check length only if it's a new user or if the username changed
		if ($displaynameChanged)
		{
			// displayname history. Putting this at top instead of with the other adminoverridables
			// so that if they're not eligible to change displaynames, we don't bug them to fix their
			// names first only to block them on the correction.
			if (!$adminoverride AND !$newuser AND !empty($vboptions['displaynamechangefrequency']))
			{
				// always allow resetting back to username
				$htmlUsername = isset($user['username']) ? vB_String::htmlSpecialCharsUni($user['username']) : $olduser['username'];
				$resettingToUsername = vB_String::htmlSpecialCharsUni($displayname) == $htmlUsername;
				if (!$resettingToUsername)
				{
					// vboptions['displaynamechangefrequency']
					// This is a per day option
					$timenow = vB::getRequest()->getTimeNow();
					$cutoff = $timenow - 86400;
					$assertor = vB::getDbAssertor();
					/*
						'userid'      => $this->existing['userid'],
						'adminid'     => $this->userinfo['userid'],
						'fieldname'   => $fieldname,
						'oldvalue'    => $this->existing[$fieldname],
						'newvalue'    => $this->user[$fieldname],
						'change_time' => $request->getTimeNow(),
						'change_uniq' => $uniqueid,
						'ipaddress'   => $request->getIpAddress(),
					*/
					// There's a limitation in the current userchangelog scheme where if an admin changes their own data,
					// there's no way to tell whether it was via adminCP (and thus adminoverride) or we should treat as
					// a "regular" change. This causes an edge case where if a user changes their own displayname to the limit
					// via adminCP, then tries to change it on their own profile, they get blocked & must edit it via adminCP
					// again.
					// Only check for user-self changes.
					$check = $assertor->getRows('getChangelogData', [
						'userid' => $olduser['userid'],
						'fieldname' => 'displayname',
						'time_start' => $cutoff,
						vB_dB_Query::PARAM_LIMIT => $vboptions['displaynamechangefrequency'],
						vB_dB_Query::PARAM_LIMITPAGE => 0,
						'self_only' => true,
					]);

					if (count($check) >= $vboptions['displaynamechangefrequency'])
					{
						// the query does ORDER BY userchangelog.change_time DESC, and we're limiting it to the option,
						// so the last entry should be the will expire soonest.
						// Currently decided against this because this requires at least two separate phrases for "hour"
						// "hours" (possibly more for minutes) which trickles down to increased test complexity, more
						// localization efforts, etc for very little gain, but may add this back if deemed critical to
						// user experience.
						//$row = end($check);
						//$hoursLeft = ceil($timenow - $row['change_time'] / 3600);
						//throw new vB_Exception_Api('displayname_change_too_frequent', [$hoursLeft]);

						throw new vB_Exception_Api('displayname_change_too_frequent');
					}
				}

			}



			// We shouldn't use vB_String::vbStrlen() as it will count &xxx; as one character.
			$length = iconv_strlen($displayname, vB_String::getCharset());
			if ($length == 0)
			{
				throw new vB_Exception_Api('fieldmissing_displayname');
			}
			else if (preg_match('/(?<!&#[0-9]{3}|&#[0-9]{4}|&#[0-9]{5});/', $displayname))
			{
				throw new vB_Exception_Api('displayname_contains_semi_colons');
			}
			// TODO:
			// also add max db column length check?

			if (!$adminoverride)
			{
				// We may want to bypass these when resetting back to a username. For now, leaving them out, as if a username is
				// "grandfathered in" through current username restriction, keeping that may warrant admin review, especially
				// for censored words.
				if ($length < $vboptions['minuserlength'])
				{
					// name too short
					throw new vB_Exception_Api('displaynametooshort', $vboptions['minuserlength']);
				}
				else if ($length > $vboptions['maxuserlength'])
				{
					// name too long
					throw new vB_Exception_Api('displaynametoolong', $vboptions['maxuserlength']);
				}
				else if ($displayname != fetch_censored_text($displayname))
				{
					// name contains censored words
					throw new vB_Exception_Api('censorfield');
				}


				if (!empty($vboptions['usernameregex']))
				{
					// check for regex compliance
					$regex = '#' . str_replace('#', '\#', $vboptions['usernameregex']) . '#siU';
					if (!preg_match($regex, $displayname))
					{
						throw new vB_Exception_Api('displaynamenotallowed', [vB_String::htmlSpecialCharsUni($displayname)]);
					}
				}

				// Skipping usernamereusedelay check for displayname

				if (!empty($vboptions['illegalusernames']))
				{
					// check for illegal username
					$usernames = preg_split('/[ \r\n\t]+/', $vboptions['illegalusernames'], -1, PREG_SPLIT_NO_EMPTY);
					$displaynameLower = strtolower($displayname);
					foreach ($usernames AS $val)
					{
						if (strpos($displaynameLower, strtolower($val)) !== false)
						{
							throw new vB_Exception_Api('displaynamenotallowed', [vB_String::htmlSpecialCharsUni($displayname)]);
						}
					}
				}

			}// end adminoverride-able
		}

	}

	private function checkUsernameInternal($newuser, $user, $olduser, $adminoverride, $vboptions)
	{
		if (!isset($user['username']))
		{
			// Existing users can skip changing their username.
			if (!$newuser)
			{
				return;
			}

			// Previously, check_required() would throw an unexpected_error if username was
			// required but never set. Let's mimic that somewhat.
			throw new vB_Exception_Api('unexpected_error');
		}

		$username_raw = $this->library->precleanUsernameRaw($user['username']);
		$username = $this->library->precleanUsername($username_raw);
		/*
			username_raw seems be the version of the username with numeric html entities
			(like &#198;).
			It seems like depending on the charset used and other forum specific state,
			we may have a preexisting username with the numeric entity (though canonical
			form that's saved nowadays seems to be utf-8 decoded versions). Since both
			versions would "display" the same, we treat them as the same username, and
			check for both in the database for duplicate user checks.
		 */
		$htmlUsername = vB_String::htmlSpecialCharsUni($username);
		$htmlUsernameRaw = vB_String::htmlSpecialCharsUni($username_raw);

		$oldUsername = $olduser['username'] ?? false;
		/*
			The old user DM code was extremely inconsistent about which username format it
			compared against an existing user's old username to detect "username changed".

			From what I can tell, $htmlUsername is what is inserted into the DB at the end
			of the day, but sometimes it compared against $htmlUsernameRaw, sometimes against
			$username, and not sure what else.

			I initially tried to preserve the old checks in each case, but that was just
			driving me crazy so I'm going to just set the "changed" check to
				$oldUsername !== $htmlUsername
			Note that the user DM still contains some "critical" checks & processes, like
			disallowing semicolons, html-escaping, and "remove trailing HTML entities",
			untouched by the refactor.
		 */
		$usernameChanged = ($newuser OR $oldUsername !== $htmlUsername);

		// Regular users are not allowed to change their usernames. New users can obviously set
		// their new usernames.
		if (!$adminoverride AND !$newuser AND $oldUsername !== $htmlUsername)
		{
				throw new vB_Exception_Api('no_permission');
		}


		// check length only if it's a new user or if the username changed
		if ($usernameChanged)
		{
			// We shouldn't use vB_String::vbStrlen() as it will count &xxx; as one character.
			$length = iconv_strlen($username, vB_String::getCharset());
			if ($length == 0)
			{
				// check for empty string
				throw new vB_Exception_Api('fieldmissing_username');
			}
			else if (preg_match('/(?<!&#[0-9]{3}|&#[0-9]{4}|&#[0-9]{5});/', $username))
			{
				// name contains semicolons
				throw new vB_Exception_Api('username_contains_semi_colons');
			}

			if (!$adminoverride)
			{
				if ($length < $vboptions['minuserlength'])
				{
					// name too short
					throw new vB_Exception_Api('usernametooshort', $vboptions['minuserlength']);
				}
				else if ($length > $vboptions['maxuserlength'])
				{
					// name too long
					throw new vB_Exception_Api('usernametoolong', $vboptions['maxuserlength']);
				}
				else if ($username != fetch_censored_text($username))
				{
					// name contains censored words
					throw new vB_Exception_Api('censorfield');
				}


				if (!empty($vboptions['usernameregex']))
				{
					// check for regex compliance
					$regex = '#' . str_replace('#', '\#', $vboptions['usernameregex']) . '#siU';
					if (!preg_match($regex, $username))
					{
						throw new vB_Exception_Api('usernametaken', [$htmlUsername,	vB5_Route::buildUrl('lostpw|fullurl')]);
					}
				}

				if (!$adminoverride AND $vboptions['usernamereusedelay'] > 0)
				{
					require_once(DIR . '/includes/class_userchangelog.php');
					$userchangelog = new vB_UserChangeLog();
					$userchangelog->set_just_count(true);
					$cutoff = vB::getRequest()->getTimeNow() - $vboptions['usernamereusedelay'] * 86400;
					$check = $userchangelog->sql_select_by_username($htmlUsername, $cutoff);
					if ($check)
					{
						throw new vB_Exception_Api('usernametaken', [$htmlUsername,	vB5_Route::buildUrl('lostpw|fullurl')]);
					}
				}

				if (!empty($vboptions['illegalusernames']))
				{
					// check for illegal username
					$usernames = preg_split('/[ \r\n\t]+/', $vboptions['illegalusernames'], -1, PREG_SPLIT_NO_EMPTY);
					foreach ($usernames AS $val)
					{
						if (strpos(strtolower($username), strtolower($val)) !== false)
						{
							throw new vB_Exception_Api('usernametaken', [$htmlUsername,	vB5_Route::buildUrl('lostpw|fullurl')]);
						}
					}
				}

			}// end adminoverride-able

			// Check duplicate usernames for the checkUsername() api method.
			$this->library->checkUsernameLibraryInternal($newuser, $user, $olduser);
		}
	}

	/**
	 * This checks whether the a username is available and valid
	 *
	 * @param username $
	 * @return	bool
	 */
	public function checkUsername($candidate)
	{
		if (empty($candidate))
		{
			throw new vB_Exception_Api('invalid_username_specified');
		}

		$newuser = true;
		$user = [
			'username' => $candidate,
		];
		$olduser = [];
		$adminoverride = false;
		$vboptions = vB::getDatastore()->getValue('options');
		$this->checkUsernameInternal($newuser, $user, $olduser, $adminoverride, $vboptions);

		return true;
	}

	public function currentUserHasAdminPermission($adminPermission)
	{
		$session = vB::getCurrentSession();
		$userInfo = $session->fetch_userinfo();
		$currentUserId = (int) $userInfo['userid'];

		//if we have a guest user for this check, it's likely that the
		//session timed out so let's return an inlinemodauth_required message.
		//if we are logged in we can check if the user is allowed to
		//have an auth session.
		if (!$session->validateCpsession() OR $currentUserId < 1)
		{
			throw new vB_Exception_Api('inlinemodauth_required');
		}

		return vB::getUserContext()->hasAdminPermission($adminPermission);
	}

	/**
	 * Returns suggested usernames for the username autocomplete popup menu.
	 *
	 * @param  string Text to search for, must be at least 3 chars long.
	 * @param  string Sort field, default 'username'
	 * @param  string Sort order, default 'ASC'
	 * @param  int    [Not used, always starts from 0] Offset to start searching from, default 0
	 * @param  int    Max number of suggestions to return, default 15, max 15
	 *
	 * @return array  Array containing one element "suggestions" which is an array.
	 *                Each element is an array containing:
	 *                    'title' => username without html entities
	 *                    'value' => username
	 *                    'id' => userid
	 */
	public function getAutocomplete($searchStr, $orderby = 'username', $direction = 'ASC', $limitstart = 0, $limitnumber = 15)
	{
		$cleaner = vB::getCleaner();

		$searchStr   = $cleaner->clean($searchStr,   vB_Cleaner::TYPE_STR);
		$orderby     = $cleaner->clean($orderby,     vB_Cleaner::TYPE_NOHTML);
		$direction   = $cleaner->clean($direction,   vB_Cleaner::TYPE_NOHTML);
		$limitstart  = $cleaner->clean($limitstart,  vB_Cleaner::TYPE_UINT);
		$limitnumber = $cleaner->clean($limitnumber, vB_Cleaner::TYPE_UINT);

		if (strlen($searchStr) < 3)
		{
			return ['suggestions' => []];
		}

		if ($limitnumber > 15)
		{
			$limitnumber = 15;
		}

		// always force $limitstart to be 0
		// I'm doing this because previously limitstart wasn't being respected
		// and I don't want to introduce a new problem by enabling it now.
		// if we actually need to use it, we just need to remove this line.
		$limitstart = 0;

		$direction = (strtoupper($direction) === 'DESC') ? 'DESC' : 'ASC';

		$query = vB::getDbAssertor()->assertQuery(
			'user',
			[
				vB_dB_Query::TYPE_KEY => vB_dB_Query::QUERY_SELECT,
				vB_dB_Query::CONDITIONS_KEY => [
					[
						'field' => 'username',
						// usernames are escaped, while the incoming lookup is not. Escape the lookup to get a better match
						// when user does not manually escape the entities (which didn't work properly at save-time anyways)
						'value' => vB_String::htmlSpecialCharsUni($searchStr),
						'operator' => vB_dB_Query::OPERATOR_BEGINS
					]
				],
				vB_dB_Query::FIELDS_KEY => ['username', 'userid', 'displayname',],
				vB_dB_Query::PARAM_LIMITSTART => $limitstart,
				vB_dB_Query::PARAM_LIMIT => $limitnumber,

			],
			[
				'field' => $orderby,
				'direction' => $direction,
			]
		);

		$matching_users = [];

		if ($query AND $query->valid())
		{
			foreach ($query AS $user)
			{
				// vBulletin_Autocomplete() expects unescaped data for the title & value... otherwise any usernames with special chars end up getting double escaped, which
				// causes various problems content save (e.g. PM recipients lookup) & looks bad at entry time.
				// Furthermore, the JS actually only uses the title for setting up the inputs, NOT the value. Trying to unravel that is not a good use of time at the moment,
				// so for now we'll go all in on the unescaped usernames. This is more or less what was happening before, but without all of the consumers (PM recipients,
				// usermentions, ignorelists) being consistently informed of this (including this function itself which failed to match search names unless the user manually
				// escaped them, which is bad UX).
				// The "value" is currently used by ckeditor.js's usermention handling code... which suffers from the same inconsistency issues when it comes to usernames
				// with html entities. As such, also unescaping the value here to stay consistent for the usermentions.

				$rawUsername = vB_String::unHtmlSpecialChars($user['username']);
				// title will be treated as HTML when 'hint' is used by our autocomplete extension
				$matching_users[$user['userid']] = [
					'title' => $rawUsername,
					'htmllabel' => $this->getAutosuggestHtmlLabel($user),
					'value' => $rawUsername,
					'id'    => $user['userid'],
				];
			}
		}


		$query = vB::getDbAssertor()->assertQuery(
			'user',
			[
				vB_dB_Query::TYPE_KEY => vB_dB_Query::QUERY_SELECT,
				vB_dB_Query::CONDITIONS_KEY => [
					[
						'field' => 'displayname',
						'value' => "$searchStr",
						'operator' => vB_dB_Query::OPERATOR_BEGINS
					]
				],
				vB_dB_Query::FIELDS_KEY => ['username', 'userid', 'displayname',],
				vB_dB_Query::PARAM_LIMITSTART => $limitstart,
				vB_dB_Query::PARAM_LIMIT => $limitnumber,

			],
			[
				'field' => $orderby,
				'direction' => $direction,
			]
		);

		if ($query AND $query->valid())
		{
			foreach ($query AS $user)
			{
				$rawUsername = vB_String::unHtmlSpecialChars($user['username']);
				$matching_users[$user['userid']] = [
					'title' => $rawUsername,
					'htmllabel' => $this->getAutosuggestHtmlLabel($user),
					'value' => $rawUsername,
					'id'    => $user['userid'],
				];
			}
		}

		// sort by htmllabel (displayname first) ascending
		uasort($matching_users, function($a, $b)
		{
			return strcasecmp($a['htmllabel'], $b['htmllabel']);
		});

		// Guarantee the array that autocomplete js expects
		$matching_users = array_values($matching_users);

		return ['suggestions' => $matching_users];
	}

	private function getAutosuggestHtmlLabel($user)
	{
		if (vB_User::doShowDisplaynameAndUsername($user))
		{
			return vB_String::htmlSpecialCharsUni($user['displayname']) . " ({$user['username']})";
		}
		else
		{
			return $user['username'];
		}
	}

	/**
	 * This sets a user to use one of the default avatars.
	 *
	 * @param int $avatarid
	 *
	 * @result	array	the new avatar info array of custom => bool, 0=> avatarurl (string)
	 */
	public function setDefaultAvatar($avatarid)
	{
		// you can only do this for yourself.
		$userContext = vB::getUserContext();
		$userid = $userContext->fetchUserId();
		// just ignore for not logged in
		if ($userid < 1)
		{
			return;
		}
		// make sure this is a valid id.
		$assertor = vB::getDbAssertor();
		$avatarData = $assertor->getRows('avatar', ['avatarid' => $avatarid]);

		if (!$avatarData OR !empty($avatarData['errors']) OR $avatarData[0]['imagecategoryid'] <> 3)
		{
			throw new vB_Exception_Api('invalid_data');
		}

		$result = $this->save($userid, null, ['avatarid' => $avatarid], [], [], [], []);

		if ($result)
		{
			$assertor->assertQuery('customavatar', 	[vB_dB_Query::TYPE_KEY => vB_dB_Query::QUERY_DELETE,	'userid' => $userid]);
		}

		return $this->fetchAvatar($userid);
	}

	/**
	 *	Convert the search array to the assertor conditions.
	 *
	 *	Refactored from adminfunctions_user.php fetch_user_search_sql
	 *
	 *	@param array $user -- user fields to search
	 *	@param array $profile -- profile fields to search
	 *
	 *	@return array
	 *		* conditions array -- conditions suitable for passing to the querybuilder class
	 *		* joins -- a list of table aliases required by the filters.  Intended to allow the method queries
	 *			that use this information to only join to tables needed for a particular filter.  Does not include
	 *			the base user table which is assumed to be the core table in the query.
	 *		* exceptions array -- information to feed custom filters that don't work with querybuilder
	 *				the method queries that consume this infromatoin
	 */
	private function fetchUserSearchCondition($user, $profile)
	{
		//keep this in one place in case it needs to change.
		$prefix = 'user.';

		$conditions = [];
		$joins = [];
		$doUsernameOrDisplayname = [];

		$user['username'] = trim($user['username'] ?? '');
		if ($user['username'])
		{
			$condition = [
				'operator' => vB_dB_Query::OPERATOR_INCLUDES
			];

			if (!empty($user['exact']))
			{
				$condition['operator'] = vB_dB_Query::OPERATOR_EQ;
			}

			$usernameFilter = $user['username_filter'] ?? 'either';
			if ($usernameFilter == 'username')
			{
				$condition['field'] = "{$prefix}username";
				$condition['value'] = vB_String::htmlSpecialCharsUni($user['username']);
				$conditions[] = $condition;
			}
			else if ($usernameFilter == 'displayname')
			{
				$condition['field'] = "{$prefix}displayname";
				$condition['value'] = $user['username'];
				$conditions[] = $condition;
			}
			else
			{
				$doUsernameOrDisplayname = [
					'displayname' => $user['username'],
					'username' => vB_String::htmlSpecialCharsUni($user['username']),
					'operator' => $condition['operator'],
				];
				// skip username or displayname in conditions, this will be handled specially in the querydefs
			}

			unset($condition);
		}
		else if (!empty($user['email']) AND !empty($user['exact_email']))
		{
			// exact email match for VBV-15751
			$conditions[] = ['field' => "{$prefix}email", 'value' => $user['email'], 'operator' => vB_dB_Query::OPERATOR_EQ];
			unset ($user['email']); // don't try to do "includes" matching below.
		}
		//note that this is a special search that precludes any other filters.  This may not be apparent from elsewhere.
		else if (!empty($user['username_or_email']))
		{
			$user['username_or_email'] = trim($user['username_or_email']);
			$op = vB_dB_Query::OPERATOR_INCLUDES;
			if (!empty($user['exact']))
			{
				$op =  vB_dB_Query::OPERATOR_EQ;
			}
			$conditions[]  = [
				'field' => "{$prefix}username",
				'value' => vB_String::htmlSpecialCharsUni($user['username_or_email']),
				'operator' => $op
			];
			$conditions[] = [
				'field' => "{$prefix}email",
				'value' => $user['username_or_email'],
				'operator' => $op
			];

			return [
				'filters' => [],
				'joins' => [],
				'unions' => $conditions,
				//this isn't actually used if the unions param is set -- perhaps we shouldn't send it.
				'exceptions' => ['membergroup' => $user['membergroup'] ?? []],
			];
		}

		$exceptions = [
			'membergroup' => $user['membergroup'] ?? []
		];

		//handle the case where usergroup is an array or a singleton -- exclude the special value of -1
		if (isset($user['usergroupid']))
		{
			$ids = false;
			if (is_array($user['usergroupid']))
			{
				$ids = array_map('intval', $user['usergroupid']);
			}
			else if ($user['usergroupid'] != -1 AND $user['usergroupid'])
			{
				$ids = intval($user['usergroupid']);
			}

			//if we have something, set the condition
			if ($ids)
			{
				$conditions[] = ['field' => "{$prefix}usergroupid", 'value' => $ids, 'operator' => vB_dB_Query::OPERATOR_EQ];
			}
		}

		if (isset($user['coppauser']))
		{
			$user_option_fields = vB::getDatastore()->getValue('bf_misc_useroptions');
			if ($user['coppauser'] == 1)
			{
				$conditions[] = [
					'field' => "{$prefix}options",
					'value' => $user_option_fields['coppauser'],
					'operator' => vB_dB_Query::OPERATOR_AND
				];
			}
			else if ($user['coppauser'] == 0)
			{
				$conditions[] = [
					'field' => "{$prefix}options",
					'value' => $user_option_fields['coppauser'],
					'operator' => vB_dB_Query::OPERATOR_NAND
				];
			}
		}

		if (isset($user['facebook']))
		{
			if ($user['facebook'] == 1)
			{
				$conditions[] = ['field' => "{$prefix}fbuserid", 'value' => '',	'operator' => vB_dB_Query::OPERATOR_NE];
			}
			else if ($user['facebook'] == 0)
			{
				$conditions[] = ['field' => "{$prefix}fbuserid", 'value' => '',	'operator' => vB_dB_Query::OPERATOR_EQ];
			}
		}

		/*
			Privacy field searches requiring special mapping
		 */

		// At the moment, this is labeled "requires consent" in the adminCP user search form.
		// This will either be
		// 	1 if we want users that require consent or
		// 	0 if we want users that don't require consent
		// If it's not set or we get any other value don't to anything (-1 is canonical for an explicit don't care)
		//
		// Previously we checked the eustatus field directly without reference to the options, which meant
		// that we returned users that *would* need confirmation if the option where enabled .
		// But with the user defined locations we no longer no what *would* need confirmation only what
		// does.  This is a subtle change but potentially significant.
		//
		// Also the logic is more complicated so we need to punt this to the "exceptions" list and handle it
		// in the query function
		if (isset($user['eustatus_check']) AND in_array($user['eustatus_check'], [0, 1]))
		{
			$optionLib = vB_Library::instance('options');
			$locations = $optionLib->getLocationOption('enable_privacy_registered');
			$cache = $optionLib->getLocationCache();

			$codes = [];
			foreach ($locations AS $locationid)
			{
				$codes = array_merge($codes, $cache[$locationid]);
			}

			$exceptions['locationcodes'] = array_unique($codes);
			$exceptions['locationchecktype'] = ($user['eustatus_check'] ? 'include' : 'exclude');
		}
		unset($user['eustatus_check']);

		// Consent status in the adminCP user search for has the options of  "provided",
		// "withdrawn", "unknown" and "any". Note that "unknown" and "any" are different!
		if (isset($user['privacyconsent']))
		{
			if ($user['privacyconsent'] === 'any')
			{
				// searcher doesn't care
			}
			else if ($user['privacyconsent'] == 1)
			{
				// provided consent
				$conditions[] = [
					'field' => "{$prefix}privacyconsent",
					'value' => '1',
					'operator' => vB_dB_Query::OPERATOR_EQ,
				];
			}
			else if ($user['privacyconsent'] == -1)
			{
				// withdrew consent
				$conditions[] = [
					'field' => "{$prefix}privacyconsent",
					'value' => '-1',
					'operator' => vB_dB_Query::OPERATOR_EQ,
				];
			}
			else if ($user['privacyconsent'] == 0)
			{
				// explicit search for user has neither provided nor withdrew consent (aka "unknown")
				$conditions[] = [
					'field' => "{$prefix}privacyconsent",
					'value' => '0',
					'operator' => vB_dB_Query::OPERATOR_EQ,
				];
			}
			unset($user['privacyconsent']);
		}
		// privacyconsentupdatedafter & privacyconsentupdatedbefore are handled below via
		// the generic timestamp converting & search condition mapping

		//different table.
		if (!empty($user['signature']))
		{
			$joins['usertextfield'] = 'usertextfield';
			$conditions[] = ['field' => 'usertextfield.signature', 'value' => $user['signature'],	'operator' => vB_dB_Query::OPERATOR_INCLUDES];
		}

		//this is special, I'm not sure why...
		//actual filter added below with the standard filters
		if (!empty($user['lastactivityafter']))
		{
			if (strval($user['lastactivityafter']) == strval(intval($user['lastactivityafter'])))
			{
				$user['lastactivityafter'] = intval($user['lastactivityafter']);
			}
			else
			{
				$user['lastactivityafter'] = strtotime($user['lastactivityafter']);
			}
		}

		//note that previously the date => timestamp conversion was done on the mysql side
		//with UNIX_TIMESTAMP.  In order to avoid trying to encode as an operation into the
		//DB Assertor, we'll move this to the client side.
		$dateFields = [
			'joindateafter',
			'joindatebefore',
			'lastactivitybefore',
			'lastpostafter',
			'lastpostbefore',
			'privacyconsentupdatedafter',
			'privacyconsentupdatedbefore',
		];
		foreach ($dateFields AS $field)
		{
			//strtotime is strange function, but anything valid for UNIX_TIMESTAMP should be okay here.
			if (!empty($user[$field]))
			{
				$user[$field] = strtotime($user[$field]);
			}
		}

		//standard fields
		// This is for fields that check if the given value is included in the text of a given field
		// (field like "%value%") in sql terms.  This replaces a bunch of nearly identical
		// if statements
		$fields = [
			vB_dB_Query::OPERATOR_INCLUDES => [
				'email', 'parentemail', 'homepage', 'usertitle', 'usertitle', 'ipaddress'
			],
			vB_dB_Query::OPERATOR_GT => [
				'birthdayafter' => 'birthday_search',
				'lastactivityafter' => 'lastactivity',
				'joindateafter' => 'joindate',
				'lastpostafter' => 'lastpost',
				'privacyconsentupdatedafter' => 'privacyconsentupdated',
			],
			vB_dB_Query::OPERATOR_GTE => [
				'postslower' => 'posts',
				'infractionslower' => 'infractions',
				'warningslower' => 'warnings',
				'pointslower' => 'ipoints',
				'reputationlower' => 'reputation',
				'useridlower' => 'userid',
			],
			vB_dB_Query::OPERATOR_LT => [
				'birthdaybefore' => 'birthday_search',
				'lastactivitybefore' => 'lastactivity',
				'joindatebefore' => 'joindate',
				'lastpostbefore' => 'lastpost',
				'privacyconsentupdatedbefore' => 'privacyconsentupdated',

				'postsupper' => 'posts',
				'infractionsupper' => 'infractions',
				'warningsupper' => 'warnings',
				'pointsupper' => 'ipoints',
				'reputationupper' => 'reputation',
				'useridupper' => 'userid',
			],
		];

		foreach ($fields AS $operator => $fieldList)
		{
			foreach ($fieldList AS $key => $field)
			{
				if (is_numeric($key))
				{
					$key = $field;
				}

				if (!empty($user[$key]))
				{
					$conditions[] = ['field' => "{$prefix}$field", 'value' => $user[$key], 'operator' => $operator];
				}
			}
		}

		$profilefields = vB::getDbAssertor()->assertQuery('vBForum:fetchprofilefields');
		foreach ($profilefields AS $profilefield)
		{
			$profConditions = $this->getProfileFieldConditions($profilefield, $profile);
			if ($profConditions)
			{
				$joins['userfield'] = 'userfield';
			}

			$conditions = array_merge($conditions, $profConditions);
		}

		return [
			'filters' => $conditions,
			'joins' => array_values($joins),
			'exceptions' => $exceptions,
			'do_username_or_displayname' => $doUsernameOrDisplayname,
		];
	}

	/**
	 * 	Get the profile information so the presentation can render it
	 *	@param 		int		userid
	 *	@return	array | false sigature information or false if there is an error or the user doesn't
	 *		have a sigature.  If the user is not permitted to have a signature, then they will
	 *		be treated as not having one even if it doesn't exist.
	 *		signature
	 *		permissions
	 *			dohtml
	 *			dobbcode
	 *			dobbimagecode
	 * 			dosmilies
	 *		sigpic
	 *		sigpicrevision
	 *		sigpicdateline
	 */
	public function fetchSignature($userid)
	{
		if (empty($userid))
		{
			return false;
		}
		$sigUserContext = vB::getUserContext($userid);
		$options = vB::getDatastore()->getValue('options');

		if (!$sigUserContext->hasPermission('genericpermissions', 'canusesignature') OR
			!(bool)$options['allow_signatures'])
		{
			return false;
		}
		$userInfo = vB_User::fetchUserinfo($userid);

		if (empty($userInfo['signature']))
		{
			return false;
		}

		$signature = [];
		$signature['raw'] = trim($userInfo['signature']);
		$signature['permissions'] = [
			'dohtml' => $sigUserContext->hasPermission('signaturepermissions', 'allowhtml'),
			'dobbcode' => $sigUserContext->hasPermission('signaturepermissions', 'canbbcode'),
			'dobbimagecode' => $sigUserContext->hasPermission('signaturepermissions', 'allowimg'),
			'dosmilies' => $sigUserContext->hasPermission('signaturepermissions', 'allowsmilies'),
		];

		if (
			isset($userInfo['sigpic']) AND
			!empty($userInfo['sigpic']) AND
			$sigUserContext->hasPermission('signaturepermissions', 'cansigpic')
		)
		{
			$signature['sigpic'] = $userInfo['sigpic'];
			$signature['sigpicrevision'] = $userInfo['sigpicrevision'];
			$signature['sigpicdateline'] = $userInfo['sigpicdateline'];
		}
		//make sure that keys always exist.
		else
		{
			$signature['sigpic'] = null;
			$signature['sigpicrevision'] = null;
			$signature['sigpicdateline'] = null;
		}

		return $signature;
	}


	// ###################### Start checkprofilefield #######################
	protected function getProfileFieldConditions($profilefield, $profile)
	{
		$varname = "field$profilefield[profilefieldid]";

		$value = $profile[$varname] ?? '';
		$optvalue = $profile[$varname . '_opt'] ?? '';

		if (empty($value) AND $optvalue === '')
		{
			return [];
		}

		$conditions = [];
		if (($profilefield['type'] == 'input' OR $profilefield['type'] == 'textarea') AND $value !== '')
		{
			$conditions[] = ['field' => $varname, 'value' => vB_String::htmlSpecialCharsUni(trim($value)), 'operator' => vB_dB_Query::OPERATOR_INCLUDES];
		}

		if ($profilefield['type'] == 'radio' OR $profilefield['type'] == 'select')
		{
			if ($value == 0 AND $optvalue === '')
			{
				// The select field was left blank!
				// and the optional field is also empty
				return [];
			}

			if ($profilefield['optional'] AND !empty($optvalue))
			{
				$conditions[] = ['field' => $varname, 'value' => htmlspecialchars_uni(trim($optvalue)), 'operator' => vB_dB_Query::OPERATOR_INCLUDES];
			}
			else
			{
				$data = vb_unserialize($profilefield['data']);
				foreach ($data AS $key => $val)
				{
					if (($key + 1) == $value)
					{
						$conditions[] = ['field' => $varname, 'value' => htmlspecialchars_uni(trim($val)), 'operator' => vB_dB_Query::OPERATOR_INCLUDES];
						break;
					}
				}
			}
		}

		if (($profilefield['type'] == 'checkbox' OR $profilefield['type'] == 'select_multiple') AND is_array($value))
		{
			foreach ($value AS $key => $val)
			{
				$conditions[] = ['field' => $varname, 'value' => pow(2, $val - 1), 'operator' => vB_dB_Query::OPERATOR_AND];
			}
		}
		return $conditions;
	}

	/**
	 * Fetch today's birthdays
	 * @return array birthday information
	 */
	public function fetchBirthdays()
	{
		$today = vbdate('Y-m-d', vB::getRequest()->getTimeNow(), false, false);
		$birthdaycache = vB::getDatastore()->getValue('birthdaycache');

		if (
			!is_array($birthdaycache)
			OR ($today != $birthdaycache['day1'] AND $today != $birthdaycache['day2'])
			OR !is_array($birthdaycache['users1'])
		)
		{
			// Need to update!
			$birthdaystore = $this->library->buildBirthdays();
		}
		else
		{
			$birthdaystore = $birthdaycache;
		}

		switch ($today)
		{
			case $birthdaystore['day1']:
				$birthdaysarray = $birthdaystore['users1'];
				break;

			case $birthdaystore['day2']:
				$birthdaysarray = $birthdaystore['users2'];
				break;

			default:
				$birthdaysarray = [];
		}

		return $birthdaysarray;
	}

	/**
	 * Returns an array with the usernames for the user ids and optionally the profileUrl for the user
	 *
	 * @param array $userIds
	 * @param bool $profileUrl - if true include the profileUrl field in the returned array.
	 *
	 * @return array -- [$userid => ['username' => $username, 'profileUrl' => $profileUrl]]
	 */
	public function fetchUsernames($userIds, $profileUrl = true)
	{
		$res = [];
		$usernames = vB_Library::instance('user')->fetchUserNames($userIds);
		foreach ($usernames AS $userid => $username)
		{
			$res[$userid]['username'] = $username;

			if ($profileUrl)
			{
				$res[$userid]['profileUrl'] = vB5_Route::buildUrl('profile', ['userid' => $userid, 'username' => $username]);
			}

			$res[$userid]['userid'] = $userid;
		}
		return $res;
	}

	/**
	 * Updates the user status
	 *
	 * @param int		UserID
	 * @param String	Status to set
	 *
	 * @return	String	Updated status from user.
	 */
	public function updateStatus($userid, $status)
	{
		$userContext = vB::getUserContext();
		$currentUserId = $userContext->fetchUserId();
		$userid = intval($userid);
		$vboptions = vB::getDatastore()->getValue('options');

		if (vB_String::vbStrlen($status) > $vboptions['statusMaxChars'])
		{
			throw new vB_Exception_Api('please_enter_user_status_with_at_most_x_characters', [$vboptions['statusMaxChars']]);
		}

		if ($userid <= 0 AND $currentUserId)
		{
			$userid = $currentUserId;
		}

		// check user is logged
		if (!$userid)
		{
			throw new vB_Exception_Api('invalid_userid');
		}

		$canModifyProfile = (($currentUserId == $userid) AND $userContext->hasPermission('genericpermissions', 'canmodifyprofile'));

		// If this isn't the current user updating their own status, check if current user canadminusers
		if (!$canModifyProfile)
		{
			$this->checkHasAdminPermission('canadminusers');
		}

		$userInfo = vB_User::fetchUserinfo($userid);
		$userdata = new vB_DataManager_User(vB_DataManager_Constants::ERRTYPE_STANDARD);
		$userdata->set_existing($userInfo);
		$userdata->set('status', $status);
		$result = $userdata->save();

		if (!is_array($result))
		{
			$userInfo = vB_User::fetchUserinfo($userid, [], 0, true);

			// Check for monitored words in user status and send notifications
			$this->library->monitorWords($userInfo['status'], 'user-status', null, $userInfo['userid']);

			return $userInfo['rawstatus'];
		}
		else
		{
			return false;
		}
	}

	/**
	 * Ban users
	 *
	 * @param array $userids Userids to ban
	 * @param int $banusergroupid Which banned usergroup to move the users to
	 * @param string $period Ban period
	 * @param string $reason Ban reason
	 */
	public function banUsers($userids, $banusergroupid, $period, $reason = '')
	{
		$assertor = vB::getDbAssertor();
		$loginuser = &vB::getCurrentSession()->fetch_userinfo();
		$usercontext = &vB::getUserContext($loginuser['userid']);
		if (!$usercontext->hasAdminPermission('cancontrolpanel') AND !$usercontext->hasPermission('moderatorpermissions', 'canbanusers'))
		{
			$forumHome = vB_Library::instance('content_channel')->getForumHomeChannel();
			throw new vB_Exception_Api('nopermission_loggedin',
				[
					$loginuser['username'],
					vB_Template_Runtime::fetchStyleVar('right'),
					$loginuser['securitytoken'],
					vB5_Route::buildUrl($forumHome['routeid'] . '|fullurl'),
				]
			);
		}

		if (!is_array($userids))
		{
			throw new vB_Exception_Api('invalid_data_w_x_y_z', [$userids, 'userids', __CLASS__, __FUNCTION__]);
		}

		foreach ($userids as &$userid)
		{
			$userid = intval($userid);
		}

		$bannedusergroups = vB_Api::instanceInternal('usergroup')->fetchBannedUsergroups();

		if (!in_array($banusergroupid, array_keys($bannedusergroups)))
		{
			throw new vB_Exception_Api('invalid_usergroup_specified');
		}

		// check that the number of days is valid
		if ($period != 'PERMANENT' AND !preg_match('#^(D|M|Y)_[1-9][0-9]?$#', $period))
		{
			throw new vB_Exception_Api('invalid_ban_period_specified');
		}

		if ($period == 'PERMANENT')
		{
			// make this ban permanent
			$liftdate = 0;
		}
		else
		{
			// get the unixtime for when this ban will be lifted
			require_once(DIR . '/includes/functions_banning.php');
			$liftdate = convert_date_to_timestamp($period);
		}

		$user_dms = [];

		$current_bans = $assertor->getRows('user_fetchcurrentbans', [
			'userids' => $userids
		]);
		foreach ($current_bans AS $current_ban)
		{
			$userinfo = vB_User::fetchUserinfo($current_ban['userid']);
			$userid = $userinfo['userid'];

			if ($current_ban['bandate'])
			{
				// they already have a ban, check if the current one is being made permanent, continue if its not
				if ($liftdate AND $liftdate < $current_ban['liftdate'])
				{
					continue;
				}

				// there is already a record - just update this record
				$assertor->update('userban',
					[
						'bandate' => vB::getRequest()->getTimeNow(),
						'liftdate' => $liftdate,
						'adminid' => $loginuser['userid'],
						'reason' => $reason,
					],
					[
						'userid' => $userinfo['userid'],
					]
				);


			}
			else
			{
				// insert a record into the userban table
				/*insert query*/
				$assertor->insert('userban', [
					'userid' => $userinfo['userid'],
					'usergroupid' => $userinfo['usergroupid'],
					'displaygroupid' => $userinfo['displaygroupid'],
					'customtitle' => $userinfo['customtitle'],
					'usertitle' => $userinfo['usertitle'],
					'adminid' => $loginuser['userid'],
					'bandate' => vB::getRequest()->getTimeNow(),
					'liftdate' => $liftdate,
					'reason' => $reason,
				]);
			}

			// update the user record
			$user_dms[$userid] = new vB_DataManager_User(vB_DataManager_Constants::ERRTYPE_SILENT);
			$user_dms[$userid]->set_existing($userinfo);
			$user_dms[$userid]->set('usergroupid', $banusergroupid);
			$user_dms[$userid]->set('displaygroupid', 0);
			$user_dms[$userid]->set('status', ''); // clear status, VBV-15853

			// update the user's title if they've specified a special user title for the banned group
			if ($bannedusergroups[$banusergroupid]['usertitle'] != '')
			{
				$user_dms[$userid]->set('usertitle', $bannedusergroups[$banusergroupid]['usertitle']);
				$user_dms[$userid]->set('customtitle', 0);
			}
			$user_dms[$userid]->pre_save();
		}

		foreach ($user_dms AS $userdm)
		{
			$userdm->save();
		}

		// and clear perms
		foreach ($userids AS $uid)
		{
			vB::getUserContext($uid)->clearChannelPermissions();
		}

		return true;
	}

	/**
	 * Returns global permission value or specific value for a nodeid for current user.
	 * @param string $group
	 * @param string $permission
	 * @param boolean $nodeid (optional)
	 * @return boolean|int
	 */
	public function hasPermissions($group, $permission, $nodeid = false)
	{
		if ($this->disabled)
		{
			// if disabled we do not have permission
			return false;
		}

		if ($group == 'adminpermissions')
		{
			//adminpermissions are always global.
			return vB::getUserContext()->hasAdminPermission($permission);
		}
		else if (empty($nodeid))
		{
			return vB::getUserContext()->hasPermission($group, $permission);
		}
		else
		{
			return vB::getUserContext()->getChannelPermission($group, $permission, $nodeid);
		}
	}

	/**
	 * Checks the various options as to whether the current user can physically remove a post

	 * @param integer $nodeid
	 *
	 * @return integer	0 or 1
	 */
	public function canRemovePost($nodeid)
	{
		if ($this->disabled)
		{
			// if disabled we do not have permission
			return 0;
		}

		$nodeid = vB::getCleaner()->clean($nodeid, vB_Cleaner::TYPE_INT);
		$userContext = vB::getUserContext();

		//if the user has global canremove, we're done
		if ($userContext->hasPermission('moderatorpermissions', 'canremoveposts') OR
			$userContext->getChannelPermission('moderatorpermissions', 'canremoveposts', $nodeid))
		{
			return 1;
		}

		//If this is is a visitor message, we check some other permissions.
		$node = vB_Library::instance('node')->getNodeBare($nodeid);
		if (($node['starter'] > 0) AND ($node['setfor'] > 0))
		{
			if ($userContext->hasPermission('moderatorpermissions2', 'canremovevisitormessages'))
			{
				return 1;
			}
			else if (($node['setfor'] == vB::getCurrentSession()->get('userid')) AND
				$userContext->hasPermission('visitormessagepermissions', 'candeleteownmessages'))
			{
				return 1;
			}
		}
		return 0;
	}


	/**
	 * Returns permission values of a group of nodes for current user.
	 * @param string $group
	 * @param string $permission
	 * @param array $nodeIds
	 * @return boolean|int
	 * @see vB_Api_User::hasPermissions
	 */
	public function havePermissions($group, $permission, $nodeIds = [])
	{
		if (empty($nodeIds))
		{
			return [];
		}

		$cleaner = vB::getCleaner();
		$nodeIds = $cleaner->clean($nodeIds, vB_Cleaner::TYPE_ARRAY_INT);

		$result = [];

		foreach ($nodeIds AS $nodeId)
		{
			$result[$nodeId] = $this->hasPermissions($group, $permission, $nodeId);
		}

		return $result;
	}

	/**
	 *	Invites members to a given node channel passing either an array of userids or usernames.
	 *
	 *	Will combine the list of username with the list of userids to get the list of
	 *	users to invite.
	 *
	 *	@param array 				$userids
	 *	@param array|string	$userNames
	 *	@param int 					$nodeId
	 *	@param string 			$requestType --	Either 'member_to' (blogs) or 'sg_member_to' (social groups)
	 *
	 *	@param array		List of the sucessfully invited members.
	 */

	public function inviteMembers($userIds, $userNames, $nodeId, $requestType)
	{
		$inviteMembers = [];
		// fetch userids...
		if (!is_array($userNames))
		{
			$userNames = [$userNames];
		}

		$users = [];
		if (is_array($userNames) AND !empty($userNames))
		{
			$users = vB::getDbAssertor()->assertQuery('user', ['username' => $userNames]);
			if ($users AND !$users->valid())
			{
				$users = [];
			}
		}

		foreach ($users AS $user)
		{
			$inviteMembers[] = $user['userid'];
		}

		// and check that userids are valid...
		if (!is_array($userIds))
		{
			$userIds = [$userIds];
		}

		foreach ($userIds AS $pos => $id)
		{
			if (!intval($id))
			{
				unset($userIds[$pos]);
			}
		}

		$inviteMembers = array_unique(array_merge($inviteMembers, $userIds));
		if (empty($inviteMembers))
		{
			throw new vB_Exception_Api('invalid_data');
		}

		if (!intval($nodeId))
		{
			throw new vB_Exception_Api('invalid_node_id');
		}
		// let's check that node really exists
		$nodeApi = vB_Api::instanceInternal('node');
		$node = $nodeApi->getNode($nodeId);

		//and check that these invites don't already exist.

		$existingCheck =  vB::getDbAssertor()->assertQuery('vBForum:getExistingRequest', [
			'userid' => $inviteMembers,
			'nodeid' => $nodeId,
			'request' => $requestType
		]);

		if ($existingCheck->valid())
		{
			foreach ($existingCheck AS $existing)
			{
				unset($inviteMembers[$existing['userid']]);
			}
		}
		$invited = [];
		foreach ($inviteMembers AS $member)
		{
			//requestChannel enforces permissions necesary
			$response = vB_Library::instance('node')->requestChannel($nodeId, $requestType, $member, null, true);
			if (!is_array($response))
			{
				$invited[] = $member;
			}
		}

		return $invited;
	}

	/**
	 *	Generates users mailing list for the given criteria.
	 *	Used for admincp - email sending and list generating.
	 *
	 * 	@param 	array 	$user 		An array of common conditions for user search
	 * 	@param 	array 	$profile 	An array of user profile field conditions for user search
	 * 	@param	array	$options 	Set of options such as activation info and pagination.
	 *
	 *	@return bool |array False if no user found. Otherwise it returns users array as result.
	 *		 The array also contains a field that stores total found user's e-mail count.
	 */
	public function generateMailingList($user, $profile, $options = [])
	{
		if (!vB::getUserContext()->hasAdminPermission('canadminusers'))
		{
			throw new vB_Exception_Api('invalid_permissions');
		}

		$conditions = $this->fetchUserSearchCondition($user, $profile);
		$conditions['options'] = ['adminemail' => !empty($user['adminemail'])];

		if (!empty($options['activation']))
		{
			$conditions['activation'] = 1;
			$conditions[vB_dB_Query::PARAM_LIMITPAGE] = intval($options[vB_dB_Query::PARAM_LIMITPAGE] ?? 0);
			$limit = intval($options[vB_dB_Query::PARAM_LIMIT] ?? 0);
			$conditions[vB_dB_Query::PARAM_LIMIT] = ($limit ? $limit : 500);
		}

		$db = vB::getDbAssertor();

		$mailList = $db->getRows('fetchMailingList', $conditions);

		if (!empty($options['activation']))
		{
			$count = $db->getRow('fetchMailingListCount', $conditions);
			$count = $count['total'];
		}
		else
		{
			$count = count($mailList);
		}

		return ['list' => $mailList, 'totalcount' => $count];
	}

	/**
	 *	Fetch users and info from a given user criteria
	 *	Used for admincp - verticalresponse.
	 *
	 * 	@param 	array 	$user 		An array of common conditions for user search
	 * 	@param 	array 	$profile 	An array of user profile field conditions for user search
	 * 	@param	array	$options 	Set of options such as activation info and pagination.
	 *
	 *	@return array 	$result 	Result which includes the 'users' => userlist and the 'totalcount'.
	 */
	public function getUsersFromCriteria($user, $profile, $options = [])
	{
		if (!vB::getUserContext()->hasAdminPermission('canadminusers'))
		{
			throw new vB_Exception_Api('invalid_permissions');
		}

		$conditions = $this->fetchUserSearchCondition($user, $profile);
		if (!empty($options[vB_dB_Query::PARAM_LIMITPAGE]) OR !empty($options[vB_dB_Query::PARAM_LIMIT]))
		{
			$conditions[vB_dB_Query::PARAM_LIMITPAGE] = (intval($options[vB_dB_Query::PARAM_LIMITPAGE])) ? intval($options[vB_dB_Query::PARAM_LIMITPAGE]) : 1;
			// default 50...
			$conditions[vB_dB_Query::PARAM_LIMIT] = (intval($options[vB_dB_Query::PARAM_LIMIT])) ? intval($options[vB_dB_Query::PARAM_LIMIT]) : 50;
		}

		$userList = vB::getDbAssertor()->getRows('fetchUsersFromCriteria', $conditions);
		return ['users' => $userList, 'totalcount' => count($userList)];
	}

	/**
	 *	Fetch private messages statistics from all the users.
	 *	Used for admincp - usertools private message statistics
	 *
	 * 	@param	array	$options 	Set of options such as pagination, total pms filter.
	 * 	* total int-- if given filter results as users for a given total
	 * 	* sortby string -- field to sort results current valid values are (username, total)
	 * 	* sortdir string -- ASC or DESC.  Only used if sortby is set.  If not given will default to ASC
	 *
	 *	@return array 	$result 	Private messages grouped by userid (including some userinfo and pm total count).
	 */
	public function fetchUsersPms($options = [])
	{
		if (!vB::getUserContext()->hasAdminPermission('canadminusers'))
		{
			throw new vB_Exception_Api('invalid_permissions');
		}

		$params = [];

		/*
 		//this isn't currently used by the query but we might want it eventually
		if (!empty($options[vB_dB_Query::PARAM_LIMITPAGE]) OR !empty($options[vB_dB_Query::PARAM_LIMIT]))
		{
			$params[vB_dB_Query::PARAM_LIMITPAGE] = (intval($options[vB_dB_Query::PARAM_LIMITPAGE])) ? intval($options[vB_dB_Query::PARAM_LIMITPAGE]) : 1;
			// default 50...
			$params[vB_dB_Query::PARAM_LIMIT] = (intval($options[vB_dB_Query::PARAM_LIMIT])) ? intval($options[vB_dB_Query::PARAM_LIMIT]) : 50;
		}
		*/

		if (!empty($options['total']))
		{
			$params['total'] = intval($options['total']);
		}

		$params['sortby'] = $options['sortby'] ?? '';
		$params['sortdir'] = $options['sortdir'] ?? '';

		$pms = vB::getDbAssertor()->getRows('vBForum:getUsersPms', $params);
		return $pms;
	}

	/**
	 * This implements vB_PermissionContext::getAdminUser().
	 * return	int		User id from a user that can administer the admincp
	 */
	public function fetchAdminUser()
	{
		return vB_PermissionContext::getAdminUser();
	}

	/**
	 * This gets the current user profile fields from the database.
	 * @TODO improve this to be consistent with profilefield table. We should wrap that out when moving user profile fields add/updating to the API
	 *
	 * @return	array	The title of the existing user profile fields.
	 */
	public function fetchUserProfileFields()
	{
		$uFields = vB::getDbAssertor()->assertQuery('fetchUserFields');

		$fields = [];
		foreach ($uFields AS $field)
		{
			if ($field['Field'] != 'temp' AND $field['Field'] != 'userid')
			{
				$fields[] = $field['Field'];
			}
		}

		return $fields;
	}

	/**
	 * This likes the channels below a parent node where a user can create starters based on groupintopic
	 * @param	int $parentNodeId -- the ancestor node id
	 *
	 * @return array array of integer, title- the nodeids
	 */
	public function getGitCanStart($parentNodeId)
	{
		// This function is meant to find "all blog channels this user can post in"
		$subchannels = vB::getDbAssertor()->getRows('vBForum:getGitSubchannels', [
			'parentnodeId' => $parentNodeId,
			'userid' => vB::getCurrentSession()->get('userid'),
		]);
		$returnChannels = [];
		$usercontext = vB::getUserContext();
		foreach ($subchannels AS $__row)
		{
			if ($usercontext->canContribute($__row['nodeid']))
			{
				$returnChannels[$__row['title']] = $__row;
			}
		}

		ksort($returnChannels, SORT_NATURAL);

		return array_values($returnChannels);
	}

	/**
	 * Tells whether the current user can create a blog entry. That can be their own permissions or GIT.
	 * @param int $nodeid	-- optional. If not passed will check the global blog channel.
	 * @return 1 if the user can create a entry in the given channel.  0 otherwise
	 */
	public function canCreateBlogEntry($nodeid = 0)
	{
		//This is called from the templates, so we return 0/1.  Templates have problems with true/false.
		if (empty($nodeid) AND vB::getUserContext()->hasPermission('forumpermissions', 'cancreateblog'))
		{
			return 1;
		}

		if (empty($nodeid))
		{
			$nodeid = vB_Library::instance('blog')->getBlogChannel();
		}
		$canStart = $this->getGitCanStart($nodeid);

		if (!empty($canStart))
		{
			return 1;
		}

		return 0;
	}

	/** Adjust GMT time back to user's time
	 * Use "gm" versions of date/time functions with this offset, not ones that rely on
	 * current server's system timezone.
	 *
	 * @param int  $userid             (Optional) If skipped, will use current user's offset.
	 *                                 If provided, will use that user's offset.
	 * @param bool $ignoreDST          (Optional) Default false. Normally, if
	 *                                 daylight savings time is active (either
	 *                                 for the user or on the server) this
	 *                                 function adds 1 hour to the offset to
	 *                                 account for it. E.g. A California user
	 *                                 would normally have their timezone set to
	 *                                 GMT-0800, but it needs to be -0700 during
	 *                                 daylight savings time. If set to true however,
	 *                                 this compensation is skipped.
	 *
	 * @return integer
	 */
	public function fetchTimeOffset($userid = false, $ignoreDST = false)
	{
		if ($userid === false)
		{
			$userInfo = vB::getCurrentSession()->fetch_userinfo();
		}
		else
		{
			$userInfo = $this->library->fetchUserinfo($userid);
		}

		$hourdiff = null;
		if (is_array($userInfo) AND isset($userInfo['timezoneoffset']))
		{
			if ($ignoreDST)
			{
				return $userInfo['timezoneoffset'] * 3600;
			}

			$options = vB::getDatastore()->getValue('options');
			if (
				(isset($userInfo['dstonoff']) AND $userInfo['dstonoff']) OR
				(isset($userInfo['dstauto']) AND $userInfo['dstauto'] AND $options['dstonoff'])
			)
			{
				// DST is on, add an hour
				$userInfo['timezoneoffset']++;
				if ((substr($userInfo['timezoneoffset'], 0, 1) != '-') AND (substr($userInfo['timezoneoffset'], 0, 1) != '+'))
				{
					// recorrect so that it has a + sign, if necessary
					$userInfo['timezoneoffset'] = '+' . $userInfo['timezoneoffset'];
				}
			}

			$hourdiff = $userInfo['timezoneoffset'] * 3600;
		}

		return $hourdiff;
	}


	/**
	 * translate a year/month/day/hour/minute to a Unix timestamp.
	 *
	 * @param	array $dateInfo -- array of year, month, day, hour, minute, second. Year and month are required.
	 *
	 * @return integer -- Unix Timestamp, corrected for the user's time setting
	 */
	public function vBMktime($dateInfo)
	{
		// The date has already been corrected to .. date_default_timezone_get(),
		//	which could be the server setting but might not be.
		// The most reliable thing is to just get that offset.
		static $userOffset;

		if (empty($dateInfo['year']) OR empty($dateInfo['month']) OR ($dateInfo['month'] > 12))
		{
			return 0;
		}

		if (empty($dateInfo['day']) OR !intval($dateInfo['day']) OR (intval($dateInfo['day']) > 31) OR (intval($dateInfo['day']) < 1))
		{
			$dateInfo['day'] = 1;
		}
		// !isset() instead of empty(), because 00:00:00 is a real time (today's 12AM, previous day's "24:00:00")
		// Most 24 hour clocks go from 00:00 to 23:59 to get rid of the ambiguity of 24:00 which many consider to be the next day.
		if (!isset($dateInfo['hour']) OR !intval($dateInfo['hour']) OR (intval($dateInfo['hour']) >= 24) OR (intval($dateInfo['hour']) < 0))
		{
			// 12 might make sense if we were on a am/pm 12-h notation, but this function doesn't seem to allow that. So to me 0 makes more sense
			// as the default. Also technically mktime/gmmktime supports negative hours & hours greater than 23 (previous day, next day, respectively)
			//$dateInfo['hour'] = 12;
			$dateInfo['hour'] = 0;
		}

		if (empty($dateInfo['minute']) OR !intval($dateInfo['minute']) OR (intval($dateInfo['minute']) > 60) OR (intval($dateInfo['minute']) < 0))
		{
			$dateInfo['minute'] = 0;
		}

		if (empty($dateInfo['second']) OR !intval($dateInfo['second']) OR (intval($dateInfo['second']) > 60) OR (intval($dateInfo['second']) < 0))
		{
			 $dateInfo['second'] = 0;
		}

		$currentUserId = vB::getCurrentSession()->get('userid');
		if (!isset($userOffset[$currentUserId]))
		{
			$userOffset[$currentUserId] = $this->fetchTimeOffset();
		}

		$date = gmmktime($dateInfo['hour'], $dateInfo['minute'], $dateInfo['second'], $dateInfo['month'], $dateInfo['day'], $dateInfo['year']);
		/*
			For GMT => User time: Time + offset
			e.g. offset = -8 (PST), GMT -> PST: 7PM (GMT) + -8 (PST offset) = 11AM (PST)
			For User time => GMT: Time - offset
			e.g. offset = -5 (EST), EST -> GMT: 3PM (EST) - -5 (EST offset) = 8PM (GMT)
		 */
		return $date - $userOffset[$currentUserId];
	}

	/*
	 * Takes a readable time string and converts it to unixtimestamp (UTC)
	 *
	 * @param  string  $strTime  A well formated time string, e.g. "2016/12/31 11:59PM" "2017/01/01 12:00AM PST"
	 *
	 * @return  ['unixtimestamp' => int converted timestamp]
	 */
	public function userTimeStrToUnixtimestamp($strTime, $userid = false, $ignoreDST = true)
	{
		/*
			TODO: add unit tests for this & polltimeouts.
		 */

		/*
			Offset is strictly relative to GMT, NOT GMT + server time (as it was previously).
			strtotime() depends on system timezone. To skip dealing with any madness, we temporarily
			set the default timezone to UTC (in case $strTime actually has a timezone specified)
		 */
		$oldTz = date_default_timezone_get();
		date_default_timezone_set('UTC');

		$offset = $this->fetchTimeOffset($userid, $ignoreDST);
		$timestamp = intval(strtotime(trim(strval($strTime)))) - $offset;

		// set it back in case some other downstream logic requires the old system time back.
		date_default_timezone_set($oldTz);


		return ['unixtimestamp' => $timestamp];
	}

	/*
	 * Takes a unixtimestamp and converts it into a readable date/time string for the current user.
	 * Basically inverts userTimeStrToUnixtimestamp().
	 *
	 * @param  string  $timestamp  Unixtimestamp ("unadjusted" for user's offset)
	 * @param  int     $userid     Optional userid, if not for current user.
	 * @param  string  $format     Optional output date format.
	 * @param  bool    $ignoreDST  Optional Ignore DST for this render. Used for events.
	 * @param  string  $locale     Optional Locale to use for output formatting, if set in language.
	 *
	 * @return  ['datestr' => string converted datestring]
	 */
	public function unixtimestampToUserDateString(
		$timestamp,
		$userid = false,
		$format = "Y-m-d H:i:s",
		$ignoreDST = true,
		$locale = ''
	)
	{
		/*
			We basically pretend that the user is on GMT so that we can use gmdate() and
			forget about server timezone.
			For ex.
			2017-10-17 1:22PM PST = 1508271720
			2017-10-17 1:22PM GMT = 1508246520
			PST -> GMT = PST - 7 hours (aka + $offset).
			So if we want gmdate(timestamp) = 2017-10-17 1:22PM, we need to feed it the GMT time,
			which is + offset
		 */
		$offset = $this->fetchTimeOffset($userid, $ignoreDST);
		$timestamp = $timestamp + $offset;

		if (!empty($locale))
		{
			$format = $this->dateUtil->convertFormat('gmstrftime', $format);
			$this->tempSetLocale($locale);
			$datestr = gmstrftime($format, $timestamp);
			$this->revertLocale();
		}
		else
		{
			$format = $this->dateUtil->convertFormat('gmdate', $format);
			$datestr = gmdate($format, $timestamp);
		}

		return ['datestr' => $datestr];
	}

	// taken from runtime::vbdate()
	private function tempSetLocale($locale)
	{
		if (empty($this->currentlocale))
		{
			$this->currentlocale = setlocale(LC_TIME, 0);
		}
		setlocale(LC_TIME, $locale);
		if (substr($locale, 0, 5) != 'tr_TR')
		{
			setlocale(LC_CTYPE, $locale);
		}
	}

	// taken from runtime::vbdate()
	private function revertLocale()
	{
		setlocale(LC_TIME, $this->currentlocale);
		// not sure what this is about, but taken from vbdate()
		if (substr($this->currentlocale, 0, 5) != 'tr_TR')
		{
			setlocale(LC_CTYPE, $this->currentlocale);
		}
	}

	private function sanitizeUserInfo($userInfo, $currentUserId)
	{
		$userInfo = $this->stripPrivateUserFields($userInfo);

		$noUserOnlyFields = (($userInfo['userid'] != $currentUserId) AND !$this->hasAdminPermission('canadminusers'));
		if ($noUserOnlyFields)
		{
			$userInfo = $this->blankUserOnlyFields($userInfo);
		}

		//blank coppa only fields
		if ($noUserOnlyFields OR !$this->useCoppa() OR empty($userInfo['birthday']) OR !$this->needsCoppa($userInfo['birthday']))
		{
			$userInfo['coppauser'] = '';
			$userInfo['parentemail'] = '';
		}

		return $userInfo;
	}

	/**
	 * Strips fields that should *never* be returned by the API.  Full stop. Don't do it.
	 * not even if the user is a super special mega admin.
	 *
	 * @param $userInfo
	 * @return The user info array without the private fields.
	 */
	private function stripPrivateUserFields($userInfo)
	{
		$fields = ['token', 'scheme', 'secret', 'securitytoken_raw', 'rememberme_secret',];
		foreach ($fields AS $field)
		{
			unset($userInfo[$field]);
		}
		return $userInfo;
	}

	/**
	 * Blank fields that only the user themselves should see.  We can also allow admins with the
	 * correct privs to see those too.  Note that this function doesn't actually check
	 * if the user should be able to see them, it just blanks them out.
	 *
	 * This doesn't actually remove the keys from the array in order to provide a consistant
	 * array format regardless of the user's permissions.
	 *
	 * @param $userInfo
	 * @return The user info array without the user fields set to ''
	 */
	private function blankUserOnlyFields($userInfo)
	{
		$fields = [
			'coppauser', 'parentemail', 'passworddate', 'ipaddress', 'passworddate', 'email', 'referrerid',
			'ipoints', 'infractions', 'warnings', 'infractiongroupids', 'infractiongroupid', 'logouthash', 'securitytoken',
			'location'
		];

		foreach ($fields AS $field)
		{
			$userInfo[$field] = '';
		}

		return $userInfo;
	}

	/**
	 * Updates guest privacy consent
	 *
	 * @param bool True if consenting, false otherwise
	 */
	public function updateGuestPrivacyConsent($consent)
	{
		$this->library->updateGuestPrivacyConsent($consent);
		return ['success' => true];
	}

	public function checkPrivacyOption($option)
	{
		$userInfo = $this->library->fetchUserinfo();
		$required = $this->library->checkPrivacyOption($option, $userInfo['location']);
		return ['required' => $required];
	}

	/**
	 * Set privacy consent and for the current user if needed.
	 */
	public function setCurrentUserPrivacyConsent()
	{
		$userInfo = $this->library->fetchUserinfo();

		//we *really* don't want to process this for guests.
		if ($userInfo['userid'] < 1)
		{
			throw new vB_Exception_Api('invalid_data_w_x_y_z', [$userInfo, 'userid', __CLASS__, __FUNCTION__]);
		}

		//we need to be clear on whether we're checking the consent status based on the IP address on save
		//or the existing user location.  At present we'll update the location on save based on the current
		//IP so we're checking based on that and this needs to match.
		$location = $this->library->getIpLocation(vB::getRequest()->getIpAddress());
		$required = $this->library->checkPrivacyOption('enable_privacy_registered', $location);
		if ($required AND $userInfo['privacyconsent'] != 1)
		{
			//only attempt to save if we're planning to change something.
			return $this->save(
				$userInfo['userid'],
				null,
				['privacyconsent' => 1],
				[],
				[],
				[],
				[],
				[],
				['acnt_settings' => 1]
			);
		}

		//we don't really use the return value anywhere but let's be
		//consistant with the save call above which is what's we've previsiously returned
		return $userInfo['userid'];
	}

	public function clearFlagForDelete()
	{
		$userInfo = $this->library->fetchUserinfo();

		//we *really* don't want to process this for guests.
		if ($userInfo['userid'] < 1)
		{
			throw new vB_Exception_Api('invalid_data_w_x_y_z', [$userInfo, 'userid', __CLASS__, __FUNCTION__]);
		}

		if ($userInfo['privacyconsent'] == -1)
		{
			// If we're checking this and the user is marked for delete then we want to clear that.
			// but don't set to "consented" because we aren't in a location that requires that (and
			// therefore we didn't show the consent language to the user
			return $this->save(
				$userInfo['userid'],
				null,
				['privacyconsent' => 0],
				[],
				[],
				[],
				[],
				[],
				['acnt_settings' => 1]
			);
		}

		return ['success' => true];
	}


	/**
	 *	Returns a report on "personal information" for a user
	 *
	 *	This is the personally identifiable information for
	 *	privacy laws.  Currently this follows our best understanding
	 *	of the EU law, but eventually this may end up being a superset
	 *	of all simpilar laws.
	 *
	 *	@param $userid (optional)
	 *	@return array of information. See the library function for full listing.
	 */
	public function getPersonalData($userid = 0)
	{
		$userid = (int) $userid;
		$currentUserId = vB::getCurrentSession()->get('userid');

		// if no userid passed, use current user
		if ($userid < 1)
		{
			$userid = $currentUserId;
		}

		// check for guest/invalid userid
		if ($userid < 1)
		{
			throw new vB_Exception_Api('invalid_data_w_x_y_z', [$userid, 'userid', __CLASS__, __FUNCTION__]);
		}

		// a user can view their own personal data, and an admin with
		// the proper permission can view others' personal data.
		if ($userid !== $currentUserId)
		{
			$this->checkHasAdminPermission('canadminusers');
		}

		// if we've gotten this far, this is a logged in user asking for their own personal
		// data or an admin with permission to admin users.
		return $this->library->getPersonalData($userid);
	}

	/**
	 * Verifies that a flash message passed through the URL is signed and valid
	 *
	 * @param string Phrase key
	 * @param string Timestamp for the securitytoken
	 * @param string The hash sha1(phrase + securitytoken)
	 *
	 * @return array Returns success=>true in the array if the message is valid.
	 */
	public function verifyFlashMessageSignature($phrase, $timestamp, $hash)
	{
		// The user API may not be the best home for this function, but
		// I choose to put it here for now since it's closely related
		// to user information (the securitytoken), and needs to have
		// access to user information before it is sanitized, namely the
		// raw security token.

		// For an overview of how the flashMessage system works, see:
		// vB5_Frontend_Controller::encodeFlashMessage()
		// vB5_Template::decodeFlashMessage()
		// vB_Api_User::verifyFlashMessageSignature()
		// displayFlashMessage() in global.js

		$success = false;

		$session = vB::getCurrentSession();
		$userinfo = $session->fetch_userinfo();
		$securitytoken_prev = $timestamp . '-' . sha1($timestamp . $userinfo['securitytoken_raw']);

		$testHash = substr(sha1($phrase . $securitytoken_prev), -10);

		if ($hash === $testHash)
		{
			$success = true;
		}

		return ['success' => $success];
	}

	/**
	 * Saves the content entry UI editor "state" where state is the show/hide state
	 * of the following 3 content entry UIs: ckeditor toolbar, attachements panel,
	 * and smilies panel.
	 *
	 * @param string Action -- 'add' (the panel is visible) or 'remove' (the panel is hidden)
	 * @param int The int bit value to add or remove from the editorstate. 1=toolbar, 2=attachments, 4=smilies
	 *
	 * @return array Array containing success and the current editor state
	 */
	public function saveEditorState($action, $value)
	{
		// 'add' or 'remove'
		$action = (string) $action;
		// 1=toolbar, 2=attachments, 4=smilies
		$value = (int) $value;

		$currentUserId = vB::getCurrentSession()->get('userid');

		// check for guest/invalid userid
		if ($currentUserId < 1)
		{
			throw new vB_Exception_Api('not_logged_no_permission');
		}

		// save it
		$assertor = vB::getDbAssertor();

		$params = [
			'editorstatevalue' => $value,
			'userid' => $currentUserId,
		];

		if ($action == 'add')
		{
			$assertor->assertQuery('vBforum:addUserEditorState', $params);
		}
		else
		{
			$assertor->assertQuery('vBforum:removeUserEditorState', $params);
		}

		$conditions = ['userid' => $currentUserId];
		$state = $assertor->getColumn('user', 'editorstate', $conditions);
		$state = reset($state);

		return [
			'success' => true,
			'editorstate' => $state,
		];
	}

	//
	// Custom User Profile Field Functions
	//

	public function saveProfileFieldDefinition($profilefield)
	{
		$this->checkHasAdminPermission('canadminusers');
		$id = $this->library->saveProfileFieldDefinition($profilefield);
		return ['profilefieldid' => $id];
	}

	public function getNamecardInfoBulk($userids)
	{
		/*
		Currently, this isn't any more efficient than just calling getNamecardInfo()
		one by one. It only exists as a convenient wrap in the few places we need to
		call getNamecardInfo() for a small list of users.

		I initially added the wrapper to use for the register namecards & bulk namecard
		rendering that we ended up scrapping. As such I did not find optimizing a bulk
		fetch worthwhile. Currently we're using the bulk fetch in only two places:
		multi-answer nodes (edge case) and pmchat. In either cases, we're not expecting
		more than order of 10 users, and those user info are probably fetched as part of
		something else and cached at the vB_User level.

		However, if it turns out we need it, we will want to implement a "proper" generic
		bulk fetchUserInfos() method in the vB_User class.
		The two current candidates that seem like they were supposed to do bulk fetch
		userinfos are vB_Library_User::preloadUserInfo() &
		vB_Library_User::getUserInfoRecords() but, per comments left above their
		declarations, they don't quite match the standard user info so aren't meant for
		generic bulk userinfo fetching that we need in a lot of places.

		We might be able to get away with just fetching specific columns for user infos
		that are not already cached, but that will be difficult to upkeep if we need more
		computed user fields (like musername, currently) that will likely require copying
		more and more code from the vB_User fetch logic anyways. As such, if performance
		needs arise I recommend we properly implement a vB_User::fetchUserInfos() method
		rather than a 3rd one-off bulk fetch method.
		 */
		$data = [];
		foreach ($userids AS $userid)
		{
			['info' => $data[$userid]] = $this->getNamecardInfo($userid);
		}

		return ['infos' => $data];
	}

	public function getNamecardInfo($userid)
	{
		$phraseapi = vB_Api::instanceInternal('phrase');
		$guest = $phraseapi->fetch(['guest', 'guest_avatar',]);
		$guest = $guest['guest'] ?? 'Guest';
		$cardinfo = [
			'userid' => 0,
			'displayname' => $guest,
			'displayname_safe' => $guest,
			'username' => $guest,
			'profileurl' => '',
			'posts' => 0,
			'online' => 'offline',
			'usertitle' => '',
			'lastactivity' => 0,
			'joindate' => 0,
		];

		$currentUserId = vB::getCurrentSession()->get('userid');
		$currentContext = vB::getUserContext();
		$canViewMembers = $currentContext->hasPermission('genericpermissions', 'canviewmembers');

		// This method used to only provide a tiny subset of the overall user info, but due to
		// feedback/request we're putting more information available on the namecard. As such, this
		// function has morphed into a wrapper for the fetchProfileInfo() that does some logic
		// that otherwise would be done in the template (e.g. see profile sidebar template)...
		if (!empty($userid))
		{
			// I don't think this is strictly necessary, because the exception below would occur
			// before the assignment to $cardinfo can happen, but just in case let's make the
			// fallback logic explicit.
			$guestcardinfo = $cardinfo;
			try
			{
				$cardinfo = $this->fetchProfileInfo($userid);
				// This can happen if $userid is invalid, and fetchProfileInfo() doesn't happen to hit the particular
				// code branches that throws exceptions on invalid user data. In particular, if you view as guest
				// it seems to by some of those.
				if (empty($cardinfo['userid']))
				{
					$cardinfo = $guestcardinfo;
				}
			}
			catch (vB_Exception_Api $e)
			{
				// I haven't figured out how yet, but sometimes the namecard can be called on users that were
				// presumably deleted or otherwise does not exist. Currently that generates an exception downstream
				// of fetchProfileInfo(). In that case, let's just return the guest card info.
				$cardinfo = $guestcardinfo;
			}
		}

		//this will now provide the correct result even when the userid is not valid.
		$cardinfo['avatar'] = $this->fetchAvatar($userid, 'profile');

		if (!empty($cardinfo['userid']))
		{
			$profileurl = vB5_Route::buildUrl('profile|fullurl', ['userid' => $userid, 'username' => $cardinfo['username']]);
			$cardinfo['displayname_safe'] = $cardinfo['musername'];
			$cardinfo['profileurl'] = $profileurl;

			$notSelf = ($currentUserId != $cardinfo['userid']);
			$cardinfo['showuserux'] = (!empty($currentUserId) AND $notSelf);

			if (!empty($currentUserId) AND $canViewMembers)
			{
				// TODO: what else should we lock behind canviewmembers?
				// Subscribe UI.
				$canUseFriends = $currentContext->hasPermission('genericpermissions2', 'canusefriends');
				$isFollowing = vB_Api::instanceInternal('follow')->isFollowingUser($cardinfo['userid']);
				$canSubscribe = ($canUseFriends AND $notSelf);
				$cardinfo['isFollowing'] = $isFollowing;
				$cardinfo['canUseFriends'] = $canUseFriends;
				$cardinfo['canSubscribe'] = $canSubscribe;
			}
		}

		return ['info' => $cardinfo];
	}

	public function ignoreUser($userid, $add = true)
	{
		$currentUserId = vB::getCurrentSession()->get('userid');
		if (!$currentUserId)
		{
			throw new vB_Exception_Api('no_permission_logged_out');
		}

		$assertor = vB::getDbAssertor();
		$username = $assertor->getColumn('user', 'username', ['userid' => $userid]);
		if ($currentUserId == $userid OR !$username)
		{
			throw new vB_Exception_Api('invalid_data_w_x_y_z', [$userid, 'userid', __CLASS__, __FUNCTION__]);
		}

		$curUserInfo = vB_User::fetchUserinfo($currentUserId);

		// This is kind of painful.. we store the userlist in DB as userids but api save & frontend expect
		// CSV usernames... we should just switch them all over to userids for everything except frontend display-only.
		$userids = explode(' ', $curUserInfo['ignorelist']);
		$key = array_search($userid, $userids);
		if ($add AND $key !== false OR !$add AND $key === false)
		{
			// Just quietly return if we don't have to make changes
			return [
				'success' => true,
				'skipped' => true,
			];
		}

		if ($add)
		{
			$userids[] = $userid;
		}
		else
		{
			unset($userids[$key]);
		}

		$usernames =  $this->library->fetchUserNames($userids);
		$newignorelist = implode(',', $usernames);
		$save = $this->save($currentUserId, '', ['ignorelist' => $newignorelist, ], [], [], []);

		return [
			'success' => true,
			'ignorelist' => $newignorelist,
		];
	}

	public function isIgnoringUser($userid, $nocache=false)
	{
		$currentUserId = vB::getCurrentSession()->get('userid');
		if (!$currentUserId)
		{
			throw new vB_Exception_Api('no_permission_logged_out');
		}

		$assertor = vB::getDbAssertor();
		$username = $assertor->getColumn('user', 'username', ['userid' => $userid]);
		if (!$username)
		{
			throw new vB_Exception_Api('invalid_data_w_x_y_z', [$userid, 'userid', __CLASS__, __FUNCTION__]);
		}

		$curUserInfo = vB_User::fetchUserinfo($currentUserId, [], false, $nocache);
		$userids = explode(' ', $curUserInfo['ignorelist']);
		$key = array_search($userid, $userids);

		return ['ignoring' => $key !== false, ];
	}

	public function changeUserRelation($userid, $action)
	{
		// This wraps a few functions for namecard buttons so we don't have to change
		// the follow API signatures that others are dependent on.

		$followApi = vB_Api::instanceInternal('follow');
		$followResponse = 0;
		switch ($action)
		{
			case 'add':
				$followResponse = $followApi->add($userid, 'follow_members');
				break;
			case 'delete':
				$followResponse = $followApi->delete($userid, 'follow_members');
				break;
			default:
				throw new vB_Exception_Api('invalid_data_w_x_y_z', [$action, 'action', __CLASS__, __FUNCTION__]);
				break;
		}

		// If we just started following a user, that clears the ignorelist, but we may have a local cache that needs to be refreshed.
		// Force nocache re-fetch from db.
		$ignoring = $this->isIgnoringUser($userid, true);

		return [
			'success' => true,
			'follow' => $followResponse,
			'ignoring' => $ignoring['ignoring'],
		];
	}
}

/*=========================================================================*\
|| #######################################################################
|| # Downloaded: 12:50, Tue Dec 24th 2024
|| # CVS: $RCSfile$ - $Revision: 117908 $
|| #######################################################################
\*=========================================================================*/
