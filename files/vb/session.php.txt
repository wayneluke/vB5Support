<?php
/*========================================================================*\
|| ###################################################################### ||
|| # vBulletin 6.1.0 Alpha 4 Week 2 - Licence Number VBCW2VFT7A
|| # ------------------------------------------------------------------ # ||
|| # Copyright 2000-2024 MH Sub I, LLC dba vBulletin. All Rights Reserved.  # ||
|| # This file may not be redistributed in whole or significant part.   # ||
|| # ----------------- VBULLETIN IS NOT FREE SOFTWARE ----------------- # ||
|| # http://www.vbulletin.com | http://www.vbulletin.com/license.html   # ||
|| ###################################################################### ||
\*========================================================================*/

/**
* Class to handle sessions
*
* Creates, updates, and validates sessions; retrieves user info of browsing user
*
* @package	vBulletin
*/
abstract class vB_Session
{
	use vB_Trait_NoSerialize;

	/**
	 *
	 * @var vB_dB_Assertor
	 */
	protected $dBAssertor = null;

	/**
	 *
	 * @var vB_Datastore
	 */
	protected $datastore = null;

	/**
	 * @var array
	 */
	protected $config;

	/**
	* The individual session variables. Equivalent to $session from the past.
	*
	* @var	array
	*/
	protected $vars = [];

	//arbitrary data to be stored as part of the session
	protected $data = [];
	protected $cookietimeout ;
	protected $rememberMeToken = '';

	/**
	* A list of variables in the $vars member that are in the database. Includes their types.
	*
	* @var	array
	*/
	protected $db_fields = [
// 	we handle the sessionhash value specially
//		'sessionhash'   => vB_Cleaner::TYPE_STR,
		'userid'        => vB_Cleaner::TYPE_INT,
		'host'          => vB_Cleaner::TYPE_STR,
		'idhash'        => vB_Cleaner::TYPE_STR,
		'lastactivity'  => vB_Cleaner::TYPE_INT,
		'location'      => vB_Cleaner::TYPE_STR,
		'styleid'       => vB_Cleaner::TYPE_INT,
		'languageid'    => vB_Cleaner::TYPE_INT,
		'loggedin'      => vB_Cleaner::TYPE_INT,
		'badlocation'   => vB_Cleaner::TYPE_INT,
		'useragent'     => vB_Cleaner::TYPE_STR,
		'apiclientid'   => vB_Cleaner::TYPE_INT,
		'apiaccesstoken'=> vB_Cleaner::TYPE_STR,
		'emailstamp'    => vB_Cleaner::TYPE_INT,
		'wol'           => vB_Cleaner::TYPE_ARRAY,
		'location'      => vB_Cleaner::TYPE_STR,
		'pagekey'       => vB_Cleaner::TYPE_STR,
	];

	/**
	* An array of changes. Used to prevent superfluous updates from being made.
	*
	* @var	array
	*/
	protected $changes = [];

	/**
	* Whether the session was created or existed previously
	*
	* @var	bool
	*/
	// todo: this is a public attribute to avoid breaking some references that even set this value.
	// Replace with getter and check if we can avoid setting this outside the class constructor.
	public $created = false;

	/**
	* Information about the user that this session belongs to.
	*
	* @var	array
	*/
	protected $userinfo = null;

	/*
	 * This should *never* change during a session
	 * @var string
	 */
	protected $sessionIdHash = null;

	/**
	 * cpsessionhash is a special session hash for admins and moderators
	 *
	 * @var string
	 */
	protected $cpsessionHash = '';


	/**
	* Constructor. Attempts to grab a session that matches parameters, but will create one if it can't.
	*
	*	@param vB_DB_Assertor $dBAssertor
	*	@param vB_Datastore $datastore
	*	@param array $config -- vBulletin config array
	*
	* @param string Previously specified sessionhash
	*	@param array $restoreSessionInfo -- Information to handle "remember me" logic.
	*		* remembermetoken -- Token value for "remember me".  Stored in the "password" cookie for legacy reasons.  There are
	*			so special values to indicate that we should reauthentic via a method other than the internal vB remember me
	*			system.
	*		* userid -- user we are remembering
	*		* fbsr_{appid} (optional) -- Only valid if facebook is enabled, and only used if "remembermetoken" is "facebook".
	* @param	integer		Style ID for this session
	* @param	integer		Language ID for this session
	*/
	protected function __construct(
		&$dBAssertor,
		&$datastore,
		&$config,
		$sessionhash = '',
		$restoreSessionInfo = [],
		$styleid = 0,
		$languageid = 0,
		$deferRememberMe = false
	)
	{
		$this->dBAssertor = & $dBAssertor;
		$this->datastore = & $datastore;
		$this->config = & $config;
		$request = vB::getRequest();

		if (isset($restoreSessionInfo['userid']))
		{
			$restoreSessionInfo['userid'] = intval($restoreSessionInfo['userid']);
		}
		$styleid = intval($styleid);
		$languageid = intval($languageid);

		$this->createSessionIdHash();

		if (!$this->loadExistingSession($sessionhash, $restoreSessionInfo, $deferRememberMe))
		{
			// We were unable to find a live session from $sessionhash, and restoresession either
			// failed or was deferred. Create a new guest session for now.
			$this->vars = $this->fetch_session(0);
			$this->created = true;
		}

		// deferRememberMe also disables finalize, as finalize needs to wait until
		// we have the proper user session for privacy consent location checks

		if (!$deferRememberMe)
		{
			$this->finalize($styleid, $languageid);
		}
	}

	protected function createSessionIdHash()
	{
		// API session idhash won't have User Agent compiled.
		$this->sessionIdHash = md5($this->fetch_substr_ip(vB::getRequest()->getAltIp()));
	}

	protected function loadExistingSession($sessionhash, $restoreSessionInfo, $deferRememberMe = false)
	{
		$gotsession = false;

		// try to fetch stored session first and save it in $this->vars
		if ($this->fetchStoredSession($sessionhash, $restoreSessionInfo))
		{
			$gotsession = true;
			$this->created = false;

			// found a session - get the userinfo
			if (!empty($this->vars['userid']))
			{
				$useroptions = [];
				if (defined('IN_CONTROL_PANEL'))
				{
					$useroptions[] = vB_Api_User::USERINFO_ADMIN;
					$userinfo = vB_Library::instance('user')->fetchUserinfo(
						$this->vars['userid'],
						$useroptions,
						(!empty($languageid) ? $languageid : $this->vars['languageid'])
					);
				}
				else if (!empty($this->data['userinfo']))
				{
					$userinfo = &$this->data['userinfo'];
				}
				else
				{
					$userinfo = vB_Library::instance('user')->fetchUserWithPerms(
						$this->vars['userid'],
						(!empty($languageid) ? $languageid : $this->vars['languageid'])
					);
				}

				$this->userinfo = &$userinfo;

			}
		}

		if (!$deferRememberMe)
		{
			//if $gotsession is already true because we found a guest session we don't want to set it to false here --
			//instead we should reuse the existing guest session if the remember me attempt fails.
			if ($this->doRememberMe($restoreSessionInfo, $gotsession))
			{
				$gotsession = true;
			}
		}

		return $gotsession;
	}

	public function doRememberMe($restoreSessionInfo, $gotsession = true)
	{
		if ($gotsession == false OR empty($this->vars['userid']))
		{
			// try to use remember me
			$useroptions = [];
			if (defined('IN_CONTROL_PANEL'))
			{
				$useroptions[] = 'admin';
			}

			/*
				vB_Session_Api note:
				VBV-12249: API session will always pass in "true" for this, as to preserve
				the behavior of always trying to fetch old session info from the information
				found in the apiclient table. If we got this far, that means they passed
				vB_Session_Api::validateApiSession(), so this should be safe.
			*/
			if (!empty($restoreSessionInfo['remembermetoken']))
			{
				if ($restoreSessionInfo['remembermetoken'] == 'facebook')
				{
					$result = $this->rememberFacebook($restoreSessionInfo, $useroptions);
				}
				else
				{
					$result = $this->rememberSession($restoreSessionInfo, $useroptions);
				}

				$gotsession = $result['auth'];
				$this->rememberMeToken = $result['remembermetoken'];
			}
		}

		return $gotsession;
	}

	public function finalize($styleid = 0, $languageid = 0)
	{
		$styleid = intval($styleid);
		$languageid = intval($languageid);

		// Agh, request back-dependency, but hopefully nothing referenced below causes circular logic.
		$request = vB::getRequest();

		//if we got user info, check to make sure the EU status is correct.
		if ($this->userinfo AND $this->userinfo['userid'] > 0)
		{
			if (vB_Library::instance('options')->isLocationOptionSet('enable_privacy_registered'))
			{
				//if we don't know the user's status, we need to look it up because
				//it could be a user that we haven't updated the status for yet.
				//it's possible that this because we can't determine it, in which case
				//we'll rely on the local ip caching to avoid spamming the geoip service
				//But if it's because we haven't look it up yet we need to know the
				//answer because it affects what info we show to the user.
				if (!$this->userinfo['location'] OR $this->userinfo['location'] == 'UNKNOWN')
				{
					$ipaddress = $request->getIpAddress();
					$location = vB_Library::instance('user')->getIpLocation($ipaddress);

					if ($location != 'UNKNOWN')
					{
						$this->userinfo['location'] = $location;

						//we can't call the save function here, it's just not going to work
						//we *need* to get the user load logic out of session, the dependency
						//chain is a nightmare.  But that's going to involve a lot of changes.
						$this->dBAssertor->update('user', ['location' => $location], ['userid' => $this->userinfo['userid']]);
					}
				}
			}
		}

		// Below used to be part of the constructor. Moved to finalize() to allow for hook injection
		// between sessionhash restore & remember me logic outside of session construction.

		$this->vars['dbsessionhash'] = $this->vars['sessionhash'];

		$this->set('styleid', $styleid);
		$this->set('languageid', $languageid);

		//This can apparently happen in when we hit an error while creating the session but it's not
		//clear that we really need this in that case.  In particular when hitting an exception in the
		//API session validateApiSession function.
		if ($this->created == false)
		{
			$this->set('useragent', $request->getUserAgent());
			$this->set('lastactivity', $request->getTimeNow());
			if (!defined('LOCATION_BYPASS') AND defined('WOLPATH'))
			{
				$this->set('location', WOLPATH);
			}
		}
	}

	// called from loadExistingSession
	// check vB_Session_Api for different behavior
	protected function fetchStoredSession($sessionhash, $restoreSessionInfo = [])
	{
		$this->cookietimeout = $this->datastore->getOption('cookietimeout');
		if ($sessionhash)
		{
			$request = vB::getRequest();
			$sessionHostSubstr = $this->fetch_substr_ip($request->getSessionHost());
			$sessionRecord = $this->dBAssertor->getRow('session',
				[
					vB_dB_Query::CONDITIONS_KEY => [
						[
							'field' => 'sessionhash',
							'value'	=> $sessionhash,
							'operator' => vB_dB_Query::OPERATOR_EQ
						],
						[
							'field' => 'lastactivity',
							'value' => ($request->getTimeNow() - $this->cookietimeout),
							'operator' => vB_dB_Query::OPERATOR_GT
						],
					]
				]
			);


			if ($sessionRecord AND ($sessionRecord['idhash'] === $this->getSessionIdHash()))
			{
				$this->vars = $sessionRecord;
			}
			else if (
				!empty($restoreSessionInfo['tryagain_apiclient']) AND
				!empty($sessionRecord['apiaccesstoken'])
			)
			{
				/*
					Mobile clients can have agent mismatches between
					requests. For example, on the android app, a showthread
					api.php call may show "Android" as the useragent, then
					something else entirely for the subsequent filedata/fetch
					calls for attachment images in that thread show "Dalvik/..."
					as the agent.
					In that case, let's check if there's an apiclient associated
					with this sessionhash, just compare session.ip with requester's
					ip.
					Note that there is not an uptodate ip record on the apiclient table,
					only the session table. `apiclient`.`initialipaddress` is set once
					per init, not updated per request.
				 */
				$apiclientRecord = $this->dBAssertor->getRow('apiclient',
					[
						vB_dB_Query::CONDITIONS_KEY => [
							[
								'field' => 'apiaccesstoken',
								'value'	=> $sessionRecord['apiaccesstoken'],
								'operator' => vB_dB_Query::OPERATOR_EQ
							],
						]
					]
				);
				if (!empty($apiclientRecord['apiclientid']))
				{
					// This check is exactly the same as below, but coded like this to preserve
					// the previous behavior (as much as possible) of not setting $this->vars
					// if idhash check failed.
					if ($this->fetch_substr_ip($sessionRecord['host']) == $sessionHostSubstr)
					{
						$this->vars = $sessionRecord;
						return true;
					}
				}
			}

			return ($this->vars AND $this->fetch_substr_ip($this->vars['host']) == $sessionHostSubstr);
		}
		else
		{
			return false;
		}
	}

	/**
	 *	Attempt to create a new session for the user without asking for a new login
	 *
	 * 	This uses various cookie information to revalidate a user without asking for a new
	 * 	login.  This is triggered wh
	 *
	 *  @param array $restoreSessionInfo -- restore array that was passed to the constructor (and is documented there)
	 *  @param array $useroptions -- User options to pass to fetchUserinfo
	 */
	protected function rememberSession($restoreSessionInfo, $useroptions)
	{
		if (!empty($restoreSessionInfo['userid']))
		{
			$userinfo = $this->fetchUserForRemember($restoreSessionInfo['userid'], $useroptions);
			if ($userinfo)
			{
				$result = vB_Library::instance('login')->verifyRememberMeFromInfo($userinfo, $restoreSessionInfo['remembermetoken']);
				if ($result['auth'])
				{
					// combination is valid
					if (!empty($this->vars['sessionhash']))
					{
						$this->dBAssertor->delete('session', ['sessionhash' => $this->vars['sessionhash']], true);
					}

					$this->vars = $this->fetch_session($userinfo['userid']);
					$this->created = true;
					$this->userinfo =& $userinfo;

					return $result;
				}
			}
		}

		return ['auth' => false, 'remembermetoken' => ''];
	}

	/**
	 *	Attempt to create a new session for the user from facebook
	 *
	 * 	This uses various cookie information to revalidate a user without asking for a new
	 * 	login.  This is triggered wh
	 *
	 *  @param array $restoreSessionInfo -- restore array that was passed to the constructor (and is documented there)
	 *  @param array $useroptions -- User options to pass to fetchUserinfo
	 */
	protected function rememberFacebook($restoreSessionInfo, $useroptions)
	{
		$failure = array ('auth' => false, 'remembermetoken' => '');

		$fblib = vB_Library::instance('facebook');
		if (!$fblib->isFacebookEnabled())
		{
			return $failure;
		}

		if (empty($restoreSessionInfo['userid']) OR empty($restoreSessionInfo['fb_signed_request']))
		{
			return $failure;
		}

		$userinfo = $this->fetchUserForRemember($restoreSessionInfo['userid'], $useroptions);

		//if this fails for some reason just carry on as guest.
		try
		{
			$vbuserid = $fblib->createSessionForLogin(['signedrequest' => $restoreSessionInfo['fb_signed_request']]);
		}
		catch (Exception $e)
		{
			return $failure;
		}

		//make sure we have the right user
		if ($vbuserid != $restoreSessionInfo['userid'])
		{
			return $failure;
		}

		// combination is valid
		if (!empty($this->vars['sessionhash']))
		{
			$this->dBAssertor->delete('session', ['sessionhash' => $this->vars['sessionhash']], true);
		}

		$this->vars = $this->fetch_session($userinfo['userid']);
		$this->created = true;
		$this->userinfo =& $userinfo;

		return ['auth' => true, 'remembermetoken' => 'facebook'];
	}

	/**
	 *	Get the user info based on the useroptions
	 *
	 *	@return array user info array
	 */
	protected function fetchUserForRemember($userid, $useroptions)
	{
		// Not entire sure what this is about, but it shouldn't be this complicated.
		$languageid = (empty($this->vars['languageid']) ? 0 : $this->vars['languageid']);
		if (empty($useroptions))
		{
			$userinfo = vB_Library::instance('user')->fetchUserWithPerms($userid, $languageid);
		}
		else
		{
			$userinfo = vB_Library::instance('user')->fetchUserinfo($userid, $useroptions, $languageid);
		}
		return $userinfo;
	}

	/**
	 * Returns a new session of the type specified by defined constants
	 *
	 * @global array $VB_API_PARAMS_TO_VERIFY - Defined in api.php
	 * @global array $VB_API_REQUESTS - Defined in api.php
	 * @param vB_dB_Assertor $dBAssertor
	 * @param vB_Datastore $datastore
	 * @param array $config
	 * @param string $sessionhash
	 * @param int $userid
	 * @param string $password
	 * @param int $styleid
	 * @param int $languageid
	 * @return vB_Session
	 */
	//This is used to create a new session on logout as well as init.php if the session hasn't already been created.
	//This function is all kinds of problematic since it uses magic defines and global variables to handle some stuff and just assumes
	//that the caller has decided to set this up.
	public static function getNewSession(&$dBAssertor, &$datastore, &$config, $sessionhash = '', $userid = 0, $password = '', $styleid = 0, $languageid = 0)
	{
		if (defined('SKIP_SESSIONCREATE') AND SKIP_SESSIONCREATE)
		{
			$session = new vB_Session_Skip($dBAssertor, $datastore, $config, $styleid, $languageid);
		}
		else if (defined('VB_API') AND VB_API)
		{
			global $VB_API_PARAMS_TO_VERIFY, $VB_API_REQUESTS;
			$session = new vB_Session_Api($dBAssertor, $datastore, $config, $sessionhash, $VB_API_PARAMS_TO_VERIFY, $VB_API_REQUESTS);
		}
		else
		{
			$restoreSessionInfo = ['userid' => $userid, 'remembermetoken' => $password];
			$session = new vB_Session_Web($dBAssertor, $datastore, $config, $sessionhash, $restoreSessionInfo, $styleid, $languageid);
		}

		return $session;
	}

	/**
	 * Returns the sessionIdHash
	 * @return string
	 */
	public function getSessionIdHash()
	{
		return $this->sessionIdHash;
	}

	/**
	* Saves the session into the database by inserting it or updating an existing one.
	*/
	public function save()
	{
		//if this is a new session we want everything, otherwise just the stuff that changed.
		$changes = ($this->created ? $this->db_fields : $this->changes);

		$cleaned = [];
		//the value here is not reliable, only the key is meaningful
		foreach ($changes AS $fieldname => $unused)
		{
			//it's possible that a change isn't db field.  If so, ignore it.
			$cleantype = $this->db_fields[$fieldname] ?? null;
			if ($cleantype)
			{
				switch ($cleantype)
				{
					case vB_Cleaner::TYPE_INT:
						$clean = intval($this->vars[$fieldname] ?? 0);
						break;
					case vB_Cleaner::TYPE_ARRAY:
						$clean = serialize($this->vars[$fieldname] ?? []);
						break;
					case vB_Cleaner::TYPE_STR:
					default:
						// will be escaped by assertor
						$clean = $this->vars[$fieldname] ?? '';
						break;
				}
				$cleaned[$fieldname] = $clean;
			}
		}

		// not sure how sessionhas can be "blanked out" but since it wasn't used we removed it from the
		// db_fields and only populate it here.
		// old comment: since the sessionhash can be blanked out, lets make sure we pull from "dbsessionhash"
		$cleaned['sessionhash'] = $this->vars['dbsessionhash'];

		if ($this->created)
		{
			$this->dBAssertor->insertIgnore('session', $cleaned);
		}
		else
		{
			if (sizeof($cleaned) > 1)
			{
				$cleaned[vB_dB_Query::TYPE_KEY] = vB_dB_Query::QUERY_UPDATE;
				$this->dBAssertor->assertQuery('session', $cleaned);
			}
		}
	}

	/**
	 *	Deletes the session from the session store.
	 *
	 *	Deletes records matching the session's sessionhash.  If there is an apiaccesstoken then
	 *	sessions matching that are also deleted.
	 *
	 *	Will have no effect and no error if the session doesn't exist.
	 *
	 *	Sets the session to "not created", but does not otherwise affect the session object.
	 */
	public function delete()
	{
		//refactored from vB_User login code.  This is more general logic and should be part of the session obect
		//delete by sessionhash
		$this->dBAssertor->delete('session', ['sessionhash' => $this->get('dbsessionhash')]);

		//if we have an apiaccess token, nuke sessions matching that too
		$accesstoken = $this->get('apiaccesstoken');
		if ($accesstoken)
		{
			$this->dBAssertor->delete('session', ['apiaccesstoken' => $accesstoken]);
		}

		$this->created = false;
	}

	/**
	 * Sets a session variable and updates the change list.
	 * @param	string	Name of session variable to update
	 * @param	mixed	Value to update it with
	 */
	public function set($key, $value)
	{
		if (!isset($this->vars[$key]) OR $this->vars[$key] != $value)
		{
			$this->vars[$key] = $value;
			$this->changes[$key] = true;
		}
	}

	public function setChannelPerms($key, $perms)
	{
		if (empty($this->data['channelPerms']))
		{
			$this->data['channelPerms'] = ['userid' => $this->vars['userid'], $key => $perms];
		}
		else
		{
			if (empty($this->data['channelPerms'][$key]) OR ($this->data['channelPerms'][$key] != $perms))
			{
				$this->data['channelPerms'][$key] = $perms;
			}
		}
	}

	public function getChannelPerms($key)
	{
		if (isset($this->data['channelPerms']) AND isset($this->data['channelPerms'][$key]))
		{
			return $this->data['channelPerms'][$key];
		}
	}


	public function clearChannelPerms()
	{
		unset($this->data['channelPerms']);
	}


	public function getRememberMeToken()
	{
		return $this->rememberMeToken;
	}

	/**
	 * Gets a session variable.
	 *
 	 * @param	string - Name of session variable
	 * @return	mixed - Value of the key, NULL if not found
	 */
	public function get($key)
	{
		return $this->vars[$key] ?? null;
	}

	/**
	 * Returns whether the session was created
	 * @return bool
	 */
	public function isCreated()
	{
		return $this->created;
	}

	// this is used by templates class
	/**
	 * Returns an array with all session vars
	 * @return array
	 */
	public function getAllVars()
	{
		return $this->vars;
	}

	/**
	 * Fetches a valid sessionhash value, not necessarily the one tied to this session.
	 * @return	string	32-character sessionhash
	 */
	public function fetch_sessionhash()
	{
		return md5(uniqid(microtime(), true));
	}

	/**
	 * Returns the IP address with the specified number of octets removed
	 * @param	string	IP address
	 * @return	string	truncated IP address
	 */
	protected function fetch_substr_ip($ip)
	{
		$options = $this->datastore->getValue('options');
		$ipUtil = new vB_Utility_Ip();
		// 255.255.255.0 is the default for the ipcheck setting. This fallback
		// should only be needed for fresh installs.
		return $ipUtil->ipSubstring($ip, 4 - ($options['ipcheck'] ?? '255.255.255.0'));
	}

	/**
	* Fetches a default session. Used when creating a new session.
	*
	* @param	integer	User ID the session should be for
	*
	* @return	array	Array of session variables
	*/
	protected function fetch_session($userid = 0)
	{
		$sessionhash = $this->fetch_sessionhash();

		$request = vB::getRequest();

		$session = [
			'sessionhash'   => $sessionhash,
			'dbsessionhash' => $sessionhash,
			'userid'        => intval($userid),
			'host'          => (empty($request) ? '' : $request->getSessionHost()),
			'idhash'        => $this->getSessionIdHash(),
			'lastactivity'  => (empty($request) ? '' : $request->getTimeNow()),
			'location'      => (defined('LOCATION_BYPASS') OR !defined('WOLPATH')) ? '' : WOLPATH,
			'styleid'       => 0,
			'languageid'    => 0,
			'loggedin'      => intval($userid) ? 1 : 0,
			'badlocation'   => 0,
			'useragent'     => (empty($request) ? '' : $request->getUserAgent()),
		];

		return $session;
	}

	/**
	 * Loads basic language information
	 */
	private function loadLanguage()
	{
		//don't use the language library here to avoid circular dependencies.
		$allLanguages = $this->datastore->getValue('languagecache');
		// We don't change the vars languageid in this case however I think that may be an artifact of the way we
		// checked if the languageid existed previously (it was a guard on the array_key_exists before creating the helper function.
		// It seems like we should probably set to the default and/or set to the 1 value in this case (things are almost
		// certainly in a bad state at this point)
		if (!is_array($allLanguages))
		{
			$allLanguages = [];
		}

		$this->vars['languageid'] = $this->getLanguageId($allLanguages);

		// If we have the options set and we didn't change the user language id, then there is no need to reload.
		if (!empty($this->userinfo['lang_options']) AND $this->vars['languageid'] == $this->userinfo['languageid'])
		{
			return;
		}

		// map from the datastore to what the names traditionally are in the user info.
		// we assume that the datastore names are all valid column names for the fallback query
		// so if that changes we need to take care to fix the fallback.
		$languagefields = [
			'options' => 'lang_options',
			'languagecode' => 'lang_code',
			'charset' => 'lang_charset',
			'dateoverride' => 'lang_dateoverride',
			'timeoverride' => 'lang_timeoverride',
			'registereddateoverride' => 'lang_registereddateoverride',
			'calformat1override' => 'lang_calformat1override',
			'calformat2override' => 'lang_calformat2override',
			'eventdateformatoverride' => 'lang_eventdateformatoverride',
			'pickerdateformatoverride' => 'lang_pickerdateformatoverride',
			'logdateoverride' => 'lang_logdateoverride',
			'decimalsep' => 'lang_decimalsep',
			'thousandsep' => 'lang_thousandsep',
			'locale' => 'lang_locale',
		];

		// This should be defined at this point but if let's be senstive to things not working in this block of
		// code since we might need it to limp along in order to fix it.  In particular things might be wierd in
		// the installer/upgrader.
		$language = $allLanguages[$this->vars['languageid']] ?? null;
		if (!$language)
		{
			$language = $this->dBAssertor->getRow('language', [
				'languageid' => $this->vars['languageid'],
				vB_dB_Query::COLUMNS_KEY => array_keys($languagefields),
			]);

			//we did our best
			if (!$language)
			{
				// If we got here then there is no way trying to render a phrase is going to work
				throw new Exception('The requested language does not exist, reset via tools.php.');
			}
		}

		//convert options
		if (isset($language['options']))
		{
			$bitfields = $this->datastore->getValue('bf_misc_languageoptions');
			if (is_array($bitfields))
			{
				$lang_options = $language['options'];
				$language['options'] = [];
				foreach ($bitfields AS $key => $value)
				{
					$language['options'][$key] = (bool) ($lang_options & $value);
				}
			}
		}

		if (!empty($this->userinfo))
		{
			foreach ($languagefields AS $sourcefield => $infofield)
			{
				$this->userinfo[$infofield] = $language[$sourcefield] ?? '';
			}
			$this->userinfo['languageid'] = $this->vars['languageid'];
		}
		else
		{
			// I'm not really clear on what this case is for.
			foreach ($languagefields AS $sourcefield => $infofield)
			{
				$this->vars[$infofield] = $language[$sourcefield] ?? '';
			}
		}
	}

	private function getLanguageId(array $languageCache) : int
	{
		// not sure why we use array_key_exists instead of isset.  They aren't 100% identical in the ['key' => null] case
		// but isset is a more efficient if we don't have null values.

		// if the current set language exists then use it.
		if (array_key_exists($this->vars['languageid'], $languageCache))
		{
			return $this->vars['languageid'];
		}

		//we only get here if we've already calculated the language and changed it.  But 0 means "default" and we don't
		//so we overwrite the value with the user value instead of the other way around.  And there is no need to refresh
		//the language value.

		// If the language is already set for the user and that exists in the cache then use that value.  This mostly comes up
		// When we do a "set to default" (id 0) on the language after we've already set and calculated it.  In which case we don't
		// want to change it (even if it's not, technically, the default).
		if (!empty($this->userinfo['languageid']) AND array_key_exists($this->userinfo['languageid'], $languageCache))
		{
			return $this->userinfo['languageid'];
		}

		//otherwise set to the configured default if it's a valid value.
		$id = $this->datastore->getOption('languageid');
		if (array_key_exists($id, $languageCache))
		{
			return $id;
		}

		// If all else fails attempt to something.  Start with id 1, which is usually the default language installed.  If not just
		// return the first key in the language cache.  At this point something has gone sideways and we're just trying to get enough
		// of the system functional to allow the admin to use admincp or tools.php to fix it.
		if (array_key_exists(1, $languageCache))
		{
			return 1;
		}

		// If we don't have anything just return 1 and hope for the best.  We may want to look it up from the db in case
		// the language cache is just broken but we didn't do that before and it may be overkill.
		return array_key_first($languageCache) ?? 1;
	}

	/**
	 * Returns appropriate user info for the owner of this session.
	 * @return array -- Array of user information.
	 */
	public function &fetch_userinfo()
	{
		if ($this->userinfo)
		{
			$this->loadLanguage();
			return $this->userinfo;
		}
		else if ($this->vars['userid'] AND !defined('SKIP_USERINFO'))
		{
			//Unfortuately it's *really* easy to get into some code that needs the user info from the code we use to load the info.
			//This causes infinite recursion as we'll this case again and try to load the user info again.
			//Set the userinfo to some of the guest defaults to ensure that we *always* hit the first case the second time around.
			$this->userinfo = $this->getGuestDefaults();
			$this->loadUserInfo();
			return $this->userinfo;
		}
		else
		{
			// guest setup
			$this->userinfo = $this->getGuestDefaults();

			if (empty($this->userinfo['lang_options']))
			{
				$this->loadLanguage();
			}

			$this->userinfo['servertimediff'] = vB_User::calcUsertimeDiff($this->userinfo);

			if (!$this->userinfo['username'])
			{
				// We need a better way to handle this -- possibly by including the guest name in the language
				// datastore.  Having the library dependency here isn't ideal (but trying to look up the phrase
				// honoring language overrides logic also isn't ideal.
				// I'm not sure if we ever use the username field when we have a guest session.
				$name = '';
				try
				{
					$phrases = vB_Library::instance('phrase')->renderPhrasesNoShortcode(['guest' => 'guest']);
					$name = $phrases['guest'];
				}
				catch (Exception $e)
				{
					//if something goes wrong here just hard code everything
					$name = 'guest';
				}

				$this->userinfo['username'] = $name;
				$this->userinfo['displayname'] = $name;
			}

			//this needs to be down here because calling it will cause a loop.
			//we'll break the loop on the second call because the this->userinfo
			//is already set.
			$optionLib = vB_Library::instance('options');
			$location = 'UNKNOWN';
			if (
				$optionLib->isLocationOptionSet('enable_privacy_guest') OR
				$optionLib->isLocationOptionSet('enable_privacy_registered') OR
				$optionLib->isLocationOptionSet('block_eu_visitors')
			)
			{
				$request = vB::getRequest();
				$ipaddress = $request->getIpAddress();
				$location = vB_Library::instance('user')->getIpLocation($ipaddress);
			}

			$this->userinfo['location'] = $location;

			//keep the guest user in sync with regular users
			vB_User::fetchMusername($this->userinfo);
		}

		return $this->userinfo;
	}

	//basic guest default values.  The stuff that doesn't require any additional queries to fetch.
	private function getGuestDefaults()
	{
			$options = $this->datastore->getValue('options');
			$bf_misc_useroptions = $this->datastore->getValue('bf_misc_useroptions');

			// guest setup
			$userinfo = [
				'userid'             => 0,
				'usergroupid'        => 1,
				'displaygroupid'     => 1,
				'membergroupids'     => '',
				'username'           => (!empty($_REQUEST['username']) ? vB_String::htmlSpecialCharsUni($_REQUEST['username']) : ''),
				'displayname'        => '',
				'password'           => '',
				'email'              => '',
				'emailstamp'         => 0,
				'styleid'            => $this->vars['styleid'],
				'languageid'         => $this->vars['languageid'],
				'lastactivity'       => $this->vars['lastactivity'],
				'daysprune'          => 0,
				'timezoneoffset'     => $options['timeoffset'],
				'dstonoff'           => $options['dstonoff'],
				'showsignatures'     => 1,
				'showavatars'        => 1,
				'showimages'         => 1,
				'showusercss'        => 1,
				'dstauto'            => 0,
				'maxposts'           => -1,
				'startofweek'        => 1,
				'threadedmode'       => 0,
				'securitytoken'      => 'guest',
				'securitytoken_raw'  => 'guest',
				'lastvisit'          => null,
				'infractiongroupids' => '',
				'pmtotal'            => 0,
				'posts'              => 0,
			];

			$userinfo['options'] =
				$bf_misc_useroptions['showsignatures'] |
				$bf_misc_useroptions['showavatars'] |
				$bf_misc_useroptions['showimages'] |
				$bf_misc_useroptions['dstauto'] |
				$bf_misc_useroptions['showusercss'];

			return $userinfo;
	}


	/**
	 * Returns appropriate value from the user info array for the owner of this session.
	 *
	 * @return mix	value of user information.
	 */
	public function &fetch_userinfo_value($value)
	{
		$null = null;	// PHP will (can) complain if you return null by reference
		$userinfo = $this->fetch_userinfo();
		if (isset($userinfo[$value]))
		{
			return $userinfo[$value];
		}
		else
		{
			return $null;
		}
	}

	/**
	* Updates the last visit and last activity times for guests and registered users (differently).
	* Last visit is set to the last activity time (before it's updated) only when a certain
	* time has lapsed. Last activity is always set to the specified time.
	*
	* @param	integer	Time stamp for last visit time (guest only)
	* @param	integer	Time stamp for last activity time (guest only)
	* @return	array	Updated values for setting cookies (guest only)
	*/
	public function doLastVisitUpdate($lastvisit = 0, $lastactivity = 0)
	{
		$options = $this->datastore->getValue('options');
		$request = vB::getRequest();
		$timeNow = $request->getTimeNow();

		$cookies = [];

		// update last visit/activity stuff
		if ($this->vars['userid'] == 0)
		{
			// guest -- emulate last visit/activity for registered users by cookies
			if ($lastvisit)
			{
				// we've been here before
				$this->userinfo['lastactivity'] = ($lastactivity ? intval($lastactivity) : intval($lastvisit));

				// here's the emulation
				if ($timeNow - $this->userinfo['lastactivity'] > $options['cookietimeout'])
				{
					// update lastvisit
					$this->userinfo['lastvisit'] = $this->userinfo['lastactivity'];
					$cookies['lastvisit'] = $this->userinfo['lastactivity'];
				}
				else
				{
					// keep lastvisit value
					$this->userinfo['lastvisit'] = intval($lastvisit);
				}
			}
			else
			{
				// first visit!
				$this->userinfo['lastvisit'] = $timeNow;
				$cookies['lastvisit'] = $timeNow;
			}

			// lastactivity is always now
			$this->userinfo['lastactivity'] = $timeNow;
			$cookies['lastactivity'] = $timeNow;

			return $cookies;
		}
		else
		{
			if ($timeNow - $this->userinfo['lastactivity'] > $options['cookietimeout'])
			{
				// see if session has 'expired' and if new post indicators need resetting
				$this->dBAssertor->shutdownQuery('updateLastVisit',
						[
							'timenow' => $timeNow,
							'userid' => $this->userinfo['userid']
						],
						'lastvisit'
				);

				$this->userinfo['lastvisit'] = $this->userinfo['lastactivity'];
			}
			else
			{
				// if this line is removed (say to be replaced by a cron job, you will need to change all of the 'online'
				// status indicators as they use $userinfo['lastactivity'] to determine if a user is online which relies
				// on this to be updated in real time.
				$this->dBAssertor->update('user', ['lastactivity' => $timeNow], ['userid' => $this->userinfo['userid']], 'lastvisit');
			}

			// we don't need to set cookies for registered users
			return null;
		}
	}

	/**
	 * Create new cpsession for the user and insert it into database or fetch current existing one
	 *
	 * @param bool $renew Whether to renew cpsession hash (Create a new one and drop the old one)
	 *
	 * @return string The new cpsession hash
	 */
	public function fetchCpsessionHash($renew = false)
	{
		if (!$this->created)
		{
			// This has been in the code for a long time and the previous exception would reference a class that doesn't exist.
			// Moreover this shouldn't happen if the code is working properly so I'm not sure it's worth creating and maintaining
			// a phrase for it.
			throw new vB_Exception_Api('unexpected_error', ['Attempted to create a CP session without a base session']);
		}

		if ($this->cpsessionHash)
		{
			if (!$renew)
			{
				return $this->cpsessionHash;
			}
			else
			{
				// Drop the old cp session record
				$this->dBAssertor->delete('cpsession', ['hash' => $this->cpsessionHash]);
			}
		}

		$this->cpsessionHash = $this->fetch_sessionhash();
		$this->dBAssertor->insert('cpsession', [
			'userid' => $this->vars['userid'],
			'hash' => $this->cpsessionHash,
			'dateline' => vB::getRequest()->getTimeNow()
		]);

		return $this->cpsessionHash;
	}

	public function setCpsessionHash($cpsessionhash)
	{
		$this->cpsessionHash = $cpsessionhash;
	}

	/**
	 * Validate cpsession
	 *
	 * @param bool $updatetimeout Whether to update the table to reset the timeout
	 *
	 * @return bool
	 */
	public function validateCpsession($updatetimeout = true)
	{
		$vboptions = $this->datastore->getValue('options');
		$timenow = vB::getRequest()->getTimeNow();
		$usercontext = vB::getUserContext();

		// Only moderators can use the mog login part of login.php, for cases that use inlinemod but
		// don't have this permission return true
		if (!$usercontext->isModerator() OR !$vboptions['enable_inlinemod_auth'])
		{
			return true;
		}

		if (empty($this->cpsessionHash))
		{
			return false;
		}
		else
		{
			$timecutoff = ($vboptions['timeoutcontrolpanel'] ? intval($timenow - $vboptions['cookietimeout']) : intval($timenow - 3600));
			$cpsession = $this->dBAssertor->getRow('cpsession', [
				vB_dB_Query::CONDITIONS_KEY => [
					['field' => 'userid', 'value' => $this->vars['userid'], 'operator' => vB_dB_Query::OPERATOR_EQ],
					['field' => 'hash', 'value' => $this->cpsessionHash, 'operator' => vB_dB_Query::OPERATOR_EQ],
					['field' => 'dateline', 'value' => $timecutoff, 'operator' => vB_dB_Query::OPERATOR_GT],
				]
			]);

			if (!empty($cpsession))
			{
				if ($updatetimeout)
				{
					$this->dBAssertor->update("cpsession", ['dateline' => $timenow], ['userid' => $this->vars['userid'], 'hash' => $this->cpsessionHash]);
				}
				return true;
			}
		}

		return false;
	}

	/**
	 *	Process any additionl bookkeeping on login
	 */
	public function processNewLogin() {}

	/**
	 *	Process any additionl bookkeeping on logout
	 */
	public function processLogout() {}

	/**
	 * Clear user cached info. Primarily needed for cleaning cache in memory.
	 *
	 */
	public function clearUserInfo()
	{
		if (empty($this->vars['userid']))
		{
			return true;
		}

		// and reload for current session
		$this->loadUserInfo(true);
	}

	/**
	 * Loads user info and stores it in session object property ($this->userinfo)
	 * for a given user regarding options being passed.
	 *
	 * 	@param 	Int 	Userid to load info
	 * 	@param 	Array 	Extra data passed to consider while loading user information.
	 *					'Options' => list of userinfo options (check vB_Api_User USERINFO_XXXX constants)
	 *					'Languageid' => id from the language to load info from.
	 * 	@param 	Bool 	Determines whether or not fetch cached information.
	 */
	protected function loadUserInfo($nocache = false)
	{
		if (defined('IN_CONTROL_PANEL'))
		{
			$this->userinfo = vB_Library::instance('user')->fetchUserinfo(
				$this->vars['userid'],
				[vB_Api_User::USERINFO_ADMIN],
				$this->vars['languageid'],
				$nocache
			);
		}
		else
		{
			$this->userinfo = vB_Library::instance('user')->fetchUserWithPerms($this->vars['userid'], $this->vars['languageid'], $nocache);
		}

		$this->loadLanguage();
	}
}

/*=========================================================================*\
|| #######################################################################
|| # Downloaded: 12:50, Tue Dec 24th 2024
|| # CVS: $RCSfile$ - $Revision: 116640 $
|| #######################################################################
\*=========================================================================*/
