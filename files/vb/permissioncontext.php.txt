<?php if (!defined('VB_ENTRY')) die('Access denied.');
/*========================================================================*\
|| ###################################################################### ||
|| # vBulletin 6.1.0 Alpha 4 Week 2 - Licence Number VBCW2VFT7A
|| # ------------------------------------------------------------------ # ||
|| # Copyright 2000-2024 MH Sub I, LLC dba vBulletin. All Rights Reserved.  # ||
|| # This file may not be redistributed in whole or significant part.   # ||
|| # ----------------- VBULLETIN IS NOT FREE SOFTWARE ----------------- # ||
|| # http://www.vbulletin.com | http://www.vbulletin.com/license.html   # ||
|| ###################################################################### ||
\*========================================================================*/

class vB_PermissionContext
{
	use vB_Trait_NoSerialize;

	protected $primary_group_id;
	protected $secondary_group_ids;
	protected $infraction_group_ids;
	/**
	 *
	 * @var vB_Datastore
	 */
	protected $datastore;
	protected $group_ids = null;
	protected $permissions = null;
	protected $forumPerms = false;

	/**Once we've checked permissions let's retain that data. **/
	protected $perms = [];
	protected $attachmentPermissions = [];

	// some instance property-cached bitfield results so we can skip
	// re-processing the exact same work when usercontext requests a
	// different field of a permissiongroup we already processed.
	private $cachedChannelIds = [];
	private $cachedInfractionMasks = [];
	private $cachedDefaultGroupPermissives = [];
	private $channelPermissions = [];

	public function __construct($datastore, $primary_group_id, array $secondary_group_ids = [], array $infraction_group_ids = [])
	{
		$this->datastore = $datastore;

		// If $primary_group_id is 0, we assume that it's guest usergroup
		if (!$primary_group_id)
		{
			$primary_group_id = 1;
		}
		$this->primary_group_id = $primary_group_id;
		$this->secondary_group_ids = $secondary_group_ids;
		$this->infraction_group_ids = $infraction_group_ids;

		$this->group_ids = $this->getUserGroups();
		$this->buildBasicPermissions();
	}

	public function getPermission($group)
	{
		return $this->permissions[$group];
	}

	/**
	 * This returns an array with the access for each usergroup passed.
	 *
	 *	@param array|integer $usergroups -- usergroup ids
	 *
	 * 	@return	array on element for each usergroup with the following arrays (each is the
	 * 		array of nodeids the user has the appropriate permissons for)
	 * 			canview
	 * 			canalwaysview
	 *			canaccess
	 *			selfonly
	 *			starteronly
	 *			canseedelnotice
	 *			canpublish
	 */
	public function getAllChannelAccess($usergroups)
	{
		if (!is_array($usergroups))
		{
			$usergroups = [$usergroups];
		}
		$result = [];

		$keys = [];
		foreach($usergroups AS $usergroup)
		{
			$keys[] = 'vBUgChannelAccessG' . $usergroup;
		}
		$this->datastore->preload($keys);

		foreach($usergroups AS $usergroup)
		{
			$access = $this->datastore->getValue('vBUgChannelAccessG' . $usergroup);
			if (!$access)
			{
				// Keep this in sync with getInfractionFilterForChannelAccess()'s $defaultAccess
				$access = [
					'canview'         => [],
					'canalwaysview'   => [],
					'canaccess'       => [],
					'selfonly'        => [],
					'starteronly'     => [],
					'canseedelnotice' => [],
					'canpublish'      => [],
					'canmoderate'     => [],
					'canviewimg'      => [],
					'canviewthumb'    => [],
				];
			}
			$result[$usergroup] = $access;
		}
		return $result;
	}

	/**
	 * This rebuilds the array of channel access by group
	 *
	 * This also sets the datastore keys vBUgChannelPermissionsFrom and vBUgChannelAccess
	 *
	 *  sets datastore values for each group, each datatore entity is an array of channel ids where a user
	 *  in that group has that access
	 * 	-- canview
	 * 	-- canaccess
	 * 	-- selfonly
	 * 	-- starteronly
	 *	-- canseedelnotice
	 *	-- canpublish
	 *	-- canmoderate
	 */
	public function rebuildGroupAccess()
	{
		$bf_ugp = $this->datastore->getValue('bf_ugp_forumpermissions');
		$bf_ugp_f2 = $this->datastore->getValue('bf_ugp_forumpermissions2');
		$bf_mod = $this->datastore->getValue('bf_misc_moderatorpermissions');
		$bf_forum = $this->datastore->getValue('bf_misc_forumoptions');

		$assertor = vB::getDbAssertor();

		//First we need all the channels.
		$channelTypeid = vB_Types::instance()->getContentTypeID('vBForum_Channel');
		$channelParents = $assertor->getColumn(
			'vBForum:node',
			'parentid',
			['contenttypeid' => $channelTypeid],
			false,
			'nodeid'
		);

		//Let's build a permissionsfrom array of $usergroup => array($nodeid => $node the permissions are from)
		$permFrom = [];
		$channelPerms = [];
		$usergroupids = [];
		$usergroupcache = $this->datastore->getValue('usergroupcache');

		if (is_array($usergroupcache))
		{
			foreach ($usergroupcache AS $_groupid => $_unused)
			{
				$permFrom[$_groupid] = [];
				$channelPerms[$_groupid] = [];
				$usergroupids[$_groupid] = $_groupid;
			}
		}
		// save a tiny bit of memory.
		unset($usergroupcache);

		$permQry = $assertor->assertQuery('vBForum:permission');
		foreach ($permQry AS $permissionRec)
		{
			['groupid' => $_groupid, 'nodeid' => $_nodeid] = $permissionRec;
			if (isset($channelParents[$_nodeid]))
			{
				// Self explanatory, but if we have a permission record here, we get perms from here.
				$permFrom[$_groupid][$_nodeid] = $_nodeid;

				$channelPerms[$_groupid][$_nodeid] = [
					'moderatorpermissions' => $permissionRec['moderatorpermissions'],
					'forumpermissions' => $permissionRec['forumpermissions'],
					'forumpermissions2' => $permissionRec['forumpermissions2'],
				];
			}
		}

		// Keep this in sync with getAllChannelAccess()
		$defaultAccess = [
			'canview'         => [],
			'canalwaysview'   => [],
			'canaccess'       => [],
			'selfonly'        => [],
			'starteronly'     => [],
			'canseedelnotice' => [],
			'canpublish'      => [],
			'canmoderate'     => [],
			'canviewimg'      => [],
			'canviewthumb'    => [],
			// any kind of restrictions, either thumbs only or no images at all.
			// This doesn't work well because many special channels are severely restricted
			// while not really being intended for galleries/attachments (e.g. infractions)
			// for mass consumption
			//'imgrestricted'   => [],
		];

		foreach ($usergroupids AS $_groupid)
		{
			$_access = $defaultAccess;
			foreach ($channelParents AS $_channelid => $_unused)
			{
				$_fromId = $this->getPermFrom(
					$permFrom,
					$channelPerms,
					$channelParents,
					$_groupid,
					$_channelid
				);

				// Actually set access stuff.
				if (!empty($_fromId))
				{
					$_fromChannelPerms = &$channelPerms[$_groupid][$_fromId];

					if ($_groupid > 1 AND ($bf_ugp['canseedelnotice'] & $_fromChannelPerms['forumpermissions']) > 0)
					{
						$_access['canseedelnotice'][$_channelid] = $_channelid;
					}

					if ($_groupid > 1 AND ($bf_ugp_f2['canpublish'] & $_fromChannelPerms['forumpermissions2']) > 0)
					{
						$_access['canpublish'][$_channelid] = $_channelid;
					}

					//Can we moderate?
					if ($_groupid > 1 AND (bool) ($bf_mod['canmoderateposts'] & $_fromChannelPerms['moderatorpermissions']))
					{
						$_access['canmoderate'][$_channelid] = $_channelid;
					}
					else if ( (bool) ($bf_ugp_f2['canalwaysview'] & $_fromChannelPerms['forumpermissions2']) )
					{
						$_access['canalwaysview'][$_channelid] = $_channelid;
						$_access['canview'][$_channelid] = $_channelid;
					}
					else if ((bool) ($bf_ugp['canview'] & $_fromChannelPerms['forumpermissions']))
					{
						if (
							(($bf_ugp['canviewothers'] & $_fromChannelPerms['forumpermissions']) > 0) AND
							(($bf_ugp['canviewthreads'] & $_fromChannelPerms['forumpermissions']) > 0)
						)
						{
							$_access['canview'][$_channelid] = $_channelid;
						}
						else if (($bf_ugp['canviewothers'] & $_fromChannelPerms['forumpermissions']) > 0)
						{
							$_access['starteronly'][$_channelid] = $_channelid;
						}
						else
						{
							$_access['selfonly'][$_channelid] = $_channelid;
						}
					}

					// Attachment / Photo visible channels
					$_canGetImgAttach = ($bf_ugp_f2['cangetimgattachment'] & $_fromChannelPerms['forumpermissions2']);
					$_canSeeThumb = ($bf_ugp['canseethumbnails'] & $_fromChannelPerms['forumpermissions']);
					if ($_canGetImgAttach)
					{
						$_access['canviewimg'][$_channelid] = $_channelid;
						$_access['canviewthumb'][$_channelid] = $_channelid;
					}
					else if ($_canSeeThumb)
					{
						$_access['canviewthumb'][$_channelid] = $_channelid;
						//$_access['imgrestricted'][$_channelid] = $_channelid;
					}
					else
					{
						//$_access['imgrestricted'][$_channelid] = $_channelid;
					}
				}
			}

			$this->datastore->build(
				'vBUgChannelAccessG' . $_groupid,
				serialize($_access),
				1,
				false
			);
		}

		//delete any entries for groups that don't exist
		$keys = $this->datastore->getKeys();
		foreach ($keys AS $key)
		{
			$matches = [];
			if (preg_match('#^vBUgChannelAccessG(\d+)$#', $key, $matches))
			{
				$groupid = $matches[1];
				if (!isset($usergroupids[$groupid]))
				{
					$this->datastore->delete($key);
				}
			}
		}

		$this->datastore->build('vBUgChannelPermissionsFrom', serialize($permFrom), 1);

		vB_Cache::allCacheEvent('rebuild_group_access');
	}

	/**
	 * Helper function to fill in permFrom for the channels that inherit permissions.
	 * Returns known permFrom & fills in the gaps as it processes unknowns.
	 */
	private function getPermFrom(&$permFrom, $channelPerms, $channelParents, $_groupid, $_channelid)
	{
		if (empty($permFrom[$_groupid][$_channelid]))
		{
			$_noCircular = 1000000;
			$_fromId = $channelParents[$_channelid];
			$_fillMissingParents = [];
			do
			{
				// We may already know the ancestor's permFrom
				if (isset($permFrom[$_groupid][$_fromId]))
				{
					$_fromId = $permFrom[$_groupid][$_fromId];
					break;
				}
				else if (isset($channelPerms[$_groupid][$_fromId]))
				{
					break;
				}
				$_fillMissingParents[] = $_fromId;
				// if we haven't found a permission record yet, keep crawling up.
				$_fromId = $channelParents[$_fromId] ?? 0;
				$_noCircular--;
			}
			while($_fromId > 0 AND $_noCircular > 0);

			if ($_noCircular == 0)
			{
				// I'm never expecting to hit this, but if this gets hit...
				// They either have more than a million channels straight down
				// with a permission record at the very top, OR the DB is badly
				// hosed. $_fromId isn't trustworthy and DB needs intervention
				throw new Exception('circular_node_parent_references');
			}

			if (empty($_fromId))
			{
				/*
					Again, not expecting to hit this, but this suggests that
					this DB has NO valid permission records for this particular
					channel family line. That MAY be remotely possible in the
					middle of an installation, but in that case we probably
					shouldn't be in here.
					EDIT: Apparently for CMS Author & Editor usergroups, they only
					have a permission record for the Articles channel and no other
					channels by default.
					throw new Exception('no_permissions_for_channel' . json_encode([$_groupid, $_channelid]));
				*/

				// Keeping behavior same as before, store false into the datastore for these
				// cases.
				$_fromId = false;
			}

			// If all went well, $_fromId is the nearest ancestor to $_channelid
			// that has a permission record for $_groupid
			$permFrom[$_groupid][$_channelid] = $_fromId;

			// This would only happen if we're looking things up bottom-up, or if
			// in an unsorted fashion. If we had to look up multiple ancestry levels,
			// no reason to do it again later for any in between.
			foreach ($_fillMissingParents AS $_parentid)
			{
				$permFrom[$_groupid][$_parentid] = $_fromId;
			}
		}

		return $permFrom[$_groupid][$_channelid];
	}

	/**
	 * Returns permissions array. This is used for unit testing
	 *
	 * @param bool $get_bitmap
	 * @param bool $get_limit
	 * @return array
	 */
	public function getPermissions($get_bitmap = TRUE, $get_limit = TRUE)
	{
		$result = array();

		foreach ($this->permissions as $key=>$value)
		{
			if ($this->isLimitPermission($key))
			{
				if ($get_limit)
				{
					$result[$key] = $value;
				}
			}
			else
			{
				if ($get_bitmap)
				{
					$result[$key] = $value;
				}
			}
		}

		return $result;
	}

	public function isLimitPermission($permission)
	{
		$intperms = $this->datastore->getValue('bf_misc_intperms');
		return array_key_exists($permission, $intperms);
	}

	/**
	 * Return an array with usergroups that can provide permissions
	 * Extracted from includes/functions.php::cache_permissions
	 * @return array
	 */
	public function getUserGroups()
	{
		$usergroupcache = $this->datastore->getValue('usergroupcache');
		$bf_ugp_genericoptions = $this->datastore->getValue('bf_ugp_genericoptions');

		$groups = [$this->primary_group_id];

		if ($usergroupcache[$this->primary_group_id]['genericoptions'] & $bf_ugp_genericoptions['allowmembergroups'])
		{
			$groups = array_unique(array_merge($groups, $this->secondary_group_ids));
		}

		return $groups;
	}

	/**
	 * Sets the permissions attribute with basic permissions
	 * Adapted from includes/functions.php::cache_permissions
	 */
	protected function buildBasicPermissions()
	{
		//If we have infraction group let's get the overriding perm usergroup
		$assertor = vB::getDbAssertor();
		$groupIds = [];
		if (!empty($this->infraction_group_ids))
		{
			foreach ($this->infraction_group_ids as $group)
			{
				// user.infractiongroupid links to infractiongroup.orusergroupid.
				// See vB_Library_Content_Infraction->fetchInfractionGroups() & buildInfractionGroupIds()
				$groupInfo = $assertor->getRow('infractiongroup', array(vB_dB_Query::TYPE_KEY => vB_dB_Query::QUERY_SELECT,
					'orusergroupid' => $group ));

				if (!empty($groupInfo))
				{
					$groupIds[] = $groupInfo['orusergroupid'];
				}
			}

			$this->infraction_group_ids = array_unique($groupIds);
		}

		$usergroupcache = $this->datastore->getValue('usergroupcache');
		$bf_ugp = $this->datastore->getValue('bf_ugp');
		$bf_misc_intperms = $this->datastore->getValue('bf_misc_intperms');

		if (count($this->group_ids) == 1)
		{
			$permissions = $usergroupcache[$this->group_ids[0]];
		}
		else
		{
			// initialise fields to 0
			foreach ($bf_ugp AS $dbfield => $permfields)
			{
				$permissions["$dbfield"] = 0;
			}

			// return the merged array of all user's membergroup permissions
			foreach ($this->group_ids AS $usergroupid)
			{
				$usergroup = $usergroupcache[$usergroupid];

				foreach ($bf_ugp AS $dbfield => $permfields)
				{
					//Some permissions- initially the create permissions- are only available at the channel level.
					if (isset($usergroup[$dbfield]))
					{
						$permissions[$dbfield] |= $usergroup[$dbfield];
					}
				}

				foreach ($bf_misc_intperms AS $dbfield => $precedence)
				{
					// put in some logic to handle $precedence
					if (!isset($intperms[$dbfield]))
					{
						$intperms[$dbfield] = $usergroup[$dbfield];
					}
					else if (!$precedence)
					{
						if ($usergroup[$dbfield] > $intperms[$dbfield])
						{
							$intperms[$dbfield] = $usergroup[$dbfield];
						}
					}
					else if ($usergroup[$dbfield] == 0 OR (isset($intperms[$dbfield]) AND $intperms[$dbfield] == 0))
					{
						// Set value to 0 as it overrides all
						$intperms[$dbfield] = 0;
					}
					else if ($usergroup[$dbfield] > $intperms[$dbfield])
					{
						$intperms[$dbfield] = $usergroup[$dbfield];
					}
				}
			}
			$permissions = array_merge($permissions, $intperms);
		}

		if (!empty($this->infraction_group_ids))
		{
			foreach ($this->infraction_group_ids AS $usergroupid)
			{
				foreach ($bf_ugp AS $dbfield => $permfields)
				{
					if (isset($usergroupcache[$usergroupid][$dbfield]))
					{
						$permissions[$dbfield] &= $usergroupcache[$usergroupid][$dbfield];
					}
				}
				foreach ($bf_misc_intperms AS $dbfield => $precedence)
				{
					if (!$precedence)
					{
						if ($usergroupcache["$usergroupid"]["$dbfield"] < $permissions["$dbfield"])
						{
							$permissions["$dbfield"] = $usergroupcache["$usergroupid"]["$dbfield"];
						}
					}
					else if ($usergroupcache["$usergroupid"]["$dbfield"] < $permissions["$dbfield"] AND $usergroupcache["$usergroupid"]["$dbfield"] != 0)
					{
						$permissions["$dbfield"] = $usergroupcache["$usergroupid"]["$dbfield"];
					}
				}
			}
		}

		$this->permissions = & $permissions;
	}

	/**
	 * Does this group have the requested system permissions
	 *
	 * @param string $group Permission group the permission is in
	 * @param string $permission Name of permission
	 * @return boolean
	 */
	public function hasPermission($group, $permission)
	{
		if (!$this->isLimitPermission($permission))
		{
			$bf_ugp = $this->datastore->getValue('bf_ugp_' . $group);
			// Note, this->permissions is checking the basic "usergroup" permission, and should
			// already have the infraction group masking applied in buildBasicPermissions().
			// For channel permissions, use getChannelPermissionGroup() which does the channel
			// specific infraction group masking.
			if (isset($this->permissions[$group]) AND isset($bf_ugp[$permission]))
			{
				return (bool) ($this->permissions[$group] & $bf_ugp[$permission]);
			}
			else
			{
				return false;
			}
		}
		else
		{
			// todo: throw an exception?
			return false;
		}
	}

	public function getLimit($permission)
	{
		if ($this->isLimitPermission($permission))
		{
			return $this->permissions[$permission];
		}
		else
		{
			// this is not an intperm, throw an exception?
			return -1;
		}
	}


	/**
	 * Returns the available permissions
	 *
	 * @return array
	 */
	public function getForumPerms()
	{
		if ($this->forumPerms === false)
		{
			$this->forumPerms = $this->datastore->getValue('bf_ugp');
		}
		return $this->forumPerms;
	}

	/**
	 * Build and caches the permissions array
	 */
	protected function buildPerms()
	{
		//we need to build the permissions.
		//Most of the time the user will have access to the root. If that's the case
		// then we can ignore all the other read access values.
		$perms = [];
		//let's get a list of all the groups and their CMS access
		$assertor = vB::getDbAssertor();

		//we might be able to pull this from cache but keeping it closer to previous behavior for the moment.
		$groupquery = $assertor->select('usergroup', [], false, ['usergroupid']);

		$sections = [];
		$parents = [];

		foreach($groupquery AS $groupinfo)
		{
			$perms[$groupinfo['usergroupid']] = [
				'canRead' => [],
				'cantRead' => [],
				'selfOnly' => [],
				'starterOnly' => [],
				'canModerate' => [],
				'cantModerate' => [],
			];
		}

		$bf_ugp = $this->datastore->getValue('bf_ugp_forumpermissions');
		$bf_ugp_f2 = $this->datastore->getValue('bf_ugp_forumpermissions2');
		$bf_mod = $this->datastore->getValue('bf_misc_moderatorpermissions');

		//Now get the permissions.
		$permquery = $assertor->assertQuery('vBForum:permission', []);
		foreach($permquery AS $permission)
		{
			$canview = ($permission['forumpermissions'] & $bf_ugp['canview']);
			$canviewthreads = ($permission['forumpermissions'] & $bf_ugp['canviewthreads']);
			$canviewothers = ($permission['forumpermissions'] & $bf_ugp['canviewothers']);
			$canalwaysview = ($permission['forumpermissions2'] & $bf_ugp_f2['canalwaysview']);

			if (($canview AND $canviewthreads AND $canviewothers) OR $canalwaysview)
			{
				$perms[$permission['groupid']]['canRead'][] = $permission['nodeid'];
			}
			else if ($canview AND $canviewothers)
			{
				$perms[$permission['groupid']]['starterOnly'][] = $permission['nodeid'];
			}
			else if ($canview AND $canviewthreads)
			{
				$perms[$permission['groupid']]['selfOnly'][] = $permission['nodeid'];
			}
			else
			{
				$perms[$permission['groupid']]['cantRead'][] = $permission['nodeid'];
			}

			if ($permission['moderatorpermissions'] & $bf_mod['canmoderateposts'])
			{
				$perms[$permission['groupid']]['canModerate'][] = $permission['nodeid'];
			}
			else
			{
				$perms[$permission['groupid']]['cantModerate'][] = $permission['nodeid'];
			}
		}

		$this->perms = $perms;

		$hashkey = 'vb_readperms';
		vB_Cache::instance()->write($hashkey, $perms, 1440, 'perms_changed');
		return $perms;
	}

	public function isNumericPermission($permission)
	{
		/*
		Old getChannelPerm() used to perform the following check instead:

			$permFields = vB_ChannelPermission::fetchPermFields();
			if (isset($permFields[$permission]) AND $permFields[$permission] != vB_ChannelPermission::TYPE_BITMAP)
			{
				return true;
			}
			return false;

		For now, going with the hard-coded check that was used in userContext().

		TODO:
		We may want to consolidate with $this->isLimitPermission() at some point.
		However, I'm not sure if that works with channel permissions as well or only
		usergroup permissions.

		This function is based on the usercontext code and I needed it accessible
		to both usercontext & permissioncontext, and I want to limit the changes as
		much as possible as the other changes are already pretty risky.
		The reason I didn't make the usercontext property public or add an accessor
		is to reduce possibilities of circular dependencies between this & usercontext.
		In general usercontext should be calling permissioncontext, not vice versa.
		 */

		//If you change this, make sure you change the channelpermissions $permissionFields array
		$countFields = [
			'edit_time' => 'hours',
			'maxtags' => 'count',
			'maxstartertags' =>'count',
			'maxothertags' => 'count',
			'maxattachments' =>'count',
			'maxchannels' =>'count',
			'channeliconmaxsize' => 'count'
		];

		return isset($countFields[$permission]);
	}

	public function getChannelid($nodeid)
	{
		if (isset($this->cachedChannelIds[$nodeid]))
		{
			return $this->cachedChannelIds[$nodeid];
		}

		// See old usercontext::getChannelIdOfNode() (I think some results were implicitly cached
		// via the node library)
		$assertor = vB::getDbAssertor();
		['channelid' => $channelid] = $assertor->getRow('getNearestChannel', ['nodeid' => $nodeid,]);

		$this->cachedChannelIds[$nodeid] = $channelid;

		return $channelid;
	}


	// For usergroups acting like primary & secondary groups, where they are all permissive
	// (bitwise ORs). For infraction like masking (restrictive), see getChannelPermissionGroupInfractionMask()
	public function getChannelPermissiongroupPermissives($usergroups, $permissiongroup, $channelid)
	{
		if (!is_array($usergroups))
		{
			$usergroups = [$usergroups];
		}

		$permissionsFrom = $this->datastore->getValue('vBUgChannelPermissionsFrom');
		/*
			The old usercontext had logic to look for the parent if it failed
			to find the ChannelPermissionsFrom map for the requested nodeid.
			The thing is, that was meant for starter nodes, and not channels,
			based on the comment, but just happened to work in the case of
			when creating a new channel (e.g. creating a blog channel), and
			trying to check view permissions on it as part of the channel
			page creation/buildURL() that causes vB5_Route_Channel constructor
			to try to do a permission check BEFORE vBUgChannelPermissionsFrom
			was rebuilt with the newly added channel information.
			This once lookup is inconsistent, but left to continue supporting
			that old, incorrect but vital behavior.
		 */
		try
		{
			//calling the library from this class is problematic because library functions tend to rely on
			//the session being fully formed.
			$node = vB_Library::instance('node')->getNodeBare($channelid);
			$parentid = $node['parentid'];
		}
		catch (Exception $e)
		{
			// Apparently, this can happen frequently when channels get deleted in tests,
			// because groupintopic records, as far as I can tell, are not properly
			// cleaned up (or in the right order?), and during reloadUserPerms()
			// the deleted channel is still in the groupintopic records and
			// getAllChannelAccess() tries to build up permissions using that record.
			// I have no idea atm if this actually happens in the wild.
			// Quietly skip.
			$parentid = null;
		}
		// start with 0b0, fill it with ORs from groups
		$collapsedPermGroup = 0;
		foreach ($usergroups AS $__usergroupid)
		{
			$this->loadChannelPermissions($__usergroupid);
			// If we can't figure out even after checking the parent (or parent is missing because
			// channelid is invalid), there's nothing we can do. Skip this.
			$__fromChannelid = $permissionsFrom[$__usergroupid][$channelid] ??
								$permissionsFrom[$__usergroupid][$parentid] ??
								null;
			if (empty($__fromChannelid))
			{
				continue;
			}

			$__thispermgroup = $this->channelPermissions[$__usergroupid][$__fromChannelid][$permissiongroup] ?? 0;
			$collapsedPermGroup |= $__thispermgroup;
		}

		return $collapsedPermGroup;
	}

	public function getChannelPermissionGroup($permissiongroup, $nodeid)
	{
		$channelid = $this->getChannelid($nodeid);
		if (empty($channelid))
		{
			// invalid nodeid or possibly a severely broken closure record?
			// In any case we don't have enough information here. Return some
			// default blocking permissions
			return false;
		}

		// start with 0b0, fill it with ORs from groups, then remove with ANDs from any infraction
		// groups.
		// $this->group_ids are primary & secondary (iff secondaries are set AND primary allows membergroups)
		if (isset($this->cachedDefaultGroupPermissives[$channelid][$permissiongroup]))
		{
			$collapsedPermGroup = $this->cachedDefaultGroupPermissives[$channelid][$permissiongroup];
		}
		else
		{
			// cache this result so we don't re-do the work for this "group" (e.g. forumpermissions2).
			// Can't cache in the below function ATM since it accepts a generic list of usergroups.
			$collapsedPermGroup = $this->getChannelPermissiongroupPermissives($this->group_ids, $permissiongroup, $channelid);
			$this->cachedDefaultGroupPermissives[$channelid][$permissiongroup] = $collapsedPermGroup;
		}
		// infraction mask is cached in the below function.
		$infractionMask = $this->getChannelPermissionGroupInfractionMask($permissiongroup, $channelid);

		$collapsedPermGroup &= $infractionMask;

		return $collapsedPermGroup;
	}

	// We may want to make this accept usergroupids instead of using the baked in infraction group ids (provided
	// at instantiation). ATM I haven't seen anything that needs it yet, so leaving the infraction group ids.
	public function getChannelPermissionGroupInfractionMask($permissiongroup, $channelid)
	{
		if (isset($this->cachedInfractionMasks[$channelid][$permissiongroup]))
		{
			return $this->cachedInfractionMasks[$channelid][$permissiongroup];
		}

		// start with all ones
		$collapsedPermGroup = ~0;

		$permissionsFrom = $this->datastore->getValue('vBUgChannelPermissionsFrom');
		// infraction groups, these will be restrictive (bitwise ANDs)
		foreach ($this->infraction_group_ids AS $__usergroupid)
		{
			$this->loadChannelPermissions($__usergroupid);
			$__fromChannelid = $permissionsFrom[$__usergroupid][$channelid] ?? null;
			if (empty($__fromChannelid))
			{
				// something's broken and we can't figure this out... just skip for now.
				// Not known to happen in the wild.
				continue;
			}

			// This could be problematic if channelPermissions are not fully populated for whatever reason,
			// as it'll have the effect of disabling this permission group. Not known to happen atm.
			$__thispermgroup = $this->channelPermissions[$__usergroupid][$__fromChannelid][$permissiongroup] ?? 0;
			$collapsedPermGroup &= $__thispermgroup;
		}

		$this->cachedInfractionMasks[$channelid][$permissiongroup] = $collapsedPermGroup;

		return $collapsedPermGroup;
	}

	// This is meant to be the numeric-permissions version of getChannelPermissionGroup(), but
	// the use cases in usercontext also commonly checks for groupintopic records, so allowing this
	// to accept arbitrary usergroups, not just primary/secondary.
	// Also applies the infractiongroup restrictions
	public function getGroupsChannelLimitPermission($usergroups, $permissiongroup, $permission, $channelid)
	{
		/*
		For limit usergroup options (not these current channel permissions), it seems like
		whether 0 means unlimited or not depends on the "precedence" check, see buildBasicPermissions().

		Per option description,
			'edit_time" of 0 means unlimited
		Per usage in vB_Tags::filterTagListContentLimits()
			'maxtags', 'maxstartertags' & 'maxothertags' of 0 mean unlimited

		Per usage in vB_Api_Node::addAttachment(),
			'maxattachments' of 0 means unlimited

		Per usage in vB_Api_Content_Channel::canAddChannel(),
			'maxchannels' of 0 means unlimited

		Per usage in vB_Api_Content_Channel::validateIcon(),
			'channeliconmaxsize' of 0 means unlimited

		These happen to be all currenly available channel limit options, but doing it this way to
		future proof it.
		 */
		$zeroIsUnlimited = [
			'edit_time' => 1,
			'maxtags' => 1,
			'maxstartertags' => 1,
			'maxothertags' => 1,
			'maxattachments' => 1,
			'maxchannels' => 1,
			'channeliconmaxsize' => 1,
		];

		// I'm not sure if this can ever happen unless the caller goofs, and I have absolutely no idea
		// what the proper response is. But our usercontext code does not seem very sure of itself,
		// so this inherits the uncertaintly.
		if (!$this->isNumericPermission($permission))
		{
			throw new Exception('unknown_limit_permission');
		}


		// 0 means unlimited in a lot of cases (all current cases for channel limits, and I think
		// most cases for usergroup limits) but this was the default that the old usercontext code
		// started off with.
		$returnValue = 0;
		// See note in getChannelPermissiongroupPermissives() about parentid and outdated groupintopic data
		try
		{
			//calling the library from this class is problematic because library functions tend to rely on
			//the session being fully formed.
			$node = vB_Library::instance('node')->getNodeBare($channelid);
			$parentid = $node['parentid'];
		}
		catch (Exception $e)
		{
			// Quietly skip.
			$parentid = null;
		}

		$permissionsFrom = $this->datastore->getValue('vBUgChannelPermissionsFrom');

		foreach ($usergroups AS $__usergroupid)
		{
			$this->loadChannelPermissions($__usergroupid);
			$__fromChannelid = $permissionsFrom[$__usergroupid][$channelid] ??
								$permissionsFrom[$__usergroupid][$parentid] ??
								null;
			if (empty($__fromChannelid))
			{
				continue;
			}

			// I'm not under what conditions this channel permission might not be set, but the old
			// getChannelPerm() used to check this, so keeping the check in for now...
			if (!isset($this->channelPermissions[$__usergroupid][$__fromChannelid][$permission]))
			{
				continue;
			}

			$__thisLimit = $this->channelPermissions[$__usergroupid][$__fromChannelid][$permission] ?? null;
			if (isset($zeroIsUnlimited[$permission]) AND $__thisLimit === 0)
			{
				$returnValue = 0;
				break;
			}
			else
			{
				$returnValue = max($returnValue, $__thisLimit);
			}
		}

		// infraction groups, these will be restrictive (minimum sans 0)
		foreach ($this->infraction_group_ids AS $__usergroupid)
		{
			$this->loadChannelPermissions($__usergroupid);
			// Unlike getChannelPermissionGroupInfractionMask(), we are not guaranteeing that the caller
			// passes us a valid nodeid/channelid, so we should do the same parentid check as above block
			// in case data is wonky during tests etc.
			$__fromChannelid = $permissionsFrom[$__usergroupid][$channelid] ??
								$permissionsFrom[$__usergroupid][$parentid] ??
								null;
			if (empty($__fromChannelid))
			{
				continue;
			}

			$__thisLimit = $this->channelPermissions[$__usergroupid][$__fromChannelid][$permission] ?? null;
			if (isset($zeroIsUnlimited[$permission]) AND $__thisLimit === 0)
			{
				// this infraction group does not limit this permission, move onto the next infraction group
				continue;
			}
			else
			{
				$returnValue = min($returnValue, $__thisLimit);
			}
		}

		return $returnValue;
	}

	public function getChannelPermission($permissiongroup, $permission, $nodeid)
	{
		if ($this->isNumericPermission($permissiongroup))
		{
			$channelid = $this->getChannelid($nodeid);
			return $this->getGroupsChannelLimitPermission($this->group_ids, $permissiongroup, $permissiongroup, $channelid);
		}


		$collapsedPermGroup = $this->getChannelPermissionGroup($permissiongroup, $nodeid);

		$bf_ugp = $this->getBitfield($permissiongroup);

		if (empty($bf_ugp[$permission]))
		{
			// invalid permissiongroup/permissionbit?
			return false;
		}

		return ($bf_ugp[$permission] & $collapsedPermGroup);
	}

	public function getBitfield($permissiongroup)
	{
		if ($permissiongroup == 'moderatorpermissions')
		{
			$bf_ugp = $this->datastore->getValue('bf_misc_' . $permissiongroup);
		}
		else
		{
			$bf_ugp = $this->datastore->getValue('bf_ugp_' . $permissiongroup);
		}

		return $bf_ugp;
	}

	/**
	 * Clears all existing permissions. Needed primarily in test.
	 *
	 * @param	int	$usergroupid (optional)
	 */
	public function clearChannelPermissions($usergroupid = false)
	{
		if ($usergroupid)
		{
			unset($this->channelPermissions[$usergroupid]);
			unset($this->perms[$usergroupid]);
		}
		else
		{
			$this->channelPermissions = [];
			$this->buildPerms();
		}

		$this->cachedChannelIds = [];
		$this->cachedInfractionMasks = [];
		$this->cachedDefaultGroupPermissives = [];

		$this->buildBasicPermissions();

		if ($usergroupid)
		{
			$this->loadChannelPermissions($usergroupid);
		}
	}

	/**
	 * This loads a permission group from the database and caches the results
	 *
	 * @param 	int		$usergroupid
	 */
	public function loadChannelPermissions($usergroupid)
	{
		$hashkey = 'channelperms_' . $usergroupid;
		$writelock = true;

		if (isset($this->channelPermissions[$usergroupid]))
		{
			return;
		}

		$this->channelPermissions[$usergroupid] = vB_Cache::instance()->read($hashkey, $writelock, false);

		//See if we got a result.
		if ($this->channelPermissions[$usergroupid] === false)
		{
			$permissions = vB::getDbAssertor()->getRows('vBForum:permission', ['groupid' => $usergroupid], false, 'nodeid');

			if (empty($permissions) OR !empty($permissions['errors']))
			{
				$this->channelPermissions[$usergroupid] = [];
			}
			else
			{
				$this->channelPermissions[$usergroupid] = $permissions;
			}
			vB_Cache::instance()->write($hashkey, $this->channelPermissions[$usergroupid], 1440, 'perms_changed');
		}
	}

	/**
	 * Gets any admin usergroups. This is defined as one that can administer permissions
	 *
	 * @return	array -- user groupids
	 */
	public static function getAdminUsergroups($all = true)
	{
		$datastore = vB::getDatastore();
		$usergroupcache = $datastore->getValue('usergroupcache');
		$bf_ugp = $datastore->getValue('bf_ugp');
		$adminMask = $bf_ugp['adminpermissions']['cancontrolpanel'];

		$group = 0;
		$groups = array();
		if (is_array($usergroupcache))
		{
			foreach($usergroupcache AS $usergroup)
			{
				if ($usergroup['adminpermissions'] & $adminMask)
				{
					if ($all)
					{
						$groups[] = $usergroup['usergroupid'];
					}
					else
					{
						$group = ($group ? $group : $usergroup['usergroupid']);
					}
				}
			}
		}

		return ($all ? $groups : $group);
	}

	/**
	 * Gets an admin user. This is defined as one that can administer the admincp
	 *
	 * return	false|integer		a userid with admin permissions, false if not found
	 */
	public static function getAdminUser()
	{
		//First see if we have somebody configured as superadmin.
		$config = vB::getConfig();
		if (!empty($config['SpecialUsers']['superadmins']))
		{
			$superAdmins = explode(",", $config['SpecialUsers']['superadmins']);

			//check the db to ensure that any admins users in the config file actually exist
			$superAdmins = vB::getDbAssertor()->getColumn('user', 'userid', array('userid' => $superAdmins));

			if (!empty($superAdmins))
			{
				return (int) current($superAdmins);
			}
		}

		//See if we have somebody with an admin user as primary usergroup
		$usergroups = self::getAdminUsergroups();

		if (empty($usergroups))
		{
			return false;
		}

		$user = vB::getDbAssertor()->getRow('user', array(vB_dB_Query::TYPE_KEY => vB_dB_Query::QUERY_SELECT,
			vB_dB_Query::COLUMNS_KEY => 'userid', 'usergroupid' => $usergroups));

		if (!empty($user))
		{
			return $user['userid'];
		}

		// VBV-11898 - Nothing prevents a user from having an admin group as a secondary group, but with a primary
		// group that doesn't allow member groups. So we should check that the returned user's primary group does allow it.
		$datastore = vB::getDatastore();
		$usergroupcache = $datastore->getValue('usergroupcache');
		$bf_ugp_genericoptions = $datastore->getValue('bf_ugp_genericoptions');
		$allowsmembergroups = array();
		foreach ($usergroupcache AS $groupid => $groupdata)
		{
			if ($groupdata['genericoptions'] & $bf_ugp_genericoptions['allowmembergroups'])
			{
				$allowsmembergroups[] = $groupid;
			}
		}

		//Last chance- see if we have somebody who has one of the admin groups as a secondary id. This is potentially very expensive.
		//so it's a real last resort.
		$data = array(vB_dB_Query::TYPE_KEY => vB_dB_Query::QUERY_SELECT,
			vB_dB_Query::CONDITIONS_KEY => array(array('field' => 'membergroupids', vB_dB_Query::OPERATOR_KEY => vB_dB_Query::OPERATOR_INCLUDES)));
		$assertor = vB::getDbAssertor();
		foreach($usergroups AS $usergroup)
		{
			$data[vB_dB_Query::CONDITIONS_KEY][0]['value'] = $usergroup;
			$test = $assertor->assertQuery('user', $data);
			//There's a dangerous condition we need to check. Let's say a site has more than eleven usergroups, and usergroup 2 has the admin permission. We need to
			//may have gotten usergroup 12 or 20.
			if ($test->valid())
			{
				foreach($test as $user)
				{
					$memberGroups = explode(',', $user['membergroupids']);
					if (in_array($usergroup,$memberGroups) AND in_array($user['usergroupid'], $allowsmembergroups))
					{
						return $user['userid'];
					}
				}
			}
		}
		//out of things to try;
		return false;
	}

	/**
	 * Get the attachment limits for an extension and usergroupid. If that usergroup does not have permission
	 *	or the extension is not in the list of allowed extensions, return false.
	 *	Note: This is only constrained to the attachmenttype and attachmentpermission tables. The create permissions
	 *	for all attachments are handled in the channels.
	 *	TODO: Make this part of the channel permissions
	 *
	 *	@param int $group Permission group the permission is in
	 *	@param string $permission Name of permission
	 *
	 *	@return	boolean|array	false if not enabled for the usergroupid. array of limits if its enabled.
	 */
	public function getAttachmentPermissions($usergroupid, $extension)
	{
		$extension = vB_String::vBStrToLower($extension);
		if (!isset($this->attachmentPermissions[$extension]))
		{
			$extensionPerms = array();
			$allAttachperms = vB::getDbAssertor()->getRows('vBForum:fetchAttachPermsByExtension', array('extension' => $extension));

			if (empty($allAttachperms))
			{
				$this->attachmentPermissions[$extension] = false;
			}
			else
			{
				foreach($allAttachperms AS $attachPerms)
				{
					if (!isset($extensionPerms['default']))
					{
						// First set the defaults set in the attachmenttype table
						$defaultPerms = array();
						$defaultPerms['height'] = !empty($attachPerms['default_height']) ? $attachPerms['default_height'] : 0;
						$defaultPerms['width'] = !empty($attachPerms['default_width']) ? $attachPerms['default_width'] : 0;
						$defaultPerms['size'] = !empty($attachPerms['default_size']) ? $attachPerms['default_size'] : 0;
						$extensionPerms['default'] = $defaultPerms;
					}

					if (!empty($attachPerms['usergroupid']))
					{
						// Now set individual permissions for the usergroups.
						if (empty($attachPerms['custom_permissions']))
						{
							// The usergroup doesn't have permission to use this extension
							$extensionPerms[$attachPerms['usergroupid']] = false;
						}
						else
						{
							// The usergroup has permission to use this extension.
							$customPerms = array();
							$customPerms['height'] = ($attachPerms['custom_height'] !== null) ? $attachPerms['custom_height'] : $extensionPerms['default']['height'];
							$customPerms['width'] = ($attachPerms['custom_width'] !== null) ? $attachPerms['custom_width'] : $extensionPerms['default']['width'];
							$customPerms['size'] = ($attachPerms['custom_size'] !== null) ? $attachPerms['custom_size'] : $extensionPerms['default']['size'];
							$extensionPerms[$attachPerms['usergroupid']] = $customPerms;
							unset($customPerms);
						}
					}
				}

				$this->attachmentPermissions[$extension] = $extensionPerms;
			}
		}

		if (isset($this->attachmentPermissions[$extension]) AND !empty($this->attachmentPermissions[$extension]))
		{
			if (isset($this->attachmentPermissions[$extension][$usergroupid]))
			{
				// We have custom permissions, use those. Could be false if this usergroup has no permissions for this extension.
				return $this->attachmentPermissions[$extension][$usergroupid];
			}
			else
			{
				// Use the defaults. Custom permissions not set, so it's allowed.
				return $this->attachmentPermissions[$extension]['default'];
			}
		}

		// This extension is not allowed.
		return false;
	}

	/**
	 * Clear out the attachment permissions.
	 */
	public function clearAttachmentPermissions()
	{
		$this->attachmentPermissions = array();
	}
}

/*=========================================================================*\
|| #######################################################################
|| # Downloaded: 12:50, Tue Dec 24th 2024
|| # CVS: $RCSfile$ - $Revision: 111130 $
|| #######################################################################
\*=========================================================================*/
